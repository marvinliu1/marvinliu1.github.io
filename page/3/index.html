<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#64CEAA"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#64CEAA">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"marvinliu1.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Take in the good!">
<meta property="og:type" content="website">
<meta property="og:title" content="Marvin&#39;s Blog">
<meta property="og:url" content="https://marvinliu1.github.io/page/3/index.html">
<meta property="og:site_name" content="Marvin&#39;s Blog">
<meta property="og:description" content="Take in the good!">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Marvin Liu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://marvinliu1.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Marvin's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Marvin's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Marvin's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>links</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Marvin Liu"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Marvin Liu</p>
  <div class="site-description" itemprop="description">Take in the good!</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/marvinliu1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;marvinliu1" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:liuyongquan2010@gmail.com" title="E-Mail → mailto:liuyongquan2010@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


<div style="color:white;">document.designMode='on'</div>

        </div>
      </div>
    </div>
    
    <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
    <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
    <div class="widget-wrap">
        <h3 class="widget-title">Tags</h3>
        <div id="myCanvasContainer" class="widget tagcloud">
            <canvas width="250" height="250" id="resCanvas" style="width=100%">
                <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Debugging/" rel="tag">Debugging</a><span class="tag-list-count">30</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/" rel="tag">Javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MarkDown/" rel="tag">MarkDown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NeXt/" rel="tag">NeXt</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Next/" rel="tag">Next</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node/" rel="tag">Node</a><span class="tag-list-count">30</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nohup/" rel="tag">Nohup</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nuxt/" rel="tag">Nuxt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">2</span></li></ul>
            </canvas>
        </div>
    </div>
    
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/marvinliu1" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://marvinliu1.github.io/2019/06/21/Adding-tag-cloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marvin Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marvin's Blog">
      <meta itemprop="description" content="Take in the good!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Marvin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/06/21/Adding-tag-cloud/" class="post-title-link" itemprop="url">Adding Tag-Cloud</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-06-21 00:26:30" itemprop="dateCreated datePublished" datetime="2019-06-21T00:26:30-06:00">2019-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a>
        </span>
    </span>

  
    <span id="/2019/06/21/Adding-tag-cloud/" class="post-meta-item leancloud_visitors" data-flag-title="Adding Tag-Cloud" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="Step-1-Install-the-plugin-hexo-tag-cloud"><a href="#Step-1-Install-the-plugin-hexo-tag-cloud" class="headerlink" title="Step 1: Install the plugin hexo-tag-cloud"></a>Step 1: Install the plugin hexo-tag-cloud</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-tag-cloud@^2.0.* --save</span><br></pre></td></tr></table></figure>
<h3 id="Step-2-Configuration"><a href="#Step-2-Configuration" class="headerlink" title="Step 2: Configuration"></a>Step 2: Configuration</h3><h4 id="For-the-Swig"><a href="#For-the-Swig" class="headerlink" title="For the Swig"></a>For the Swig</h4><p>Locate the file <code>bash theme/next/layout/_macro/sidebar.swig</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> site.tags.length &gt; 1 %&#125;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span> src=<span class="string">&quot;/js/tagcloud.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span> src=<span class="string">&quot;/js/tagcanvas.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;div class=<span class="string">&quot;widget-wrap&quot;</span>&gt;</span><br><span class="line">    &lt;h3 class=<span class="string">&quot;widget-title&quot;</span>&gt;标签云&lt;/h3&gt;</span><br><span class="line">    &lt;div <span class="built_in">id</span>=<span class="string">&quot;myCanvasContainer&quot;</span> class=<span class="string">&quot;widget tagcloud&quot;</span>&gt;</span><br><span class="line">        &lt;canvas width=<span class="string">&quot;250&quot;</span> height=<span class="string">&quot;250&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;resCanvas&quot;</span> style=<span class="string">&quot;width=100%&quot;</span>&gt;</span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        &lt;/canvas&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h4 id="For-the-ejs"><a href="#For-the-ejs" class="headerlink" title="For the ejs"></a>For the ejs</h4><p>Located the file <code>bash hexo/themes/landscape/layout/_widget/tagcloud.ejs </code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;% <span class="keyword">if</span> (site.tags.length) &#123; %&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span> src=<span class="string">&quot;/js/tagcloud.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span> charset=<span class="string">&quot;utf-8&quot;</span> src=<span class="string">&quot;/js/tagcanvas.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div class=<span class="string">&quot;widget-wrap&quot;</span>&gt;</span><br><span class="line">        &lt;h3 class=<span class="string">&quot;widget-title&quot;</span>&gt;Tag Cloud&lt;/h3&gt;</span><br><span class="line">        &lt;div <span class="built_in">id</span>=<span class="string">&quot;myCanvasContainer&quot;</span> class=<span class="string">&quot;widget tagcloud&quot;</span>&gt;</span><br><span class="line">            &lt;canvas width=<span class="string">&quot;250&quot;</span> height=<span class="string">&quot;250&quot;</span> <span class="built_in">id</span>=<span class="string">&quot;resCanvas&quot;</span> style=<span class="string">&quot;width=100%&quot;</span>&gt;</span><br><span class="line">                &lt;%- tagcloud() %&gt;</span><br><span class="line">            &lt;/canvas&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<h4 id="For-the-jade"><a href="#For-the-jade" class="headerlink" title="For the jade"></a>For the jade</h4><p>Locate the file <code>bash apollo/layout/archive.jade </code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">block container</span><br><span class="line">    include mixins/post</span><br><span class="line">    .archive</span><br><span class="line">        h2(class=<span class="string">&#x27;archive-year&#x27;</span>)= <span class="string">&#x27;Tag Cloud&#x27;</span></span><br><span class="line">        script(<span class="built_in">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>, charset=<span class="string">&#x27;utf-8&#x27;</span>, src=<span class="string">&#x27;/oj-code/js/tagcloud.js&#x27;</span>)</span><br><span class="line">        script(<span class="built_in">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>, charset=<span class="string">&#x27;utf-8&#x27;</span>, src=<span class="string">&#x27;/oj-code/js/tagcanvas.js&#x27;</span>)</span><br><span class="line">        <span class="comment">#myCanvasContainer.widget.tagcloud(align=&#x27;center&#x27;)</span></span><br><span class="line">            canvas<span class="comment">#resCanvas(width=&#x27;500&#x27;, height=&#x27;500&#x27;, style=&#x27;width=100%&#x27;)</span></span><br><span class="line">                !=tagcloud()</span><br><span class="line">            !=tagcloud()</span><br><span class="line">    +postList()</span><br></pre></td></tr></table></figure>
<h3 id="Step-3-Config-the-theme"><a href="#Step-3-Config-the-theme" class="headerlink" title="Step 3: Config the theme"></a>Step 3: Config the theme</h3><p>Locate the config file in your theme folder <code>bash _config.yml </code></p>
<p>Adding new lines below in the end of the config file</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hexo-tag-cloud</span></span><br><span class="line">tag_cloud:</span><br><span class="line">    textFont: Trebuchet MS, Helvetica</span><br><span class="line">    textColor: <span class="string">&#x27;#333&#x27;</span></span><br><span class="line">    textHeight: 25</span><br><span class="line">    outlineColor: <span class="string">&#x27;#E2E1D1&#x27;</span></span><br><span class="line">    maxSpeed: 0.1</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://marvinliu1.github.io/2019/06/20/3.7.1%20uncaughtException/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marvin Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marvin's Blog">
      <meta itemprop="description" content="Take in the good!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Marvin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/06/20/3.7.1%20uncaughtException/" class="post-title-link" itemprop="url">Node in Debugging, 3.7 UncaughtException</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-06-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-20T00:00:00-06:00">2019-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Node-in-Debugging/" itemprop="url" rel="index"><span itemprop="name">Node in Debugging</span></a>
        </span>
    </span>

  
    <span id="/2019/06/20/3.7.1%20uncaughtException/" class="post-meta-item leancloud_visitors" data-flag-title="Node in Debugging, 3.7 UncaughtException" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging">Node in Debugging</a></p>
<p>相信所有 Node.js 开发者都对 <code>TypeError: Cannot read property &#39;xxx&#39; of undefined/null</code> 这种错误并不陌生，这是因为期望从一个对象上获取 xxx 属性，结果这个对象的值是 undefined 或者 null。</p>
<h2 id="3-7-1-uncaughtException"><a href="#3-7-1-uncaughtException" class="headerlink" title="3.7.1 uncaughtException"></a>3.7.1 uncaughtException</h2><p>看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const article = &#123; title: &#x27;Node.js&#x27;, content: &#x27;Hello, Node.js&#x27; &#125;</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(article.author.name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行以上代码打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/Users/nswbmw/Desktop/test/app.js:3</span><br><span class="line">  console.log(article.author.name)</span><br><span class="line">                             ^</span><br><span class="line">TypeError: Cannot read property &#x27;name&#x27; of undefined</span><br><span class="line">    at Timeout.setInterval [as _onTimeout] (/Users/nswbmw/Desktop/test/app.js:3:30)</span><br><span class="line">    at ontimeout (timers.js:475:11)</span><br><span class="line">    at tryOnTimeout (timers.js:310:5)</span><br><span class="line">    at Timer.listOnTimeout (timers.js:270:5)</span><br></pre></td></tr></table></figure>

<p>article 是一个文章对象有 title 和 content 属性，没有 author 属性，所以 article.author 是 undefined，调用 article.author.name 会报错。而且这个运行时错误是在一个异步函数（setImmediate）内抛出的，所以这个错误是一个 “uncaught exception”，如果没有 process.on(‘uncaughtException’, () &#x3D;&gt; {}) 事件监听器的话程序会 crash。</p>
<p>调试这种错误没有比较好的方法，通常只能添加 console.log 打印出 article 的值。但是我们前面介绍过 llnode 的用法，是否可以使用 llnode 调试这类问题呢？答案是肯定的。</p>
<h2 id="3-7-2-llnode"><a href="#3-7-2-llnode" class="headerlink" title="3.7.2 llnode"></a>3.7.2 llnode</h2><p>我们添加 –abort-on-uncaught-exception 参数重新运行程序，当程序 crash 的时候，会自动 Core Dump。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ulimit -c unlimited</span><br><span class="line">$ node --abort-on-uncaught-exception app.js</span><br><span class="line">Uncaught TypeError: Cannot read property &#x27;name&#x27; of undefined</span><br><span class="line"></span><br><span class="line">FROM</span><br><span class="line">Immediate.setImmediate (/home/nswbmw/test/app.js:1:1)</span><br><span class="line">runCallback (timers.js:1:1)</span><br><span class="line">tryOnImmediate (timers.js:1:1)</span><br><span class="line">processImmediate [as _immediateCallback] (timers.js:1:1)</span><br><span class="line">Illegal instruction (core dumped)</span><br></pre></td></tr></table></figure>

<p>此时生成一个 core 文件，我们使用 llnode 加载并诊断这个 core 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ lldb-4.0 -c ./core</span><br><span class="line">(lldb) target create --core &quot;./core&quot;</span><br><span class="line">Core file &#x27;/home/nswbmw/test/./core&#x27; (x86_64) was loaded.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>使用 <code>v8 bt</code> 查看最近的 backtrace。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) v8 bt</span><br><span class="line"> * thread #1: tid = 4750, 0x00007ffd905d5b39 node`v8::base::OS::Abort() + 9, name = &#x27;node&#x27;, stop reason = signal SIGILL</span><br><span class="line">  * frame #0: 0x00007ffd905d5b39 node`v8::base::OS::Abort() + 9</span><br><span class="line">    frame #1: 0x00007ffd900a4d19 node`v8::internal::Isolate::Throw(v8::internal::Object*, v8::internal::MessageLocation*) + 489</span><br><span class="line">    frame #2: 0x00007ffd9005e7f9 node`v8::internal::LoadIC::Load(v8::internal::Handle&lt;v8::internal::Object&gt;, v8::internal::Handle&lt;v8::internal::Name&gt;) + 569</span><br><span class="line">    frame #3: 0x00007ffd9005f759 node`v8::internal::Runtime_LoadIC_Miss(int, v8::internal::Object**, v8::internal::Isolate*) + 633</span><br><span class="line">    frame #4: 0x000018e6e710463d &lt;exit&gt;</span><br><span class="line">    frame #5: 0x000018e6e71ecce4 &lt;stub&gt;</span><br><span class="line">    frame #6: 0x000018e6e71bf9ce setImmediate(this=0x0000154a3ae09429:&lt;Object: Immediate&gt;) at /home/nswbmw/test/app.js:2:14 fn=0x0000154a3ae09281</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：在 frame #4 处程序触发 exit，往上追溯到 frame #6 有一个 setImmediate 抛出了错误，在 app.js 第 2 行，符合打印出的错误信息。setImmediate 的回调函数的地址为 0x0000154a3ae09281，我们使用 <code>v8 i</code> 检索这个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) v8 i 0x0000154a3ae09281</span><br><span class="line">0x0000154a3ae09281:&lt;function: setImmediate at /home/nswbmw/test/app.js:2:14</span><br><span class="line">  context=0x0000154a3ae09199&#123;</span><br><span class="line">    (previous)=0x000017849b703d89</span><br><span class="line">    (closure)=0x0000154a3ae08d81 &#123;&lt;function: (anonymous) at /home/nswbmw/test/app.js:1:10&gt;&#125;,</span><br><span class="line">    article=0x0000154a3ae091d1:&lt;Object: Object&gt;&#125;&gt;</span><br><span class="line">(lldb) v8 i 0x0000154a3ae091d1</span><br><span class="line">0x0000154a3ae091d1:&lt;Object: Object properties &#123;</span><br><span class="line">    .title=0x000014117e04c9e9:&lt;String: &quot;Node.js&quot;&gt;,</span><br><span class="line">    .content=0x000014117e04ca09:&lt;String: &quot;Hello, Node.js&quot;&gt;&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>setImmediate 函数内有一个 article 对象，然后我们继续通过 <code>v8 i</code> 检索得知 article 的值为 { title: “Node.js”, content: “Hello, Node.js” }，并没有 author 属性，真相大白。</p>
<h2 id="3-7-3-ReDoS"><a href="#3-7-3-ReDoS" class="headerlink" title="3.7.3 ReDoS"></a>3.7.3 ReDoS</h2><p>DoS（Denial of Service）全称是拒绝服务攻击，ReDoS（RegExp Denial of Service）即是正则表达式拒绝服务攻击。ReDoS 是由于正则表达式写得有缺陷，所以使用正则匹配时，会出现大量占用 CPU 的情况，导致服务不可用，而导致正则表达式匹配 “卡住” 的原因正是正则表达式的 “回溯” 特性。</p>
<p>看一个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/a.*b/g.test(&#x27;aaaf&#x27;)</span><br></pre></td></tr></table></figure>

<p>匹配过程如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging/blob/master/assets/3.7.1.png"><img src="https://github.com/nswbmw/node-in-debugging/raw/master/assets/3.7.1.png" alt="img"></a></p>
<p><strong>可以看出</strong>：因为 * 是贪婪匹配，所以第 3 步 <code>.*</code> 匹配了字符串末尾，由于剩下一个 <code>b</code> 无法匹配所以 “吐” 出一个字符再尝试匹配（第 4 步），仍然不匹配（第 5 步），继续 “吐” 出一个字符…这个 “吐” 一个字符的过程就是回溯（backtrack）。</p>
<p>再看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const reg = /(a*)+b/</span><br><span class="line"></span><br><span class="line">console.time(&#x27;reg&#x27;)</span><br><span class="line">reg.test(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaf&#x27;) // reg: 2572.022ms</span><br><span class="line">// reg.test(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaf&#x27;) // reg: 5048.735ms</span><br><span class="line">// reg.test(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaf&#x27;) // reg: 10710.070ms</span><br><span class="line">console.timeEnd(&#x27;reg&#x27;)</span><br></pre></td></tr></table></figure>

<p>运行以上代码，每添加一个字母 a，程序的运行时间就翻倍，这正是由于正则表达式的回溯导致的，这个正则表达式的时间复杂度为 O(2^n)。</p>
<p>平时写出具有回溯的正则表达式是比较常见的，这个时候程序会 “卡住”，使用 llnode 也可以调试这类问题。</p>
<p>运行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;/(a*)+b/.test(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaf&#x27;)&quot; &gt; app.js</span><br><span class="line">$ node --abort-on-uncaught-exception app.js &amp;</span><br><span class="line">$ kill -BUS `pgrep -n node`</span><br></pre></td></tr></table></figure>

<p>生成 core 文件，使用 llnode 调试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ lldb-4.0 -c ./core</span><br><span class="line">(lldb) target create --core &quot;./core&quot;</span><br><span class="line">Core file &#x27;/home/nswbmw/test/./core&#x27; (x86_64) was loaded.</span><br><span class="line">(lldb) v8 bt</span><br><span class="line"> * thread #1: tid = 5381, 0x000036a6db804f6b, name = &#x27;node&#x27;, stop reason = signal SIGBUS</span><br><span class="line">  * frame #0: 0x000036a6db804f6b &lt;builtin&gt;</span><br><span class="line">    ...</span><br><span class="line">    frame #6: 0x000036a6db68463d &lt;exit&gt;</span><br><span class="line">    frame #7: 0x000036a6db7135f4 test(this=0x0000038344709119:&lt;JSRegExp source=/(a*)+b/&gt;, 0x0000098ccdb4c9e9:&lt;String: &quot;aaaaaaaaaaaaaaaa...&quot;&gt;) at (no script) fn=0x0000183ca0c134a1</span><br><span class="line">    ...</span><br><span class="line">(lldb) v8 i -F 0x0000098ccdb4c9e9</span><br><span class="line">0x0000098ccdb4c9e9:&lt;String: &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaf&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：在程序退出前，程序在执行一个正则表达式（<code>/(a*)+b/</code>）的 test 方法，参数是字符串(<code>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaf</code>)。</p>
<p>减少正则表达式回溯的简单方法就是合并不必要的量词，如将上面的正则表达式 <code>/(a*)+b/</code> 修改为 <code>/a*b/</code>。</p>
<h2 id="3-7-4-参考链接"><a href="#3-7-4-参考链接" class="headerlink" title="3.7.4 参考链接"></a>3.7.4 参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.rawidn.com/posts/ddos-and-ddos-in-regular-expression.html">https://www.rawidn.com/posts/ddos-and-ddos-in-regular-expression.html</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://marvinliu1.github.io/2019/05/28/3.6.1%20%E4%BB%80%E4%B9%88%E6%98%AF%20Event%20Loop%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marvin Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marvin's Blog">
      <meta itemprop="description" content="Take in the good!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Marvin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/28/3.6.1%20%E4%BB%80%E4%B9%88%E6%98%AF%20Event%20Loop%EF%BC%9F/" class="post-title-link" itemprop="url">Node in Debugging, 3.6 What is event loop?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-28 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-28T00:00:00-06:00">2019-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Node-in-Debugging/" itemprop="url" rel="index"><span itemprop="name">Node in Debugging</span></a>
        </span>
    </span>

  
    <span id="/2019/05/28/3.6.1%20%E4%BB%80%E4%B9%88%E6%98%AF%20Event%20Loop%EF%BC%9F/" class="post-meta-item leancloud_visitors" data-flag-title="Node in Debugging, 3.6 What is event loop?" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging">Node in Debugging</a></p>
<p>事件循环（Event Loop）是 Node.js 最核心的概念，所以理解 Event Loop 如何运作对于写出正确的代码和调试是非常重要的。比如考虑以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;hi&#x27;)</span><br><span class="line">&#125;, 1000)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们期望程序运行 1s 后打印出 hi，但是实际情况可能是远大于 1s 后才打印出 hi。这个时候如果理解 Event Loop 就可以轻易发现问题，否则任凭怎么调试都是发现不了问题的。</p>
<h2 id="3-6-1-什么是-Event-Loop？"><a href="#3-6-1-什么是-Event-Loop？" class="headerlink" title="3.6.1 什么是 Event Loop？"></a>3.6.1 什么是 Event Loop？</h2><p>Event Loop 可以简单理解为：</p>
<ol>
<li>所有任务都在主线程上执行，形成一个执行栈（Execution Context Stack）。</li>
<li>主线程之外，还存在一个 “任务队列”（Task Queue）。系统把异步任务放到 “任务队列” 之中，然后主线程继续执行后续的任务。</li>
<li>一旦 “执行栈” 中的所有任务执行完毕，系统就会读取 “任务队列”。如果这个时候，异步任务已经结束了等待状态，就会从 “任务队列” 进入执行栈，恢复执行。</li>
<li>主线程不断重复上面的第三步。</li>
</ol>
<p><strong>小提示</strong>：我们常说 Node.js 是单线程的，但为何能达到高并发呢？原因就在于底层的 Libuv 维护一个 I&#x2F;O 线程池（即上述的 “任务队列”），结合 Node.js 异步 I&#x2F;O 的特性，单线程也能达到高并发啦。</p>
<p>上面提到了 “读取任务队列”，这样讲有点笼统，其实 Event Loop 的 “读取任务队列” 有 6 个阶段，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure>

<p>每个阶段都有一个 <strong>FIFO</strong> 的回调队列（queue），当 Event Loop 执行到这个阶段时，会从当前阶段的队列里拿出一个任务放到栈中执行，当队列任务清空，或者执行的回调数量达到上限后，Event Loop 会进入下个阶段。</p>
<p>每个阶段（phase）的作用：</p>
<ul>
<li>timers：执行 setTimeout() 和 setInterval() 中到期的 callback。</li>
<li>I&#x2F;O callbacks：上一轮循环中有少数的 I&#x2F;O callback 会被延迟到这一轮的这一阶段执行。</li>
<li>idle, prepare：仅内部使用。</li>
<li>poll：最重要的阶段，执行 I&#x2F;O callback，在适当的条件下 node 会阻塞在这个阶段。</li>
<li>check：执行 setImmediate() 的 callback。</li>
<li>close callbacks：执行 close 事件的 callback，例如 socket.on(‘close’,func)。</li>
</ul>
<h2 id="3-6-2-poll-阶段"><a href="#3-6-2-poll-阶段" class="headerlink" title="3.6.2 poll 阶段"></a>3.6.2 poll 阶段</h2><p>poll 阶段主要有两个功能：</p>
<ol>
<li>当 timers 的定时器到期后，执行定时器（setTimeout 和 setInterval）的 callback。</li>
<li>执行 poll 队列里面的 I&#x2F;O callback。</li>
</ol>
<p>如果 Event Loop 进入了 poll 阶段，且代码未设定 timer，可能发生以下情况：</p>
<ul>
<li>如果 poll queue 不为空，Event Loop 将同步的执行 queue 里的 callback，直至 queue 为空，或者执行的 callback 到达系统上限。</li>
<li>如果 poll queue 为空，可能发生以下情况：<ul>
<li>如果代码使用 setImmediate() 设定了 callback，Event Loop 将结束 poll 阶段进入 check 阶段，并执行 check 阶段的 queue。</li>
<li>如果代码没有使用 setImmediate()，Event Loop 将阻塞在该阶段等待 callbacks 加入 poll queue，如果有 callback 进来则立即执行。</li>
</ul>
</li>
</ul>
<p>一旦 poll queue 为空，Event Loop 将检查 timers，如果有 timer 的时间到期，Event Loop 将回到 timers 阶段，然后执行 timer queue。</p>
<h2 id="3-6-3-process-nextTick"><a href="#3-6-3-process-nextTick" class="headerlink" title="3.6.3 process.nextTick()"></a>3.6.3 process.nextTick()</h2><p>上面的 6 个阶段并没有出现 process.nextTick()，process.nextTick() 不在 Event Loop 的任何阶段执行，而是在各个阶段切换的中间执行，即从一个阶段切换到下个阶段前执行。这里还需要提一下 macrotask 和 microtask 的概念，macrotask（宏任务）指 Event Loop 每个阶段执行的任务，microtask（微任务）指每个阶段之间执行的任务。即上述 6 个阶段都属于 macrotask，process.nextTick() 属于 microtask。</p>
<p><strong>小提示</strong>：process.nextTick() 的实现和 v8 的 microtask 并无关系，是 Node.js 层面的东西，应该说 process.nextTick() 的行为接近为 microtask。Promise.then 也属于 microtask 的一种。</p>
<p>最后，放出一张关于 Event Loop 非常直观的图：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging/blob/master/assets/3.6.1.png"><img src="https://github.com/nswbmw/node-in-debugging/raw/master/assets/3.6.1.png" alt="img"></a></p>
<p>绿色小块表示 Event Loop 的各个阶段，执行的是 macrotask，macrotask 中间的粉红箭头表示执行的是 microtask。</p>
<h2 id="3-6-4-六道题"><a href="#3-6-4-六道题" class="headerlink" title="3.6.4 六道题"></a>3.6.4 六道题</h2><p>下面我们以六道题巩固一下前面讲到的 Event Loop 的知识。</p>
<h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setImmediate&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setImmediate</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout</span><br><span class="line">setImmediate</span><br></pre></td></tr></table></figure>

<p>为什么结果不确定呢？</p>
<p><strong>解释</strong>：setTimeout&#x2F;setInterval 的第 2 个参数取值范围是：[1, 2^31 - 1]，如果超过这个范围则会初始化为 1，即 setTimeout(fn, 0) &#x3D;&#x3D;&#x3D; setTimeout(fn, 1)。我们知道 setTimeout 的回调函数在 timer 阶段执行，setImmediate 的回调函数在 check 阶段执行，event loop 的开始会先检查 timer 阶段，但是在开始之前到 timer 阶段会消耗一定时间，所以就会出现两种情况：</p>
<ol>
<li>timer 前的准备时间超过 1ms，满足 loop-&gt;time &gt;&#x3D; 1，则执行 timer 阶段（setTimeout）的回调函数。</li>
<li>timer 前的准备时间小于 1ms，则先执行 check 阶段（setImmediate）的回调函数，下一次 event loop 执行 timer 阶段（setTimeout）的回调函数。</li>
</ol>
<p>再看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setTimeout&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setImmediate&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const start = Date.now()</span><br><span class="line">while (Date.now() - start &lt; 10);</span><br></pre></td></tr></table></figure>

<p>运行结果一定是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout</span><br><span class="line">setImmediate</span><br></pre></td></tr></table></figure>

<h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setTimeout&#x27;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line"></span><br><span class="line">  setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setImmediate&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setImmediate</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：fs.readFile 的回调函数执行完后：</p>
<ol>
<li>注册 setTimeout 的回调函数到 timer 阶段。</li>
<li>注册 setImmediate 的回调函数到 check 阶段。</li>
<li>event loop 从 pool 阶段出来继续往下一个阶段执行，恰好是 check 阶段，所以 setImmediate 的回调函数先执行。</li>
<li>本次 event loop 结束后，进入下一次 event loop，执行 setTimeout 的回调函数。</li>
</ol>
<p>所以，在 I&#x2F;O Callbacks 中注册的 setTimeout 和 setImmediate，永远都是 setImmediate 先执行。</p>
<h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setInterval&#x27;)</span><br><span class="line">&#125;, 100)</span><br><span class="line"></span><br><span class="line">process.nextTick(function tick () &#123;</span><br><span class="line">  process.nextTick(tick)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果：setInterval 永远不会打印出来。</p>
<p><strong>解释</strong>：process.nextTick 会无限循环，将 event loop 阻塞在 microtask 阶段，导致 event loop 上其他 macrotask 阶段的回调函数没有机会执行。</p>
<p>解决方法通常是用 setImmediate 替代 process.nextTick，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setInterval&#x27;)</span><br><span class="line">&#125;, 100)</span><br><span class="line"></span><br><span class="line">setImmediate(function immediate () &#123;</span><br><span class="line">  setImmediate(immediate)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果：每 100ms 打印一次 setInterval。</p>
<p><strong>解释</strong>：process.nextTick 内执行 process.nextTick 仍然将 tick 函数注册到当前 microtask 的尾部，所以导致 microtask 永远执行不完； setImmediate 内执行 setImmediate 会将 immediate 函数注册到下一次 event loop 的 check 阶段，而不是当前正在执行的 check 阶段，所以给了 event loop 上其他 macrotask 执行的机会。</p>
<p>再看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setImmediate1&#x27;)</span><br><span class="line">  setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;setImmediate2&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  process.nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;nextTick&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setImmediate3&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setImmediate1</span><br><span class="line">setImmediate3</span><br><span class="line">nextTick</span><br><span class="line">setImmediate2</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：并不是说 setImmediate 可以完全代替 process.nextTick，process.nextTick 在特定场景下还是无法被代替的，比如我们就想将一些操作放到最近的 microtask 里执行。</p>
<h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const promise = Promise.resolve()</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    return promise</span><br><span class="line">  &#125;)</span><br><span class="line">promise.catch(console.error)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:188:7)</span><br><span class="line">    at Function.Module.runMain (module.js:667:11)</span><br><span class="line">    at startup (bootstrap_node.js:187:16)</span><br><span class="line">    at bootstrap_node.js:607:3</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：Promise A+ 的规范里规定 promise 不能返回自己。仔细想想，即使规范里不规定，promise.then 类似于 process.nextTick，都会将回调函数注册到 microtask 阶段。上面代码也会导致死循环，类似前面提到的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(function tick () &#123;</span><br><span class="line">  process.nextTick(tick)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>再看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = Promise.resolve()</span><br><span class="line"></span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;promise&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;nextTick&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nextTick</span><br><span class="line">promise</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：promise.then 虽然和 process.nextTick 一样，都将回调函数注册到 microtask，但优先级不一样。process.nextTick 的 microtask queue 总是优先于 promise 的 microtask queue 执行。</p>
<h3 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;, 0)</span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">  for (let i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">    i === 9999 &amp;&amp; resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(3)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">  console.log(4)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(5)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：Promise 构造函数是同步执行的，所以先打印 2、3，然后打印 5，接下来 event loop 进入执行 microtask 阶段，执行 promise.then 的回调函数打印出 4，然后执行下一个 macrotask，恰好是 timer 阶段的 setTimeout 的回调函数，打印出 1。</p>
<h3 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">  &#125;, 100)</span><br><span class="line">  setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">  &#125;)</span><br><span class="line">  process.nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">  console.log(5)</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(6)</span><br><span class="line">  &#125;, 100)</span><br><span class="line">  setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(7)</span><br><span class="line">  &#125;)</span><br><span class="line">  process.nextTick(() =&gt; &#123;</span><br><span class="line">    console.log(8)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(9)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">1</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>process.nextTick、setTimeout 和 setImmediate 的组合，请读者自行推理吧。</p>
<h2 id="3-6-5-参考链接"><a href="#3-6-5-参考链接" class="headerlink" title="3.6.5 参考链接"></a>3.6.5 参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cnodejs.org/topic/57d68794cb6f605d360105bf">https://cnodejs.org/topic/57d68794cb6f605d360105bf</a></li>
<li><a target="_blank" rel="noopener" href="https://cnodejs.org/topic/5a9108d78d6e16e56bb80882">https://cnodejs.org/topic/5a9108d78d6e16e56bb80882</a></li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c">https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://marvinliu1.github.io/2019/05/21/Nuxtjs%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marvin Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marvin's Blog">
      <meta itemprop="description" content="Take in the good!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Marvin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/21/Nuxtjs%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">Nuxt.js Tutorial</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-21 00:12:31" itemprop="dateCreated datePublished" datetime="2019-05-21T00:12:31-06:00">2019-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Nuxt/" itemprop="url" rel="index"><span itemprop="name">Nuxt</span></a>
        </span>
    </span>

  
    <span id="/2019/05/21/Nuxtjs%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" class="post-meta-item leancloud_visitors" data-flag-title="Nuxt.js Tutorial" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=yQ8lENTmwnYOjAcdGWYdHg==.qBZchJpLuLMLzRDxyeXVf6UVQ25JAxbNuYLPFEPnro/p541xocWwP+kE4eVkOX6oSsfN8k4d1lqwyg1sByVw+w==">原文链接</a></p>
<p>Vue 开发一个单页面应用，相信很多前端工程师都已经学会了，但是单页面应用有一个致命的缺点，就是 SEO 极不友好。除非，vue 能在服务端渲染（ssr）并直接返回已经渲染好的页面，而并非只是一个单纯的 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>。</p>
<p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=oKAZXiPKJ8/UBeXAg0oxiQ==.6cm3QKXDeEFzjZvUTIl8ZIVO9VzX9U3Ie/L9nEcOVTg=">Nuxt.js</a> 就是一个极简的 vue 版的 ssr 框架。基于它，我们可以快速开发一个基于 vue 的 ssr 单页面应用。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Nuxt.js 官方提供了一个模板，可以使用 vue-cli 直接安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vue init nuxt-community/starter-template &lt;project-name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README<span class="selector-class">.md</span></span><br><span class="line">├── assets</span><br><span class="line">├── components</span><br><span class="line">├── layouts</span><br><span class="line">├── middleware</span><br><span class="line">├── node_modules</span><br><span class="line">├── nuxt<span class="selector-class">.config</span><span class="selector-class">.js</span></span><br><span class="line">├── package<span class="selector-class">.json</span></span><br><span class="line">├── pages</span><br><span class="line">├── plugins</span><br><span class="line">├── static</span><br><span class="line">├── store</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol>
<li><strong>assets</strong>: 资源文件。放置需要经过 webpack 打包处理的资源文件，如 scss，图片，字体等。</li>
<li><strong>components</strong>: 组件。这里存放在页面中，可以复用的组件。</li>
<li><strong>layouts</strong>: 布局。页面都需要有一个布局，默认为 default。它规定了一个页面如何布局页面。所有页面都会加载在布局页面中的 <code>&lt;nuxt /&gt;</code> 标签中。如果需要在普通页面中使用下级路由，则需要在页面中添加 <code>&lt;nuxt-child /&gt;</code>。<strong>该目录名为Nuxt.js保留的，不可更改。</strong></li>
<li><strong>middleware</strong>: 中间件。存放中间件。可以在页面中调用： <code>middleware: &#39;middlewareName&#39;</code> 。</li>
<li><strong>pages</strong>: 页面。一个 vue 文件即为一个页面。index.vue 为根页面。<ol>
<li>若需要二级页面，则添加文件夹即可。</li>
<li>如果页面的名称类似于 <code>_id.vue</code> （以 <code>_</code> 开头），则为动态路由页面，<code>_</code> 后为匹配的变量（params）。</li>
<li>若变量是必须的，则在文件夹下建立空文件 <code>index.vue</code>。更多的配置请移步至 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=dqP8fiwxvWcDQejYsgVfnQ==.y26NO9RNGsx08RI8Gi7Imhg7B3G7QLbeJXY0U4CsVIHZ9YnGGZLnh+xUVeE0oWah">官网</a> 。</li>
</ol>
</li>
<li><strong>plugin</strong>: 插件。用于组织那些需要在 <code>根vue.js应用</code> 实例化之前需要运行的 Javascript 插件。<strong>需要注意的是，在任何 Vue 组件的<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=CuYf1e6VrH3SxMCC649nww==.QcZmNcZIQPcT+7faNXV4O9TUsr6jlU05cNgm73fDzNVi1aqdlnZmdzcdJq536xrUKJD0LCAGWxh5KnXKj/ztLA==">生命周期</a>内， 只有 <code>beforeCreate</code> 和 <code>created</code> 这两个钩子方法会在 *客户端和服务端均被调用*。其他钩子方法仅在客户端被调用。</strong></li>
<li><strong>static</strong>: 静态文件。放置不需要经过 webpack 打包的静态资源。如一些 js, css 库。</li>
<li><strong>store</strong>: 状态管理。具体使用请移步至 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=AoDbP9LRa208Jyhj1oUPIA==.HxvxiMQv3Ou9U/o63GW1kHUDxq1nayYomZ4NobYa53IoUibLC+hvDekNvNidL7jG">官网</a>。</li>
<li><strong>nuxt.config.js</strong>: <code>nuxt.config.js</code> 文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。具体配置请移步至 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=Jc3I+GhOcRlE+zP4oHVOSg==.kIVDMKTG/k4jeQsbrBeoBQGx0XP8cxDpRRJHmiXoxH5OpCLe8ayNBuoii6KFqGgq">官网</a>。</li>
</ol>
<h3 id="Nuxt-特有函数"><a href="#Nuxt-特有函数" class="headerlink" title="Nuxt 特有函数"></a>Nuxt 特有函数</h3><p>首先，了解一下在 nuxt 的页面中独有的函数&#x2F;变量：</p>
<h4 id="asyncData-context"><a href="#asyncData-context" class="headerlink" title="asyncData(context)"></a>asyncData(context)</h4><p><code>asyncData</code>方法使得你能够在渲染组件之前异步获取数据。该方法在<strong>服务端</strong>中执行的，所以，请求数据时，<strong>不存在跨域问题</strong>。返回的数据将与 <code>data()</code> 返回的数据进行合并。<strong>由于<code>asyncData</code>方法是在组件 *初始化* 前被调用的，所以在方法内是没有办法通过 <code>this</code> 来引用组件的实例对象。</strong></p>
<p><code>context</code> 变量的可用属性一览：</p>
<table>
<thead>
<tr>
<th>属性字段</th>
<th>类型</th>
<th>可用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>isClient</code></td>
<td>Boolean</td>
<td>客户端 &amp; 服务端</td>
<td>是否来自客户端渲染</td>
</tr>
<tr>
<td><code>isServer</code></td>
<td>Boolean</td>
<td>客户端 &amp; 服务端</td>
<td>是否来自服务端渲染</td>
</tr>
<tr>
<td><code>isDev</code></td>
<td>Boolean</td>
<td>客户端 &amp; 服务端</td>
<td>是否是开发(dev) 模式，在生产环境的数据缓存中用到</td>
</tr>
<tr>
<td><code>route</code></td>
<td><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=EhSnyiweglWgdpqp8ODgIA==.xjoo8ztbhJUNMXi8fVa4u6h//LajKkgw1HOL5ujMVjnX3CR3TahY6+KyvRTTsMDJtnopcWfyF1QQSJMQQos5xQ==">vue-router 路由</a></td>
<td>客户端 &amp; 服务端</td>
<td><code>vue-router</code> 路由实例。</td>
</tr>
<tr>
<td><code>store</code></td>
<td><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=olAv4D/AKolrJdt3ilarDQ==.bddJZIl0ZP2wddJojIjmNaJDX2OlzVNvn1NmE10RfoGJS0Ar71/FrJYwr/o4auKrfkq6GmKEOsOaZiU0Rnp5Wyv9uG7cjoZhn1ZQ5fM8Ttg=">vuex 数据流</a></td>
<td>客户端 &amp; 服务端</td>
<td><code>Vuex.Store</code> 实例。<strong>只有vuex 数据流存在相关配置时可用。</strong></td>
</tr>
<tr>
<td><code>env</code></td>
<td>Object</td>
<td>客户端 &amp; 服务端</td>
<td><code>nuxt.config.js</code> 中配置的环境变量, 见 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=WqVZrMizdFRyKc5oV5TwAA==.ZmzeAp9RGrg/dlq+JbdEFa+oV7cQus/k5ZcttCWkKczqXqEVe2dWUndbwwPnhb9U">环境变量 api</a></td>
</tr>
<tr>
<td><code>params</code></td>
<td>Object</td>
<td>客户端 &amp; 服务端</td>
<td>route.params 的别名</td>
</tr>
<tr>
<td><code>query</code></td>
<td>Object</td>
<td>客户端 &amp; 服务端</td>
<td>route.query 的别名</td>
</tr>
<tr>
<td><code>req</code></td>
<td><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=ZTcor6Gj8DnBDdIL0JP1BA==.9T6jIC+XMg64OYEopDFLdfj8RDbJTh+rVGu/mOUtVHneBypb5FKeZJgfgRLt3BnnzkU1bN8XfLSZFqSgeuBt/w5JDh+7LtP+j7zKLls4Nfk=">http.Request</a></td>
<td>服务端</td>
<td>Node.js API 的 Request 对象。如果 nuxt 以中间件形式使用的话，这个对象就根据你所使用的框架而定。<em>nuxt generate 不可用</em>。</td>
</tr>
<tr>
<td><code>res</code></td>
<td><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=4efLqkj2Z6mUjgYtyftj8g==.V5Ao0Iz1WlMXw3MS6p/8lUrhqRm0S3KbPVd4IxipJLLMgrmiCF2anjMVzTUNDC28tVxxDa29s5H/sj8FIwwEDg==">http.Response</a></td>
<td>服务端</td>
<td>Node.js API 的 Response 对象。如果 nuxt 以中间件形式使用的话，这个对象就根据你所使用的框架而定。<em>nuxt generate 不可用</em>。</td>
</tr>
<tr>
<td><code>redirect</code></td>
<td>Function</td>
<td>客户端 &amp; 服务端</td>
<td>用这个方法重定向用户请求到另一个路由。状态码在服务端被使用，默认 302。<code>redirect([status,] path [, query])</code></td>
</tr>
<tr>
<td><code>error</code></td>
<td>Function</td>
<td>客户端 &amp; 服务端</td>
<td>用这个方法展示错误页：<code>error(params)</code>。<code>params</code> 参数应该包含 <code>statusCode</code> 和 <code>message</code> 字段。</td>
</tr>
</tbody></table>
<h4 id="fetch-context"><a href="#fetch-context" class="headerlink" title="fetch(context)"></a>fetch(context)</h4><p><em>fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据。为了让获取过程可以异步，<strong>你需要返回一个 Promise</strong>，Nuxt.js 会等这个 promise 完成后再渲染组件。</em></p>
<p><strong>fetch 会在组件每次加载前被调用（在服务端或切换至目标路由之前）。</strong></p>
<h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>Nuxt.js 使用了 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=z6lYOgCdPjX1K5Jdxp8h1Q==.pkZ+oJXV11McTaHeBz5VzvEOW83qsrnpj4Kh8neloASuQu9JDPRFAe28LThj4GM7"><code>vue-meta</code></a> 更新应用的 <code>头部标签(Head)</code> 和 <code>html 属性</code>。</p>
<p>用于更新 头部信息。如 title，descripe 等。<strong>在 <code>head</code> 方法里可通过 <code>this</code> 关键字来获取组件的数据。</strong></p>
<h4 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h4><p>指定该页面使用哪个布局文件。默认值为 <code>default</code>。</p>
<h4 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h4><p>需要执行的中间件，如鉴权的 <code>auth</code>等。</p>
<h4 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h4><p>指定页面切换时的动画效果。支持传入 <code>String</code>, <code>Object</code>, <code>Function</code>。具体配置请移步至 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=RAWcYpUuPwFcTZWtz55mOQ==.X5ahD5RlPNbcwUQpDybb35s/FHUq9+tr9RwAAbKkjKuWRmWH1+dwf7WCyuMZwwzq">官网</a> 。</p>
<h4 id="validate"><a href="#validate" class="headerlink" title="validate"></a>validate</h4><p>Nuxt.js 可以让你在动态路由对应的页面组件中配置一个校验方法用于校验动态路由参数的有效性。</p>
<p>返回 <code>true</code> 说明路由有效，则进入路由页面。返回不是 <code>true</code> 则显示 404 页面。</p>
<h3 id="Begin-Coding"><a href="#Begin-Coding" class="headerlink" title="Begin Coding"></a>Begin Coding</h3><h4 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h4><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p>在这里，我们使用 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=Di/FwQuM2z/4k3Sv0z6aUg==.ajZ69v213SEpzGGycaj2JGU/UEOTNpdc9RopP9MQZdg=">CNode API</a> 进行开发 Demo.</p>
<h5 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h5><p>请求数据，我们使用 Nuxt 官方提供的 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=b16sKUKlk8RKYn8eU5okEw==.GyeT/0Ge3PyKQBq1AVcsgZnvPKpuWgzktdQevhrJcrSoT85hRHV766C/s4oRo8vZ">@nuxtjs&#x2F;axios</a> 安装后，在 nuxt.config.js 中加上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">modules</span>: [</span><br><span class="line">    <span class="string">&#x27;@nuxtjs/axios&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">axios</span>: &#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;https://cnodejs.org/api/v1&#x27;</span>,</span><br><span class="line">    <span class="comment">// or other axios configs.</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以在页面中通过 <code>this.$axios.$get</code> 来获取数据，不需要在每个页面都单独引入 axios.</p>
<h5 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h5><p>需要先安装 sass-loader 和 node-sass</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$    yarn add sass-loader node-sass --dev</span><br></pre></td></tr></table></figure>

<p>如果需要在项目中全局使用某个 scss 文件（如 mixins, vars 等），需要借助 sass-resources-loader : <code>yarn add sass-resources-loader —dev</code>， 还需要在 nuxt.config.js 的 build 配置中调整导出的 loader 配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="title function_">extend</span>(<span class="params">config, &#123; isDev, isClient &#125;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> sassResourcesLoader = &#123;  </span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;sass-resources-loader&#x27;</span>,  </span><br><span class="line">        <span class="attr">options</span>: &#123;  </span><br><span class="line">          <span class="attr">resources</span>: [</span><br><span class="line">            <span class="comment">// 填写需要全局注入 scss 的文件。引入后，所有页面均有效。</span></span><br><span class="line">            <span class="string">&#x27;assets/styles/mixins.scss&#x27;</span>  </span><br><span class="line">          ]</span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 修改 scss sass 引用的 loader。</span></span><br><span class="line">      config.<span class="property">module</span>.<span class="property">rules</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">rule</span>) =&gt;</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (rule.<span class="property">test</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;/\\.vue$/&#x27;</span>) &#123;  </span><br><span class="line">          rule.<span class="property">options</span>.<span class="property">loaders</span>.<span class="property">sass</span>.<span class="title function_">push</span>(sassResourcesLoader)  </span><br><span class="line">          rule.<span class="property">options</span>.<span class="property">loaders</span>.<span class="property">scss</span>.<span class="title function_">push</span>(sassResourcesLoader)  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> ([<span class="string">&#x27;/\\.sass$/&#x27;</span>, <span class="string">&#x27;/\\.scss$/&#x27;</span>].<span class="title function_">indexOf</span>(rule.<span class="property">test</span>.<span class="title function_">toString</span>()) !== -<span class="number">1</span>) &#123;  </span><br><span class="line">          rule.<span class="property">use</span>.<span class="title function_">push</span>(sassResourcesLoader)  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;)  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h4><p>首页一般只需要简单的获取首页数据并渲染即可。</p>
<p>主要 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncData</span>(<span class="params">&#123;app, query&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(query)</span><br><span class="line">  <span class="comment">// 根据不用的标签获取不同的数据，最后返回话题列表。</span></span><br><span class="line">  <span class="keyword">return</span> app.<span class="property">$axios</span>.$get(<span class="string">`topics?tab=<span class="subst">$&#123;query.tab || <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(res)</span></span><br><span class="line">    <span class="comment">// console.log(JSON.parse(res))</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">list</span>: res.<span class="property">data</span>&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进入首页时，该函数会被执行， nuxt 会等到获取数据后再和组件的 data 合并，进而渲染数据。在模板中，可以直接使用 list 变量获取数据。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card fluid topic&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;topic in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;topic.id&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;section&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">nuxt-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name: &#x27;topic-id&#x27;, params: &#123;id: topic.id&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;topic-title&quot;</span>&gt;</span>&#123;&#123;topic.title&#125;&#125;<span class="tag">&lt;/<span class="name">nuxt-link</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;topic-info&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mark</span> <span class="attr">v-if</span>=<span class="string">&quot;topic.top&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tertiary&quot;</span>&gt;</span>精华<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mark</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123;tabsObj[topic.tab]&#125;&#125;<span class="tag">&lt;/<span class="name">mark</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;topic.author.avatar_url&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;topic.author.loginname&#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这里提及一下， <code>&lt;nuxt-link /&gt;</code> 和 <code>&lt;a /&gt;</code> 的区别是： <code>nuxt-link</code> 走的是 vue-router 的路由，即网页已为单页面，并且浏览器不会重定向。而 <code>a</code> 标签走的是 <code>window.location.href</code>，每一次点击 <code>a</code> 标签后的页面，都会进行一次服务端渲染，和普通的 PHP 混合开发没有太大的区别。</p>
<p>在这里使用了 <code>nuxt-link</code> 是因为 CNode 的 API 不存在跨域问题，因此可以作为一个单页面应用，体验更好。</p>
<p>因为列表页数据类型有多种，该页面可能会被复用，所以当路由对象发生变化时，需要重新获取数据，这时可以监听路由的变化以做出响应：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;$route&#x27;</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;$route has changed.&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getData</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置 seo 优化（这里只是单纯的复制罢了，demo 使用，侵删）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">head</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;首页&#x27;</span> + (<span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">tab</span> ? <span class="string">`- <span class="subst">$&#123;<span class="variable language_">this</span>.tabsObj[<span class="variable language_">this</span>.$route.query.tab]&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">    <span class="attr">meta</span>: [&#123;</span><br><span class="line">      <span class="attr">hid</span>: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">      <span class="attr">content</span>: <span class="string">&#x27;CNode：Node.js专业中文社区&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="话题详情"><a href="#话题详情" class="headerlink" title="话题详情"></a>话题详情</h4><p>同样的，使用 <code>asyncData</code> 函数进行获取数据，再渲染页面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncData</span>(<span class="params">&#123;app, params&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(params)</span><br><span class="line">  <span class="keyword">return</span> app.<span class="property">$axios</span>.$get(<span class="string">&#x27;topic/&#x27;</span> + params.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// let data = res.data instanceof String ? JSON.parse(res.data) : res.data</span></span><br><span class="line">    <span class="keyword">let</span> data = res.<span class="property">data</span></span><br><span class="line">    <span class="comment">// console.log(res)</span></span><br><span class="line">    <span class="comment">// let div = document.createElement(&#x27;div&#x27;)</span></span><br><span class="line">    <span class="comment">// div.innerHTML = res.data.data.content</span></span><br><span class="line">    <span class="comment">// res.data.summary = div.innerText.substr(0, 120)</span></span><br><span class="line">    data.<span class="property">summary</span> = data.<span class="property">content</span>.<span class="title function_">replace</span>(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>,<span class="string">&quot;&quot;</span>).<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">120</span>).<span class="title function_">replace</span>(<span class="regexp">/\s+/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">detail</span>: data&#125;</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;axios.get failed.&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，踩过坑。想使用 div 的 innerText 来过滤掉正文中的 HTML 标签，但是，如果用户是直接进入这个页面的时候，执行 <code>asyncData</code> 时，<code>document</code> 对象是不存在的，从而会报错。也就是说，<strong>当 <code>asyncData</code> 在服务端执行时，是没有 <code>document</code> 和 <code>window</code> 对象的</strong>，请大家注意一下。</p>
<p>作为一个社区，seo 尤为重要，倘若每个页面都需要写一大堆的 head 对象，就会显得尤其的繁琐。所以可以借助 nuxt 的 plugin 机制，将其封装成一个函数，并注入到每一个页面当中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugins/global.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 必传 标题，描述。其他的 meta 标签通过 payload 注入，其中，每个 meta 的 hid 需要是唯一的。</span></span><br><span class="line">    $seo(title, content, payload = []) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        title,</span><br><span class="line">        <span class="attr">meta</span>: [&#123;</span><br><span class="line">          <span class="attr">hid</span>: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;description&#x27;</span>,</span><br><span class="line">          content</span><br><span class="line">        &#125;].<span class="title function_">concat</span>(payload)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 nuxt.config.js 中加上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="string">&#x27;~plugins/global.js&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，只需要在页面的 <code>head</code> 的函数中，返回该函数即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">head</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.$seo(<span class="variable language_">this</span>.<span class="property">detail</span>.<span class="property">title</span>, <span class="variable language_">this</span>.<span class="property">detail</span>.<span class="property">summary</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo5dh2n4k5j314k0nq0vu.jpg" alt="详情页 seo"></p>
<p>可见，详情页已经成功的设置了部分 seo 的标签。</p>
<p>以上是 Nuxt 的一些基础配置及应用。</p>
<p>我再去研究一下， fetch 和 store 的结合，将该 demo 继续完善。</p>
<p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=331HKnZd3kx5B1qCBrwcXA==./hS2koJfqK9p6Gks+EtJzWApn0CRW6/euao2ucSNO4Mlp2aqxoM5kTRsykytJaym">Demo 线上地址</a><br><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=HarIRi3qPBbQoNhoQ7QVUw==.WKJ82vJ2UfufyamtZ8nOA4OyetwRWtPtxu3dG4SdihXLLbdB0Ak0qa2gft6EYq13">GitHub 地址</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://marvinliu1.github.io/2019/05/16/3.5.1%20%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marvin Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marvin's Blog">
      <meta itemprop="description" content="Take in the good!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Marvin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/16/3.5.1%20%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">Node in Debugging, 3.5 Evironment</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-16 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-16T00:00:00-06:00">2019-05-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Node-in-Debugging/" itemprop="url" rel="index"><span itemprop="name">Node in Debugging</span></a>
        </span>
    </span>

  
    <span id="/2019/05/16/3.5.1%20%E7%8E%AF%E5%A2%83/" class="post-meta-item leancloud_visitors" data-flag-title="Node in Debugging, 3.5 Evironment" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging">Node in Debugging</a></p>
<p>我们知道，Node.js 不适合 CPU 密集型计算的场景，通常的解决方法是用 C&#x2F;C++ 编写 Node.js 的扩展（Addons）。以前只能用 C&#x2F;C++，现在我们有了新的选择——Rust。</p>
<h2 id="3-5-1-环境"><a href="#3-5-1-环境" class="headerlink" title="3.5.1 环境"></a>3.5.1 环境</h2><ul>
<li><a href="mailto:&#110;&#x6f;&#x64;&#101;&#64;&#x38;&#46;&#57;&#x2e;&#x34;">&#110;&#x6f;&#x64;&#101;&#64;&#x38;&#46;&#57;&#x2e;&#x34;</a></li>
<li><a href="mailto:rust@1.26.0-nightly">rust@1.26.0-nightly</a></li>
</ul>
<h2 id="3-5-2-Rust"><a href="#3-5-2-Rust" class="headerlink" title="3.5.2 Rust"></a>3.5.2 Rust</h2><p>Rust 是 Mozilla 开发的注重安全、性能和并发的现代编程语言。相比较于其他常见的编程语言，它有 3 个独特的概念：</p>
<ol>
<li>所有权</li>
<li>借用</li>
<li>生命周期</li>
</ol>
<p>正是这 3 个特性保证了 Rust 是内存安全的，这里不会展开讲解，有兴趣的读者可以去了解一下。</p>
<p>接下来，我们通过三种方式使用 Rust 编写 Node.js 的扩展。</p>
<h2 id="3-5-3-FFI"><a href="#3-5-3-FFI" class="headerlink" title="3.5.3 FFI"></a>3.5.3 <a target="_blank" rel="noopener" href="https://github.com/node-ffi/node-ffi">FFI</a></h2><p>FFI 的全称是 Foreign Function Interface，即可以用 Node.js 调用动态链接库。</p>
<p>运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new ffi-demo &amp;&amp; cd ffi-demo</span><br><span class="line">$ npm init -y</span><br><span class="line">$ npm i ffi --save</span><br><span class="line">$ touch index.js</span><br></pre></td></tr></table></figure>

<p>部分文件修改如下：</p>
<p><strong>src&#x2F;lib.rs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#[no_mangle]</span><br><span class="line">pub extern fn fib(n: i64) -&gt; i64 &#123;</span><br><span class="line">  return match n &#123;</span><br><span class="line">    1 | 2 =&gt; 1,</span><br><span class="line">    n =&gt; fib(n - 1) + fib(n - 2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Cargo.toml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;ffi-demo&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line"></span><br><span class="line">[lib]</span><br><span class="line">name = &quot;ffi&quot;</span><br><span class="line">crate-type = [&quot;dylib&quot;]</span><br></pre></td></tr></table></figure>

<p>Cargo.toml 是 Rust 项目的配置文件，相当于 Node.js 中的 package.json。这里指定编译生成的类型是 dylib（动态链接库），名字在 *inux 下是 libffi，Windows 下是 ffi。</p>
<p>使用 cargo 编译代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build #开发环境用</span><br><span class="line">或者</span><br><span class="line">$ cargo build --release #生产环境用，编译器做了更多优化，但编译慢</span><br></pre></td></tr></table></figure>

<p>cargo 是 Rust 的构建工具和包管理工具，负责构建代码、下载依赖库并编译它们。此时会生成一个 target 的目录，该目录下会有 debug（不加 –release）或者 release（加 –release）目录，存放了生成的动态链接库。</p>
<p><strong>index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const ffi = require(&#x27;ffi&#x27;)</span><br><span class="line">const isWin = /^win/.test(process.platform)</span><br><span class="line"></span><br><span class="line">const rust = ffi.Library(&#x27;target/debug/&#x27; + (!isWin ? &#x27;lib&#x27; : &#x27;&#x27;) + &#x27;ffi&#x27;, &#123;</span><br><span class="line">  fib: [&#x27;int&#x27;, [&#x27;int&#x27;]]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function fib(n) &#123;</span><br><span class="line">  if (n === 1 || n === 2) &#123;</span><br><span class="line">    return 1</span><br><span class="line">  &#125;</span><br><span class="line">  return fib(n - 1) + fib(n - 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">console.time(&#x27;node&#x27;)</span><br><span class="line">console.log(fib(40))</span><br><span class="line">console.timeEnd(&#x27;node&#x27;)</span><br><span class="line"></span><br><span class="line">// rust</span><br><span class="line">console.time(&#x27;rust&#x27;)</span><br><span class="line">console.log(rust.fib(40))</span><br><span class="line">console.timeEnd(&#x27;rust&#x27;)</span><br></pre></td></tr></table></figure>

<p>运行 index.js：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br><span class="line">102334155</span><br><span class="line">node: 1053.743ms</span><br><span class="line">102334155</span><br><span class="line">rust: 1092.570ms</span><br></pre></td></tr></table></figure>

<p>将 index.js 中 debug 改为 release，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build --release</span><br><span class="line">$ node index.js</span><br><span class="line">102334155</span><br><span class="line">node: 1050.467ms</span><br><span class="line">102334155</span><br><span class="line">rust: 273.508ms</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：添加了 –release 编译后的代码，执行效率提升十分明显。</p>
<h2 id="3-5-4-Neon"><a href="#3-5-4-Neon" class="headerlink" title="3.5.4 Neon"></a>3.5.4 <a target="_blank" rel="noopener" href="https://github.com/neon-bindings/neon">Neon</a></h2><p>官方介绍：</p>
<blockquote>
<p>Rust bindings for writing safe and fast native Node.js modules.</p>
</blockquote>
<p>使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ npm i neon-cli -g</span><br><span class="line">$ neon new neon-demo</span><br><span class="line">$ cd neon-demo</span><br><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── lib</span><br><span class="line">│   └── index.js</span><br><span class="line">├── native</span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   ├── build.rs</span><br><span class="line">│   └── src</span><br><span class="line">│       └── lib.rs</span><br><span class="line">└── package.json</span><br><span class="line"></span><br><span class="line">3 directories, 6 files</span><br><span class="line">$ npm i #触发 neon build</span><br><span class="line">$ node lib/index.js</span><br><span class="line">hello node</span><br></pre></td></tr></table></figure>

<p>接下来我们看看关键的代码文件。</p>
<p><strong>lib&#x2F;index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var addon = require(&#x27;../native&#x27;);</span><br><span class="line">console.log(addon.hello());</span><br></pre></td></tr></table></figure>

<p><strong>native&#x2F;src&#x2F;lib.rs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#[macro_use]</span><br><span class="line">extern crate neon;</span><br><span class="line"></span><br><span class="line">use neon::vm::&#123;Call, JsResult&#125;;</span><br><span class="line">use neon::js::JsString;</span><br><span class="line"></span><br><span class="line">fn hello(call: Call) -&gt; JsResult&lt;JsString&gt; &#123;</span><br><span class="line">    let scope = call.scope;</span><br><span class="line">    Ok(JsString::new(scope, &quot;hello node&quot;).unwrap())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">register_module!(m, &#123;</span><br><span class="line">    m.export(&quot;hello&quot;, hello)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>native&#x2F;build.rs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extern crate neon_build;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    neon_build::setup(); // must be called in build.rs</span><br><span class="line"></span><br><span class="line">    // add project-specific build logic here...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>native&#x2F;Cargo.toml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;neon-demo&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">authors = [&quot;nswbmw&quot;]</span><br><span class="line">license = &quot;MIT&quot;</span><br><span class="line">build = &quot;build.rs&quot;</span><br><span class="line"></span><br><span class="line">[lib]</span><br><span class="line">name = &quot;neon_demo&quot;</span><br><span class="line">crate-type = [&quot;dylib&quot;]</span><br><span class="line"></span><br><span class="line">[build-dependencies]</span><br><span class="line">neon-build = &quot;0.1.22&quot;</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">neon = &quot;0.1.22&quot;</span><br></pre></td></tr></table></figure>

<p>在运行 <code>neon build</code> 时，会根据 native&#x2F;Cargo.toml 中 build 字段指定的文件（这里是 build.rs）编译，并且生成的类型是 dylib（动态链接库）。native&#x2F;src&#x2F;lib.rs 存放了扩展的代码逻辑，通过 register_module 注册了一个 hello 方法，返回 hello node 字符串。</p>
<p>接下来测试原生 Node.js 和 Neon 编写的扩展运行斐波那契数列的执行效率。</p>
<p>修改对应文件如下：</p>
<p><strong>native&#x2F;src&#x2F;lib.rs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#[macro_use]</span><br><span class="line">extern crate neon;</span><br><span class="line"></span><br><span class="line">use neon::vm::&#123;Call, JsResult&#125;;</span><br><span class="line">use neon::mem::Handle;</span><br><span class="line">use neon::js::JsInteger;</span><br><span class="line"></span><br><span class="line">fn fib(call: Call) -&gt; JsResult&lt;JsInteger&gt; &#123;</span><br><span class="line">  let scope = call.scope;</span><br><span class="line">  let index: Handle&lt;JsInteger&gt; = try!(try!(call.arguments.require(scope, 0)).check::&lt;JsInteger&gt;());</span><br><span class="line">  let index: i32 = index.value() as i32;</span><br><span class="line">  let result: i32 = fibonacci(index);</span><br><span class="line">  Ok(JsInteger::new(scope, result))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fibonacci(n: i32) -&gt; i32 &#123;</span><br><span class="line">  match n &#123;</span><br><span class="line">    1 | 2 =&gt; 1,</span><br><span class="line">    _ =&gt; fibonacci(n - 1) + fibonacci(n - 2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">register_module!(m, &#123;</span><br><span class="line">  m.export(&quot;fib&quot;, fib)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>lib&#x2F;index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const rust = require(&#x27;../native&#x27;)</span><br><span class="line"></span><br><span class="line">function fib (n) &#123;</span><br><span class="line">  if (n === 1 || n === 2) &#123;</span><br><span class="line">    return 1</span><br><span class="line">  &#125;</span><br><span class="line">  return fib(n - 1) + fib(n - 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">console.time(&#x27;node&#x27;)</span><br><span class="line">console.log(fib(40))</span><br><span class="line">console.timeEnd(&#x27;node&#x27;)</span><br><span class="line"></span><br><span class="line">// rust</span><br><span class="line">console.time(&#x27;rust&#x27;)</span><br><span class="line">console.log(rust.fib(40))</span><br><span class="line">console.timeEnd(&#x27;rust&#x27;)</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ neon build</span><br><span class="line">$ node lib/index.js</span><br><span class="line">102334155</span><br><span class="line">node: 1030.681ms</span><br><span class="line">102334155</span><br><span class="line">rust: 270.417ms</span><br></pre></td></tr></table></figure>

<p>接下来看一个复杂点的例子，用 Neon 编写一个 User 类，可传入一个含有 first_name 和 last_name 的对象，暴露出一个 get_full_name 方法。</p>
<p>修改对应文件如下：</p>
<p><strong>native&#x2F;src&#x2F;lib.rs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#[macro_use]</span><br><span class="line">extern crate neon;</span><br><span class="line"></span><br><span class="line">use neon::js::&#123;JsFunction, JsString, Object, JsObject&#125;;</span><br><span class="line">use neon::js::class::&#123;Class, JsClass&#125;;</span><br><span class="line">use neon::mem::Handle;</span><br><span class="line">use neon::vm::Lock;</span><br><span class="line"></span><br><span class="line">pub struct User &#123;</span><br><span class="line">  first_name: String,</span><br><span class="line">  last_name: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare_types! &#123;</span><br><span class="line">  pub class JsUser for User &#123;</span><br><span class="line">    init(call) &#123;</span><br><span class="line">      let scope = call.scope;</span><br><span class="line">      let user = try!(try!(call.arguments.require(scope, 0)).check::&lt;JsObject&gt;());</span><br><span class="line">      let first_name: Handle&lt;JsString&gt; = try!(try!(user.get(scope, &quot;first_name&quot;)).check::&lt;JsString&gt;());</span><br><span class="line">      let last_name: Handle&lt;JsString&gt; = try!(try!(user.get(scope, &quot;last_name&quot;)).check::&lt;JsString&gt;());</span><br><span class="line"></span><br><span class="line">      Ok(User &#123;</span><br><span class="line">        first_name: first_name.value(),</span><br><span class="line">        last_name: last_name.value(),</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method get_full_name(call) &#123;</span><br><span class="line">      let scope = call.scope;</span><br><span class="line">      let first_name = call.arguments.this(scope).grab(|user| &#123; user.first_name.clone() &#125;);</span><br><span class="line">      let last_name = call.arguments.this(scope).grab(|user| &#123; user.last_name.clone() &#125;);</span><br><span class="line">      Ok(try!(JsString::new_or_throw(scope, &amp;(first_name + &amp;last_name))).upcast())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">register_module!(m, &#123;</span><br><span class="line">  let class: Handle&lt;JsClass&lt;JsUser&gt;&gt; = try!(JsUser::class(m.scope));</span><br><span class="line">  let constructor: Handle&lt;JsFunction&lt;JsUser&gt;&gt; = try!(class.constructor(m.scope));</span><br><span class="line">  try!(m.exports.set(&quot;User&quot;, constructor));</span><br><span class="line">  Ok(())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>lib&#x2F;index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const rust = require(&#x27;../native&#x27;)</span><br><span class="line">const User = rust.User</span><br><span class="line"></span><br><span class="line">const user = new User(&#123;</span><br><span class="line">  first_name: &#x27;zhang&#x27;,</span><br><span class="line">  last_name: &#x27;san&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(user.get_full_name())</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ neon build</span><br><span class="line">$ node lib/index.js</span><br><span class="line">zhangsan</span><br></pre></td></tr></table></figure>

<h2 id="3-5-5-NAPI"><a href="#3-5-5-NAPI" class="headerlink" title="3.5.5 NAPI"></a>3.5.5 <a target="_blank" rel="noopener" href="https://nodejs.org/api/n-api.html">NAPI</a></h2><p>不少 Node.js 开发者可能都遇到过升级 Node.js 版本导致程序运行不起来的情况，需要重新安装依赖解决，比如：node-sass 模块。因为之前编写 Node.js 扩展严重依赖于 V8 暴露的 API，而不同版本的 Node.js 依赖的 V8 版本可能不同，一旦升级 Node.js 版本，原先运行正常的 Node.js 的扩展就可能失效了。</p>
<p>NAPI 是 node@8 新添加的用于原生模块开发的接口，相较于以前的开发方式，NAPI 提供了稳定的 ABI 接口，消除了 Node.js 版本差异、引擎差异等编译后不兼容的问题，解决了编写 Node.js 插件最头疼的问题。</p>
<p>目前 NAPI 还处于试验阶段，所以相关资料并不多，笔者写了一个 demo 放到了 GitHub 上，这里直接 clone 下来运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/nswbmw/rust-napi-demo</span><br></pre></td></tr></table></figure>

<p>主要文件代码如下：</p>
<p><strong>src&#x2F;lib.rs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#[macro_use]</span><br><span class="line">extern crate napi;</span><br><span class="line">#[macro_use]</span><br><span class="line">extern crate napi_derive;</span><br><span class="line"></span><br><span class="line">use napi::&#123;NapiEnv, NapiNumber, NapiResult&#125;;</span><br><span class="line"></span><br><span class="line">#[derive(NapiArgs)]</span><br><span class="line">struct Args&lt;&#x27;a&gt; &#123;</span><br><span class="line">  n: NapiNumber&lt;&#x27;a&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn fibonacci&lt;&#x27;a&gt;(env: &amp;&#x27;a NapiEnv, args: &amp;Args&lt;&#x27;a&gt;) -&gt; NapiResult&lt;NapiNumber&lt;&#x27;a&gt;&gt; &#123;</span><br><span class="line">  let number = args.n.to_i32()?;</span><br><span class="line">  NapiNumber::from_i32(env, _fibonacci(number))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">napi_callback!(export_fibonacci, fibonacci);</span><br><span class="line"></span><br><span class="line">fn _fibonacci(n: i32) -&gt; i32 &#123;</span><br><span class="line">  match n &#123;</span><br><span class="line">    1 | 2 =&gt; 1,</span><br><span class="line">    _ =&gt; _fibonacci(n - 1) + _fibonacci(n - 2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const rust = require(&#x27;./build/Release/example.node&#x27;)</span><br><span class="line"></span><br><span class="line">function fib (n) &#123;</span><br><span class="line">  if (n === 1 || n === 2) &#123;</span><br><span class="line">    return 1</span><br><span class="line">  &#125;</span><br><span class="line">  return fib(n - 1) + fib(n - 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">console.time(&#x27;node&#x27;)</span><br><span class="line">console.log(fib(40))</span><br><span class="line">console.timeEnd(&#x27;node&#x27;)</span><br><span class="line"></span><br><span class="line">// rust</span><br><span class="line">console.time(&#x27;rust&#x27;)</span><br><span class="line">console.log(rust.fibonacci(40))</span><br><span class="line">console.timeEnd(&#x27;rust&#x27;)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br><span class="line">102334155</span><br><span class="line">node: 1087.650ms</span><br><span class="line">102334155</span><br><span class="line">rust: 268.395ms</span><br><span class="line">(node:33302) Warning: N-API is an experimental feature and could change at any time.</span><br></pre></td></tr></table></figure>

<h2 id="3-5-6-参考链接"><a href="#3-5-6-参考链接" class="headerlink" title="3.5.6 参考链接"></a>3.5.6 参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/neon-bindings/neon">https://github.com/neon-bindings/neon</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/napi-rs/napi">https://github.com/napi-rs/napi</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27650526">https://zhuanlan.zhihu.com/p/27650526</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://marvinliu1.github.io/2019/05/10/3.4.1%20Ignition%20+%20Turbofan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marvin Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marvin's Blog">
      <meta itemprop="description" content="Take in the good!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Marvin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/10/3.4.1%20Ignition%20+%20Turbofan/" class="post-title-link" itemprop="url">Node in Debugging, 3.4 Ignition + Turbofan</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-10 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-10T00:00:00-06:00">2019-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Node-in-Debugging/" itemprop="url" rel="index"><span itemprop="name">Node in Debugging</span></a>
        </span>
    </span>

  
    <span id="/2019/05/10/3.4.1%20Ignition%20+%20Turbofan/" class="post-meta-item leancloud_visitors" data-flag-title="Node in Debugging, 3.4 Ignition + Turbofan" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging">Node in Debugging</a></p>
<p>如果你想以最简单的方式提升 Node.js 程序的性能，那就升级到 node@8+ 吧。这不是一个玩笑，多少 JavaScript 前辈们以血的教训总结出了一长列 “Optimization killers”，典型的有：</p>
<ol>
<li>在 try 里面不要写过多代码，V8 无法优化，最好将这些代码放到一个函数里，然后 try 这个函数。</li>
<li>少用 delete。</li>
<li>少用 arguments。</li>
<li>…</li>
</ol>
<p>然而，随着 V8 彻底换上了新的 JIT 编译器—— Turbofan，大多数 “Optimization killers” 都已经成了过去时。所以在本节中我们来看看哪些过去常见的 “Optimization killers” 已经可以被 V8 优化。</p>
<h2 id="3-4-1-Ignition-Turbofan"><a href="#3-4-1-Ignition-Turbofan" class="headerlink" title="3.4.1 Ignition + Turbofan"></a>3.4.1 Ignition + Turbofan</h2><p>之前 V8 使用的是名为 Crankshaft 的编译器，这个编译器后来逐渐暴露出一些缺点：</p>
<ol>
<li>Doesn’t scale to full, modern JavaScript (try-catch, for-of, generators, async&#x2F;await, …)</li>
<li>Defaults to deoptimization (performance cliffs, deoptimization loops)</li>
<li>Graph construction, inlining and optimization all mixed up</li>
<li>Tight coupling to fullcodegen &#x2F; brittle environment tracking</li>
<li>Limited optimization potential &#x2F; limited static analysis (i.e. type propagation)</li>
<li>High porting overhead</li>
<li>Mixed low-level and high-level semantics of instructions</li>
</ol>
<p>而引入 Turbofan 的好处是：</p>
<ol>
<li>Full ESnext language support (try-catch&#x2F;-finally, class literals, eval, generators, async functions, modules, destructuring, etc.)</li>
<li>Utilize and propagate (static) type information</li>
<li>Separate graph building from optimization &#x2F; inlining</li>
<li>No deoptimization loops &#x2F; deoptimization only when really beneficial</li>
<li>Sane environment tracking (also for lazy deoptimization)</li>
<li>Predictable peak performance</li>
</ol>
<p>Ignition 是 V8 新引入的解释器，用来将代码编译成简洁的字节码，而不是之前的机器码，这大大减少了结果代码，减少了系统的内存使用。由于字节码较小，所以可以编译全部源代码，而不用避免编译未使用的代码。也就是说，脚本只需要解析一次，而不是像之前的编译过程那样解析多次。</p>
<p>Ignition 与 TurboFan 的关系为：Ignition 解释器使用低级的、体系结构无关的 TurboFan 宏汇编指令为每个操作码生成字节码处理程序，TurboFan 将这些指令编译成目标平台的代码，并在这个过程中执行低级的指令选择和机器寄存器分配。</p>
<p>补充一点，之前的 V8 将代码编译成机器码执行，而新的 V8 将代码编译成字节码解释执行，动机是什么呢？可能是：</p>
<ol>
<li>减少机器码占用的内存空间，即牺牲时间换空间（主要动机）。</li>
<li>加快代码的启动速度。</li>
<li>对 V8 的代码进行重构，降低 V8 的代码复杂度。</li>
</ol>
<h2 id="3-4-2-版本对应关系"><a href="#3-4-2-版本对应关系" class="headerlink" title="3.4.2 版本对应关系"></a>3.4.2 版本对应关系</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node@6       -&gt; V8@5.1 -&gt; Crankshaft</span><br><span class="line">node@8.0-8.2 -&gt; V8@5.8 -&gt; Crankshaft + Turbofan</span><br><span class="line">                V8@5.9 -&gt; Turbofan</span><br><span class="line">node@8.3-8.4 -&gt; V8@6.0 -&gt; Turbofan</span><br></pre></td></tr></table></figure>

<h2 id="3-4-3-try-x2F-catch"><a href="#3-4-3-try-x2F-catch" class="headerlink" title="3.4.3 try&#x2F;catch"></a>3.4.3 try&#x2F;catch</h2><p>最著名的去优化之一是使用 try&#x2F;catch 代码块。下面通过 4 种场景比较在不同的 V8 版本下执行的效率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">var benchmark = require(&#x27;benchmark&#x27;)</span><br><span class="line">var suite = new benchmark.Suite()</span><br><span class="line"></span><br><span class="line">function sum (base, max) &#123;</span><br><span class="line">  var total = 0</span><br><span class="line"></span><br><span class="line">  for (var i = base; i &lt; max; i++) &#123;</span><br><span class="line">    total += i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;sum with try catch&#x27;, function sumTryCatch () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var base = 0</span><br><span class="line">    var max = 65535</span><br><span class="line"></span><br><span class="line">    var total = 0</span><br><span class="line"></span><br><span class="line">    for (var i = base; i &lt; max; i++) &#123;</span><br><span class="line">      total += i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err.message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;sum without try catch&#x27;, function noTryCatch () &#123;</span><br><span class="line">  var base = 0</span><br><span class="line">  var max = 65535</span><br><span class="line"></span><br><span class="line">  var total = 0</span><br><span class="line"></span><br><span class="line">  for (var i = base; i &lt; max; i++) &#123;</span><br><span class="line">    total += i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;sum wrapped&#x27;, function wrapped () &#123;</span><br><span class="line">  var base = 0</span><br><span class="line">  var max = 65535</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    sum(base, max)</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err.message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;sum function&#x27;, function func () &#123;</span><br><span class="line">  var base = 0</span><br><span class="line">  var max = 65535</span><br><span class="line"></span><br><span class="line">  sum(base, max)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.on(&#x27;complete&#x27;, require(&#x27;./print&#x27;))</span><br><span class="line">suite.run()</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging/blob/master/assets/3.4.1.jpg"><img src="https://github.com/nswbmw/node-in-debugging/raw/master/assets/3.4.1.jpg" alt="img"></a></p>
<p><strong>结论</strong>：在 <a href="mailto:&#110;&#111;&#x64;&#101;&#64;&#x38;&#46;&#x33;">&#110;&#111;&#x64;&#101;&#64;&#x38;&#46;&#x33;</a> 及以上版本中，在 try 块内写代码的性能损耗可以忽略不计。</p>
<h2 id="3-4-4-delete"><a href="#3-4-4-delete" class="headerlink" title="3.4.4 delete"></a>3.4.4 delete</h2><p>多年以来，delete 对于任何希望编写高性能 JavaScript 的人来说都是受限制的，我们通常用赋值 undefined 替代。delete 的问题归结为 V8 处理 JavaScript 对象的动态特性和原型链方式，使得属性查找在实现上变得复杂。下面通过 3 种场景比较在不同的 V8 版本下执行的效率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">var benchmark = require(&#x27;benchmark&#x27;)</span><br><span class="line">var suite = new benchmark.Suite()</span><br><span class="line"></span><br><span class="line">function MyClass (x, y) &#123;</span><br><span class="line">  this.x = x</span><br><span class="line">  this.y = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function MyClassLast (x, y) &#123;</span><br><span class="line">  this.y = y</span><br><span class="line">  this.x = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;setting to undefined&#x27;, function undefProp () &#123;</span><br><span class="line">  var obj = new MyClass(2, 3)</span><br><span class="line">  obj.x = undefined</span><br><span class="line"></span><br><span class="line">  JSON.stringify(obj)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;delete&#x27;, function deleteProp () &#123;</span><br><span class="line">  var obj = new MyClass(2, 3)</span><br><span class="line">  delete obj.x</span><br><span class="line"></span><br><span class="line">  JSON.stringify(obj)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;delete last property&#x27;, function deleteProp () &#123;</span><br><span class="line">  var obj = new MyClassLast(2, 3)</span><br><span class="line">  delete obj.x</span><br><span class="line"></span><br><span class="line">  JSON.stringify(obj)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;setting to undefined literal&#x27;, function undefPropLit () &#123;</span><br><span class="line">  var obj = &#123; x: 2, y: 3 &#125;</span><br><span class="line">  obj.x = undefined</span><br><span class="line"></span><br><span class="line">  JSON.stringify(obj)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;delete property literal&#x27;, function deletePropLit () &#123;</span><br><span class="line">  var obj = &#123; x: 2, y: 3 &#125;</span><br><span class="line">  delete obj.x</span><br><span class="line"></span><br><span class="line">  JSON.stringify(obj)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;delete last property literal&#x27;, function deletePropLit () &#123;</span><br><span class="line">  var obj = &#123; y: 3, x: 2 &#125;</span><br><span class="line">  delete obj.x</span><br><span class="line"></span><br><span class="line">  JSON.stringify(obj)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.on(&#x27;complete&#x27;, require(&#x27;./print&#x27;))</span><br><span class="line">suite.run()</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging/blob/master/assets/3.4.2.jpg"><img src="https://github.com/nswbmw/node-in-debugging/raw/master/assets/3.4.2.jpg" alt="img"></a></p>
<p><strong>结论</strong>：在 node@8 及以上版本中，delete 一个对象上的属性比 node@6 快了一倍。在 <a href="mailto:&#x6e;&#111;&#x64;&#x65;&#x40;&#56;&#46;&#51;">&#x6e;&#111;&#x64;&#x65;&#x40;&#56;&#46;&#51;</a> 及以上版本中，delete 一个对象上最后一个属性几乎与赋值 undefined 同样快了。</p>
<h2 id="3-4-5-arguments"><a href="#3-4-5-arguments" class="headerlink" title="3.4.5 arguments"></a>3.4.5 arguments</h2><p>我们知道 arguments 是个类数组，所以通常我们要使用 <code>Array.prototype.slice.call(arguments)</code> 将它转化成数组再使用，这样会有一定的性能损耗。下面通过 4 种场景比较在不同的 V8 版本下执行的效率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">var benchmark = require(&#x27;benchmark&#x27;)</span><br><span class="line">var suite = new benchmark.Suite()</span><br><span class="line"></span><br><span class="line">function leakyArguments () &#123;</span><br><span class="line">  return other(arguments)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function copyArgs () &#123;</span><br><span class="line">  var array = new Array(arguments.length)</span><br><span class="line"></span><br><span class="line">  for (var i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    array[i] = arguments[i]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return other(array)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sliceArguments () &#123;</span><br><span class="line">  var array = Array.prototype.slice.apply(arguments)</span><br><span class="line">  return other(array)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function spreadOp(...args) &#123;</span><br><span class="line">  return other(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function other (toSum) &#123;</span><br><span class="line">  var total = 0</span><br><span class="line">  for (var i = 0; i &lt; toSum.length; i++) &#123;</span><br><span class="line">    total += toSum[i]</span><br><span class="line">  &#125;</span><br><span class="line">  return total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;leaky arguments&#x27;, () =&gt; &#123;</span><br><span class="line">  leakyArguments(1, 2, 3)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;Array.prototype.slice arguments&#x27;, () =&gt; &#123;</span><br><span class="line">  sliceArguments(1, 2, 3)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;for-loop copy arguments&#x27;, () =&gt; &#123;</span><br><span class="line">  copyArgs(1, 2, 3)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;spread operator&#x27;, () =&gt; &#123;</span><br><span class="line">  spreadOp(1, 2, 3)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.on(&#x27;complete&#x27;, require(&#x27;./print&#x27;))</span><br><span class="line">suite.run()</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging/blob/master/assets/3.4.3.jpg"><img src="https://github.com/nswbmw/node-in-debugging/raw/master/assets/3.4.3.jpg" alt="img"></a></p>
<p><strong>结论</strong>：在 <a href="mailto:&#x6e;&#x6f;&#x64;&#101;&#x40;&#56;&#x2e;&#51;">&#x6e;&#x6f;&#x64;&#101;&#x40;&#56;&#x2e;&#51;</a> 及以上版本中，使用对象展开运算符是除直接使用 arguments 外最快的方案，对于 <a href="mailto:&#x6e;&#111;&#x64;&#x65;&#64;&#x38;&#46;&#x32;">&#x6e;&#111;&#x64;&#x65;&#64;&#x38;&#46;&#x32;</a> 及以下的版本，我们应该使用一个 for 循环将 key 从 arguments 复制到一个新的（预先分配的）数组中。总之，是时候抛弃 Array.prototype.slice.call 了。</p>
<h2 id="3-4-6-async-性能提升"><a href="#3-4-6-async-性能提升" class="headerlink" title="3.4.6 async 性能提升"></a>3.4.6 async 性能提升</h2><p>在 <a href="mailto:&#x56;&#x38;&#x40;&#53;&#x2e;&#x37;">&#x56;&#x38;&#x40;&#53;&#x2e;&#x37;</a> 发布后，原生的 async 函数与 Promise 一样快了，同时，Promise 的性能也比 <a href="mailto:&#86;&#56;&#64;&#53;&#46;&#x36;">&#86;&#56;&#64;&#53;&#46;&#x36;</a> 快了一倍。如图所示：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging/blob/master/assets/3.4.4.jpg"><img src="https://github.com/nswbmw/node-in-debugging/raw/master/assets/3.4.4.jpg" alt="img"></a></p>
<h2 id="3-4-7-不会优化的特性"><a href="#3-4-7-不会优化的特性" class="headerlink" title="3.4.7 不会优化的特性"></a>3.4.7 不会优化的特性</h2><p>并不是说上了 Turbofan 就能优化所有的 JavaScript 语法，有些语法 V8 是不会去优化的（也没有必要），例如：</p>
<ol>
<li>debugger</li>
<li>eval</li>
<li>with</li>
</ol>
<p>我们以 debugger 为例，比较使用和不使用 debugger 时的性能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var benchmark = require(&#x27;benchmark&#x27;)</span><br><span class="line">var suite = new benchmark.Suite()</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;with debugger&#x27;, function withDebugger () &#123;</span><br><span class="line">  var base = 0</span><br><span class="line">  var max = 65535</span><br><span class="line"></span><br><span class="line">  var total = 0</span><br><span class="line"></span><br><span class="line">  for (var i = base; i &lt; max; i++) &#123;</span><br><span class="line">    debugger</span><br><span class="line">    total += i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.add(&#x27;without debugger&#x27;, function withoutDebugger () &#123;</span><br><span class="line">  var base = 0</span><br><span class="line">  var max = 65535</span><br><span class="line"></span><br><span class="line">  var total = 0</span><br><span class="line"></span><br><span class="line">  for (var i = base; i &lt; max; i++) &#123;</span><br><span class="line">    total += i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">suite.on(&#x27;complete&#x27;, require(&#x27;./print&#x27;))</span><br><span class="line">suite.run()</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging/blob/master/assets/3.4.5.jpg"><img src="https://github.com/nswbmw/node-in-debugging/raw/master/assets/3.4.5.jpg" alt="img"></a></p>
<p><strong>结论</strong>：在所有测试的 V8 版本中，debugger 一直都很慢，所以记得在打断点测试完后一定要删掉 debugger。</p>
<h2 id="3-4-8-总结"><a href="#3-4-8-总结" class="headerlink" title="3.4.8 总结"></a>3.4.8 总结</h2><ol>
<li>使用最新 LTS 版本的 Node.js。</li>
<li>关注 V8 团队的博客——<a target="_blank" rel="noopener" href="https://v8project.blogspot.com/">https://v8project.blogspot.com</a>，了解第一手资讯。</li>
<li>清晰的代码远比使用一些奇技淫巧提升的一点性能重要得多。</li>
</ol>
<h2 id="3-4-9-参考链接"><a href="#3-4-9-参考链接" class="headerlink" title="3.4.9 参考链接"></a>3.4.9 参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/davidmarkclements/v8-perf">https://github.com/davidmarkclements/v8-perf</a></li>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/news/2016/08/v8-ignition-javascript-inteprete">http://www.infoq.com/cn/news/2016/08/v8-ignition-javascript-inteprete</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1H1lLsbclvzyOF3IUR05ZUaZcqDxo7_-8f4yJoxdMooU/edit#slide=id.g18ceb14729_0_59">https://docs.google.com/presentation/d/1H1lLsbclvzyOF3IUR05ZUaZcqDxo7_-8f4yJoxdMooU/edit#slide=id.g18ceb14729_0_59</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nearform.com/blog/node-js-is-getting-a-new-v8-with-turbofan">https://www.nearform.com/blog/node-js-is-getting-a-new-v8-with-turbofan</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26669846">https://zhuanlan.zhihu.com/p/26669846</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://marvinliu1.github.io/2019/05/02/3.3.1%20Stack%20Trace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marvin Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marvin's Blog">
      <meta itemprop="description" content="Take in the good!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Marvin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/02/3.3.1%20Stack%20Trace/" class="post-title-link" itemprop="url">Node in Debugging, 3.3 Stack Trace</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-02 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-02T00:00:00-06:00">2019-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Node-in-Debugging/" itemprop="url" rel="index"><span itemprop="name">Node in Debugging</span></a>
        </span>
    </span>

  
    <span id="/2019/05/02/3.3.1%20Stack%20Trace/" class="post-meta-item leancloud_visitors" data-flag-title="Node in Debugging, 3.3 Stack Trace" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging">Node in Debugging</a></p>
<p>对于 JavaScript 中的 Error，想必大家已经很熟悉了，毕竟天天与它打交道。</p>
<p>Node.js 内置的 Error 类型有：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/api/errors.html%23errors_class_error">Error</a>：通用的错误类型，例如：<code>new Error(&#39;error!!!&#39;)</code>。</li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/api/errors.html%23errors_class_syntaxerror">SyntaxError</a>：语法错误，例如：<code>require(&#39;vm&#39;).runInThisContext(&#39;binary ! isNotOk&#39;)</code>。</li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/api/errors.html%23errors_class_referenceerror">ReferenceError</a>：引用错误，如引用一个未定义的变量，例如：<code>doesNotExist</code>。</li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/api/errors.html%23errors_class_typeerror">TypeError</a>：类型错误，例如：<code>require(&#39;url&#39;).parse(() =&gt; &#123;&#125;)</code>。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError">URIError</a>：全局的 URI 处理函数抛出的错误，例如：<code>encodeURI(&#39;\uD800&#39;)</code>。</li>
<li><a target="_blank" rel="noopener" href="https://nodejs.org/api/errors.html%23errors_class_assertionerror">AssertError</a>：使用 assert 模块时抛出的错误，例如：<code>assert(false)</code>。</li>
</ol>
<p>每个 Error 对象通常有 name、message、stack、constructor 等属性。当程序抛出异常时，我们需要根据错误栈（error.stack）定位到出错代码。希望本节能够帮助读者理解并玩转错误栈，写出错误栈清晰的代码，方便调试。</p>
<h2 id="3-3-1-Stack-Trace"><a href="#3-3-1-Stack-Trace" class="headerlink" title="3.3.1 Stack Trace"></a>3.3.1 Stack Trace</h2><p>错误栈本质上就是调用栈（或者叫：堆栈追踪）。所以我们先复习一下 JavaScript 中调用栈的概念。</p>
<p><strong>调用栈</strong>：每当有一个函数调用，就会将其压入栈顶，在调用结束的时候再将其从栈顶移出。</p>
<p>来看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function c () &#123;</span><br><span class="line">  console.log(&#x27;c&#x27;)</span><br><span class="line">  console.trace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b () &#123;</span><br><span class="line">  console.log(&#x27;b&#x27;)</span><br><span class="line">  c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function a () &#123;</span><br><span class="line">  console.log(&#x27;a&#x27;)</span><br><span class="line">  b()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a()</span><br></pre></td></tr></table></figure>

<p>执行后打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">Trace</span><br><span class="line">    at c (/Users/nswbmw/Desktop/test/app.js:3:11)</span><br><span class="line">    at b (/Users/nswbmw/Desktop/test/app.js:8:3)</span><br><span class="line">    at a (/Users/nswbmw/Desktop/test/app.js:13:3)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:16:1)</span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：c 函数中 console.trace() 打印出的堆栈追踪依次为 c、b、a，即 a 调用了 b，b 调用了 c。</p>
<p>稍微修改下上面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function c () &#123;</span><br><span class="line">  console.log(&#x27;c&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b () &#123;</span><br><span class="line">  console.log(&#x27;b&#x27;)</span><br><span class="line">  c()</span><br><span class="line">  console.trace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function a () &#123;</span><br><span class="line">  console.log(&#x27;a&#x27;)</span><br><span class="line">  b()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a()</span><br></pre></td></tr></table></figure>

<p>执行后打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">Trace</span><br><span class="line">    at b (/Users/nswbmw/Desktop/test/app.js:8:11)</span><br><span class="line">    at a (/Users/nswbmw/Desktop/test/app.js:13:3)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:16:1)</span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：c() 在 console.trace() 之前执行完毕，从栈中移除，所以栈中从上往下为 b、a。</p>
<p>上面示例的代码过于简单，在实际情况下错误栈并没有这么直观。以常用的 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/mongoose">mongoose</a> 为例，mongoose 的错误栈并不友好：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const mongoose = require(&#x27;mongoose&#x27;)</span><br><span class="line">const Schema = mongoose.Schema</span><br><span class="line">mongoose.connect(&#x27;mongodb://localhost/test&#x27;)</span><br><span class="line"></span><br><span class="line">const UserSchema = new Schema(&#123;</span><br><span class="line">  id: mongoose.Schema.Types.ObjectId</span><br><span class="line">&#125;)</span><br><span class="line">const User = mongoose.model(&#x27;User&#x27;, UserSchema)</span><br><span class="line">User</span><br><span class="line">  .create(&#123; id: &#x27;xxx&#x27; &#125;)</span><br><span class="line">  .then(console.log)</span><br><span class="line">  .catch(console.error)</span><br></pre></td></tr></table></figure>

<p>运行后打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123; ValidationError: User validation failed: id: Cast to ObjectID failed for value &quot;xxx&quot; at path &quot;id&quot;</span><br><span class="line">    at ValidationError.inspect (/Users/nswbmw/Desktop/test/node_modules/mongoose/lib/error/validation.js:56:24)</span><br><span class="line">    at ...</span><br><span class="line">  errors:</span><br><span class="line">   &#123; id:</span><br><span class="line">      &#123; CastError: Cast to ObjectID failed for value &quot;xxx&quot; at path &quot;id&quot;</span><br><span class="line">    at new CastError (/Users/nswbmw/Desktop/test/node_modules/mongoose/lib/error/cast.js:27:11)</span><br><span class="line">    at model.$set (/Users/nswbmw/Desktop/test/node_modules/mongoose/lib/document.js:792:7)</span><br><span class="line">    at ...</span><br><span class="line">        message: &#x27;Cast to ObjectID failed for value &quot;xxx&quot; at path &quot;id&quot;&#x27;,</span><br><span class="line">        name: &#x27;CastError&#x27;,</span><br><span class="line">        stringValue: &#x27;&quot;xxx&quot;&#x27;,</span><br><span class="line">        kind: &#x27;ObjectID&#x27;,</span><br><span class="line">        value: &#x27;xxx&#x27;,</span><br><span class="line">        path: &#x27;id&#x27;,</span><br><span class="line">        reason: [Object] &#125; &#125;,</span><br><span class="line">  _message: &#x27;User validation failed&#x27;,</span><br><span class="line">  name: &#x27;ValidationError&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>从 mongoose 给出的 error.stack 中看不到任何有用的信息，error.message 告诉我们 “xxx” 不匹配 User 这个 Model 的 id（ObjectID）的类型，其他的字段基本上也是这个结论的补充，却没有给出我们最关心的问题：<strong>我写的代码中，到底哪一行出了问题？</strong></p>
<p>如何解决这个问题呢？我们先看看 Error.captureStackTrace 的用法。</p>
<h2 id="3-3-2-Error-captureStackTrace"><a href="#3-3-2-Error-captureStackTrace" class="headerlink" title="3.3.2 Error.captureStackTrace"></a>3.3.2 Error.captureStackTrace</h2><p>Error.captureStackTrace 是 V8 提供的一个 API，可以传入两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error.captureStackTrace(targetObject[, constructorOpt])</span><br></pre></td></tr></table></figure>

<p>Error.captureStackTrace 会在 targetObject 中添加一个 stack 属性，对该属性进行访问时，将以字符串的形式返回 Error.captureStackTrace() 语句被调用时的代码位置信息（即：调用栈历史）。</p>
<p>举个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myObject = &#123;&#125;</span><br><span class="line">Error.captureStackTrace(myObject)</span><br><span class="line">console.log(myObject.stack)</span><br><span class="line">// 输出</span><br><span class="line">Error</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:2:7)</span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p>除了 targetObject，captureStackTrace 还接收一个类型为 function 的可选参数 constructorOpt，当传递该参数时，调用栈中所有 constructorOpt 函数之上的信息(包括 constructorOpt 函数自身)，都会在访问 targetObject.stack 时被忽略。当需要对终端用户隐藏内部的实现细节时，constructorOpt 参数会很有用。传入第 2 个参数通常用于自定义错误，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function MyError() &#123;</span><br><span class="line">  Error.captureStackTrace(this, MyError)</span><br><span class="line">  this.name = this.constructor.name</span><br><span class="line">  this.message = &#x27;you got MyError&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myError = new MyError()</span><br><span class="line">console.log(myError)</span><br><span class="line">console.log(myError.stack)</span><br><span class="line">// 输出</span><br><span class="line">MyError &#123; name: &#x27;MyError&#x27;, message: &#x27;you got MyError&#x27; &#125;</span><br><span class="line">Error</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:7:17)</span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p>如果去掉 captureStackTrace 的第 2 个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function MyError() &#123;</span><br><span class="line">  Error.captureStackTrace(this)</span><br><span class="line">  this.name = this.constructor.name</span><br><span class="line">  this.message = &#x27;you got MyError&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const myError = new MyError()</span><br><span class="line">console.log(myError)</span><br><span class="line">console.log(myError.stack)</span><br><span class="line">// 输出</span><br><span class="line">MyError &#123; name: &#x27;MyError&#x27;, message: &#x27;you got MyError&#x27; &#125;</span><br><span class="line">Error</span><br><span class="line">    at new MyError (/Users/nswbmw/Desktop/test/app.js:2:9)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:7:17)</span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：出现了 MyError 相关的调用栈，但我们并不关心 MyError 及其内部是如何实现的。</p>
<p>captureStackTrace 的第 2 个参数可以传入调用链上的其他函数，不一定是当前函数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const myObj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">function c () &#123;</span><br><span class="line">  Error.captureStackTrace(myObj, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b () &#123;</span><br><span class="line">  c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function a () &#123;</span><br><span class="line">  b()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a()</span><br><span class="line">console.log(myObj.stack)</span><br><span class="line">// 输出</span><br><span class="line">Error</span><br><span class="line">    at a (/Users/nswbmw/Desktop/test/app.js:12:3)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:15:1)</span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：captureStackTrace 的第 2 个参数传入了函数 b，调用栈中隐藏了 b 函数及其以上所有的堆栈帧。</p>
<p>讲到这里，相信读者都明白了 captureStackTrace 的用法。但这具体有什么用呢？其实上面提到了：<strong>隐藏内部的实现细节，优化错误栈</strong>。</p>
<p>下面以笔者写的一个模块 <a target="_blank" rel="noopener" href="https://github.com/mongolass/mongolass">Mongolass</a> 为例，讲解如何应用 captureStackTrace。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/mongolass/mongolass">Mongolass</a> 是一个轻量且优雅的连接 MongoDB 的模块。</p>
</blockquote>
<h2 id="3-3-3-captureStackTrace-在-Mongolass-中的应用"><a href="#3-3-3-captureStackTrace-在-Mongolass-中的应用" class="headerlink" title="3.3.3 captureStackTrace 在 Mongolass 中的应用"></a>3.3.3 captureStackTrace 在 Mongolass 中的应用</h2><p>这里先大体讲讲 Mongolass 的用法。Mongolass 与 Mongoose 类似，有 Model 的概念，Model 上挂载的方法对应对 MongoDB 的 collections 的操作，例如：<code>User.insert</code>。User 是一个 Model 实例，<code>User.insert</code> 方法返回的是一个 Query 实例。Query 的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Query &#123;</span><br><span class="line">  constructor(op, args) &#123;</span><br><span class="line">    Error.captureStackTrace(this, this.constructor);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用 Error.captureStackTrace 隐藏了 Query 内部的错误栈细节，但这样带来一个问题：丢失了原来的 error.stack，在 Mongolass 中可以自定义插件，而插件函数的执行是在 Query 内部，假如在插件中抛错，则会丢失相关错误栈信息。</p>
<p>如何弥补呢？Mongolass 的做法是：当 Query 内部抛出错误（error）时，截取有用的 error.stack，然后拼接到 Query 实例通过 Error.captureStackTrace 生成的 stack 上。</p>
<p>来看一段 Mongolass 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const Mongolass = require(&#x27;mongolass&#x27;)</span><br><span class="line">const Schema = Mongolass.Schema</span><br><span class="line">const mongolass = new Mongolass(&#x27;mongodb://localhost:27017/test&#x27;)</span><br><span class="line"></span><br><span class="line">const UserSchema = new Schema(&#x27;UserSchema&#x27;, &#123;</span><br><span class="line">  name: &#123; type: &#x27;string&#x27; &#125;,</span><br><span class="line">  age: &#123; type: &#x27;number&#x27; &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const User = mongolass.model(&#x27;User&#x27;, UserSchema)</span><br><span class="line"></span><br><span class="line">User</span><br><span class="line">  .insertOne(&#123; name: &#x27;nswbmw&#x27;, age: &#x27;wrong age&#x27; &#125;)</span><br><span class="line">  .exec()</span><br><span class="line">  .then(console.log)</span><br><span class="line">  .catch(console.error)</span><br></pre></td></tr></table></figure>

<p>运行后打印的错误信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123; TypeError: ($.age: &quot;wrong age&quot;) ✖ (type: number)</span><br><span class="line">    at Model.insertOne (/Users/nswbmw/Desktop/test/node_modules/mongolass/lib/query.js:104:16)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:12:4)</span><br><span class="line">    at ...</span><br><span class="line">  validator: &#x27;type&#x27;,</span><br><span class="line">  actual: &#x27;wrong age&#x27;,</span><br><span class="line">  expected: &#123; type: &#x27;number&#x27; &#125;,</span><br><span class="line">  path: &#x27;$.age&#x27;,</span><br><span class="line">  schema: &#x27;UserSchema&#x27;,</span><br><span class="line">  model: &#x27;User&#x27;,</span><br><span class="line">  op: &#x27;insertOne&#x27;,</span><br><span class="line">  args: [ &#123; name: &#x27;nswbmw&#x27;, age: &#x27;wrong age&#x27; &#125; ],</span><br><span class="line">  pluginName: &#x27;MongolassSchema&#x27;,</span><br><span class="line">  pluginOp: &#x27;beforeInsertOne&#x27;,</span><br><span class="line">  pluginArgs: [] &#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：app.js 第 12 行的 insertOne 报错，报错原因是 age 字段是字符串 “wrong age”，而我们期望的是 number 类型的值。</p>
<h2 id="3-3-4-Error-prepareStackTrace"><a href="#3-3-4-Error-prepareStackTrace" class="headerlink" title="3.3.4 Error.prepareStackTrace"></a>3.3.4 Error.prepareStackTrace</h2><p>V8 暴露了另外一个接口——Error.prepareStackTrace。简单来讲，它的作用就是：<strong>定制 stack</strong>。用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error.prepareStackTrace(error, structuredStackTrace)</span><br></pre></td></tr></table></figure>

<p>第 1 个参数是个 Error 对象，第 2 个参数是一个数组，每一项都是一个 CallSite 对象，包含错误的函数名、行数等信息。对比以下两种代码：</p>
<p>正常的 throw error：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function c () &#123;</span><br><span class="line">  throw new Error(&#x27;error!!!&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b () &#123;</span><br><span class="line">  c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function a () &#123;</span><br><span class="line">  b()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  a()</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(e.stack)</span><br><span class="line">&#125;</span><br><span class="line">// 输出</span><br><span class="line">Error: error!!!</span><br><span class="line">    at c (/Users/nswbmw/Desktop/test/app.js:2:9)</span><br><span class="line">    at b (/Users/nswbmw/Desktop/test/app.js:6:3)</span><br><span class="line">    at a (/Users/nswbmw/Desktop/test/app.js:10:3)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:14:3)</span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p>使用 Error.prepareStackTrace 格式化 stack：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Error.prepareStackTrace = function (error, callSites) &#123;</span><br><span class="line">  return error.toString() + &#x27;\n&#x27; + callSites.map(callSite =&gt; &#123;</span><br><span class="line">    return &#x27;    -&gt; &#x27; + callSite.getFunctionName() + &#x27; (&#x27;</span><br><span class="line">      + callSite.getFileName() + &#x27;:&#x27;</span><br><span class="line">      + callSite.getLineNumber() + &#x27;:&#x27;</span><br><span class="line">      + callSite.getColumnNumber() + &#x27;)&#x27;</span><br><span class="line">  &#125;).join(&#x27;\n&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function c () &#123;</span><br><span class="line">  throw new Error(&#x27;error!!!&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b () &#123;</span><br><span class="line">  c()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function a () &#123;</span><br><span class="line">  b()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  a()</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  console.log(e.stack)</span><br><span class="line">&#125;</span><br><span class="line">// 输出</span><br><span class="line">Error: error!!!</span><br><span class="line">    -&gt; c (/Users/nswbmw/Desktop/test/app.js:11:9)</span><br><span class="line">    -&gt; b (/Users/nswbmw/Desktop/test/app.js:15:3)</span><br><span class="line">    -&gt; a (/Users/nswbmw/Desktop/test/app.js:19:3)</span><br><span class="line">    -&gt; null (/Users/nswbmw/Desktop/test/app.js:23:3)</span><br><span class="line">    -&gt; ...</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：我们自定义了一个 Error.prepareStackTrace 格式化了 stack 并打印出来。</p>
<p>CallSite 对象还有许多 API，例如：getThis、getTypeName、getFunction、getFunctionName、getMethodName、getFileName、getLineNumber、getColumnNumber、getEvalOrigin、isToplevel、isEval、isNative 和 isConstructor，这里不一一介绍了，有兴趣的读者可查看参考链接。</p>
<p>在使用 Error.prepareStackTrace 时需要注意两点：</p>
<ol>
<li>这个方法是 V8 暴露出来的，所以只能在基于 V8 的 Node.js 或者 Chrome 里才能使用。</li>
<li>这个方法会修改全局 Error 的行为。</li>
</ol>
<h2 id="3-3-5-Error-prepareStackTrace-的其他用法"><a href="#3-3-5-Error-prepareStackTrace-的其他用法" class="headerlink" title="3.3.5 Error.prepareStackTrace 的其他用法"></a>3.3.5 Error.prepareStackTrace 的其他用法</h2><p>Error.prepareStackTrace 除了格式化错误栈外还有什么作用呢？<a target="_blank" rel="noopener" href="https://github.com/sindresorhus">sindresorhus</a> 大神还写了一个 <a target="_blank" rel="noopener" href="https://github.com/sindresorhus/callsites">callsites</a> 的模块，可以用来获取函数调用相关的信息，例如获取执行该函数所在的文件名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const callsites = require(&#x27;callsites&#x27;)</span><br><span class="line"></span><br><span class="line">function getFileName() &#123;</span><br><span class="line">  console.log(callsites()[0].getFileName())</span><br><span class="line">  //=&gt; &#x27;/Users/nswbmw/Desktop/test/app.js&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFileName()</span><br></pre></td></tr></table></figure>

<p>我们来看一下源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = () =&gt; &#123;</span><br><span class="line">  const _ = Error.prepareStackTrace</span><br><span class="line">  Error.prepareStackTrace = (_, stack) =&gt; stack</span><br><span class="line">  const stack = new Error().stack.slice(1)</span><br><span class="line">  Error.prepareStackTrace = _</span><br><span class="line">  return stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意以下几点：</p>
<ol>
<li>因为修改 Error.prepareStackTrace 会全局生效，所以将原来的 Error.prepareStackTrace 存到一个变量中，函数执行完后再重置回去，避免影响全局的 Error。</li>
<li>Error.prepareStackTrace 函数直接返回 CallSite 对象数组，而不是格式化后的 stack 字符串。</li>
<li>new 一个 Error，stack 是返回的 CallSite 对象数组，因为第 1 项是 callsites，它总是这个模块的 CallSite，所以通过 slice(1) 去掉。</li>
</ol>
<p>假如我们想获取当前函数的父函数名，则可以这样用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const callsites = require(&#x27;callsites&#x27;)</span><br><span class="line"></span><br><span class="line">function b () &#123;</span><br><span class="line">  console.log(callsites()[1].getFunctionName())</span><br><span class="line">  // =&gt; &#x27;a&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function a () &#123;</span><br><span class="line">  b()</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure>

<h2 id="3-3-6-Error-stackTraceLimit"><a href="#3-3-6-Error-stackTraceLimit" class="headerlink" title="3.3.6 Error.stackTraceLimit"></a>3.3.6 Error.stackTraceLimit</h2><p>Node.js 还暴露了一个 Error.stackTraceLimit 的设置，可以通过设置这个值来改变输出的 stack 的行数，默认值是 10。</p>
<h2 id="3-3-7-Long-Stack-Trace"><a href="#3-3-7-Long-Stack-Trace" class="headerlink" title="3.3.7 Long Stack Trace"></a>3.3.7 Long Stack Trace</h2><p>stack trace 也有短板，问题出在异步操作上。若在异步回调中抛错，就会丢失绑定回调前的调用栈信息，来看个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const foo = function () &#123;</span><br><span class="line">  throw new Error(&#x27;error!!!&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">const bar = function () &#123;</span><br><span class="line">  setTimeout(foo)</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br><span class="line">// 输出</span><br><span class="line">/Users/nswbmw/Desktop/test/app.js:2</span><br><span class="line">  throw new Error(&#x27;error!!!&#x27;)</span><br><span class="line">  ^</span><br><span class="line"></span><br><span class="line">Error: error!!!</span><br><span class="line">    at Timeout.foo [as _onTimeout] (/Users/nswbmw/Desktop/test/app.js:2:9)</span><br><span class="line">    at ontimeout (timers.js:469:11)</span><br><span class="line">    at tryOnTimeout (timers.js:304:5)</span><br><span class="line">    at Timer.listOnTimeout (timers.js:264:5)</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：丢失了 bar 的调用栈。</p>
<p>在实际开发过程中，异步回调的例子数不胜数，如果不能知道异步回调之前的触发位置，则会给 debug 带来很大的难度。这时，出现了一个叫 long Stack Trace 的概念。</p>
<p>long Stack Trace 并不是 JavaScript 原生就支持的功能，所以要拥有这样的功能，就需要我们做一些 hack，幸好在 V8 环境下，所有 hack 所需的 API，V8 都已经提供了。</p>
<p>对于异步回调，目前能做的就是在所有会产生异步操作的 API 上做一些手脚，这些 API 包括：</p>
<ul>
<li>setTimeout, setInterval, setImmediate。</li>
<li>nextTick, nextDomainTick。</li>
<li>EventEmitter.addEventListener。</li>
<li>EventEmitter.on。</li>
<li>Ajax XHR。</li>
</ul>
<p>Long Stack Trace 相关的库可以参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/AndreasMadsen/trace">AndreasMadsen&#x2F;trace</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mattinsler/longjohn">mattinsler&#x2F;longjohn</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tlrobinson/long-stack-traces">tlrobinson&#x2F;long-stack-traces</a></li>
</ol>
<p>node@8+ 提供了强大的 async_hooks 模块，在本书的后面章节会介绍如何使用。</p>
<h2 id="3-3-8-参考链接"><a href="#3-3-8-参考链接" class="headerlink" title="3.3.8 参考链接"></a>3.3.8 参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25338849">https://zhuanlan.zhihu.com/p/25338849</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007076507">https://segmentfault.com/a/1190000007076507</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/v8/v8/wiki/Stack-Trace-API">https://github.com/v8/v8/wiki/Stack-Trace-API</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1d5120ad62bb">https://www.jianshu.com/p/1d5120ad62bb</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://marvinliu1.github.io/2019/04/28/3.2.1%20async%20+%20await/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marvin Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marvin's Blog">
      <meta itemprop="description" content="Take in the good!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Marvin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/28/3.2.1%20async%20+%20await/" class="post-title-link" itemprop="url">Node in Debugging, 3.2 Async and Await</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-28 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-28T00:00:00-06:00">2019-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Node-in-Debugging/" itemprop="url" rel="index"><span itemprop="name">Node in Debugging</span></a>
        </span>
    </span>

  
    <span id="/2019/04/28/3.2.1%20async%20+%20await/" class="post-meta-item leancloud_visitors" data-flag-title="Node in Debugging, 3.2 Async and Await" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging">Node in Debugging</a></p>
<p>笔者在很长一段时间内都在使用 koa@1 +（generator|bluebird）+ sequelize 这个组合，这个组合并没有什么问题，也很常见，但是到了滥用的地步，导致后来维护和调试起来都很痛苦。若排除 sequelize 这个我们不得不用的模块，从调试 cpuprofile 的角度讲讲为什么笔者认为应该用 async&#x2F;await + Promise 替代 co + generator|bluebird。</p>
<p>笔者的观点是：<strong>使用原生模块具有更清晰的调用栈</strong>。</p>
<p>下面用 4 个例子进行对比，看看实现相同逻辑的不同代码生成的 cpuprofile 中调用栈的信息。</p>
<h2 id="3-2-1-async-await"><a href="#3-2-1-async-await" class="headerlink" title="3.2.1 async + await"></a>3.2.1 async + await</h2><p><strong>async.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const profiler = require(&#x27;v8-profiler&#x27;)</span><br><span class="line"></span><br><span class="line">async function A () &#123;</span><br><span class="line">  return await Promise.resolve(&#x27;A&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function B () &#123;</span><br><span class="line">  return await A()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async function asyncWrap () &#123;</span><br><span class="line">  const start = Date.now()</span><br><span class="line">  profiler.startProfiling()</span><br><span class="line">  while (Date.now() - start &lt; 10000) &#123;</span><br><span class="line">    await B()</span><br><span class="line">  &#125;</span><br><span class="line">  const profile = profiler.stopProfiling()</span><br><span class="line">  profile.export()</span><br><span class="line">    .pipe(fs.createWriteStream(&#x27;async.cpuprofile&#x27;))</span><br><span class="line">    .on(&#x27;finish&#x27;, () =&gt; &#123;</span><br><span class="line">      profile.delete()</span><br><span class="line">      console.error(&#x27;async.cpuprofile export success&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>加载运行后生成的 async.cpuprofile，如下所示：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging/blob/master/assets/3.1.1.png"><img src="https://github.com/nswbmw/node-in-debugging/raw/master/assets/3.1.1.png" alt="img"></a></p>
<p><strong>可以看出</strong>：asyncWrap 中调用了 B 函数，B 函数调用了 A 函数，A 函数中 resolve 了一个值。在 asyncWrap 中还调用了 stopProfiling 函数。</p>
<h2 id="3-2-2-co-yield"><a href="#3-2-2-co-yield" class="headerlink" title="3.2.2 co + yield"></a>3.2.2 co + yield</h2><p><strong>co.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const co = require(&#x27;co&#x27;)</span><br><span class="line">const profiler = require(&#x27;v8-profiler&#x27;)</span><br><span class="line"></span><br><span class="line">function * A () &#123;</span><br><span class="line">  return yield Promise.resolve(&#x27;A&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function * B () &#123;</span><br><span class="line">  return yield A()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(function * coWrap () &#123;</span><br><span class="line">  const start = Date.now()</span><br><span class="line">  profiler.startProfiling()</span><br><span class="line">  while (Date.now() - start &lt; 10000) &#123;</span><br><span class="line">    yield B()</span><br><span class="line">  &#125;</span><br><span class="line">  const profile = profiler.stopProfiling()</span><br><span class="line">  profile.export()</span><br><span class="line">    .pipe(fs.createWriteStream(&#x27;co.cpuprofile&#x27;))</span><br><span class="line">    .on(&#x27;finish&#x27;, () =&gt; &#123;</span><br><span class="line">      profile.delete()</span><br><span class="line">      console.error(&#x27;co.cpuprofile export success&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>加载运行后生成的 co.cpuprofile，如下所示：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging/blob/master/assets/3.1.2.png"><img src="https://github.com/nswbmw/node-in-debugging/raw/master/assets/3.1.2.png" alt="img"></a></p>
<p><strong>可以看出</strong>：调用栈非常深，有太多没有用的 co 相关的调用栈。如果 n 个 generator 层层嵌套，就会出现 n 倍的 (anonymous)-&gt;onFullfiled-&gt;next-&gt;toPromise-&gt;co-&gt;Promise-&gt;(anonymous) 调用栈。如果你读过 co 的源码，就可能知道，这是 co 将 generator 解包的过程。其实这个可以通过将 <code>yield generator</code> 替换成 <code>yield* generator</code> 来优化。</p>
<h2 id="3-2-3-co-yield"><a href="#3-2-3-co-yield" class="headerlink" title="3.2.3 co + yield*"></a>3.2.3 co + yield*</h2><p><strong>co_better.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const co = require(&#x27;co&#x27;)</span><br><span class="line">const profiler = require(&#x27;v8-profiler&#x27;)</span><br><span class="line"></span><br><span class="line">function * A () &#123;</span><br><span class="line">  return yield Promise.resolve(&#x27;A&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function * B () &#123;</span><br><span class="line">  return yield * A()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(function * coWrap () &#123;</span><br><span class="line">  const start = Date.now()</span><br><span class="line">  profiler.startProfiling()</span><br><span class="line">  while (Date.now() - start &lt; 10000) &#123;</span><br><span class="line">    yield * B()</span><br><span class="line">  &#125;</span><br><span class="line">  const profile = profiler.stopProfiling()</span><br><span class="line">  profile.export()</span><br><span class="line">    .pipe(fs.createWriteStream(&#x27;co_better.cpuprofile&#x27;))</span><br><span class="line">    .on(&#x27;finish&#x27;, () =&gt; &#123;</span><br><span class="line">      profile.delete()</span><br><span class="line">      console.error(&#x27;co_better.cpuprofile export success&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>加载运行后生成的 co_better.cpuprofile，如下所示：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging/blob/master/assets/3.1.3.png"><img src="https://github.com/nswbmw/node-in-debugging/raw/master/assets/3.1.3.png" alt="img"></a></p>
<p><strong>可以看出</strong>：与 co.js 相比，调用栈清晰了很多，不过与使用 async&#x2F;await 相比，还是多了些 onFulfilled、next。</p>
<h2 id="3-2-4-co-bluebird"><a href="#3-2-4-co-bluebird" class="headerlink" title="3.2.4 co + bluebird"></a>3.2.4 co + bluebird</h2><p><strong>co_bluebird.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const co = require(&#x27;co&#x27;)</span><br><span class="line">const Promise = require(&#x27;bluebird&#x27;)</span><br><span class="line">const profiler = require(&#x27;v8-profiler&#x27;)</span><br><span class="line"></span><br><span class="line">function * A () &#123;</span><br><span class="line">  return yield Promise.resolve(&#x27;A&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function * B () &#123;</span><br><span class="line">  return yield * A()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(function * coBluebirdWrap () &#123;</span><br><span class="line">  const start = Date.now()</span><br><span class="line">  profiler.startProfiling()</span><br><span class="line">  while (Date.now() - start &lt; 10000) &#123;</span><br><span class="line">    yield * B()</span><br><span class="line">  &#125;</span><br><span class="line">  const profile = profiler.stopProfiling()</span><br><span class="line">  profile.export()</span><br><span class="line">    .pipe(fs.createWriteStream(&#x27;co_bluebird.cpuprofile&#x27;))</span><br><span class="line">    .on(&#x27;finish&#x27;, () =&gt; &#123;</span><br><span class="line">      profile.delete()</span><br><span class="line">      console.error(&#x27;co_bluebird.cpuprofile export success&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>加载运行后生成的 co_bluebird.cpuprofile，如下所示：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging/blob/master/assets/3.1.4.png"><img src="https://github.com/nswbmw/node-in-debugging/raw/master/assets/3.1.4.png" alt="img"></a></p>
<p><strong>可以看出</strong>：与 co_better.js 相比，调用栈中多了许多 bluebird 模块的无用信息。而且这只是非常简单的示例代码，要是在复杂的业务逻辑中大量使用 bluebird 代码生成的 cpuprofile，就几乎没法看了。</p>
<p><strong>结论</strong>：使用 async&#x2F;await + Promise + 命名函数，具有更清晰的调用栈，让分析 cpuprofile 时不再痛苦。</p>
<p>聪明的你可能会问：</p>
<ol>
<li>为什么不建议用 bluebird？因为：<ol>
<li>随着 V8 不断优化，原生 Promise 性能逐渐提高，bluebird 的性能优势不明显。</li>
<li>原生 Promise 的 API 足够用，至少能覆盖大部分使用场景，而且还在不断完善，未来还会添加新的 API，例如：Promise.prototype.finally。</li>
<li>具有更清晰的调用栈。</li>
</ol>
</li>
<li>由于历史遗留原因，现在代码中大量使用了 yield + generator 怎么办？可以：<ol>
<li>将所有 yield generator 替换成 yield * generator。</li>
<li>升级到 node@8+，逐步用 async&#x2F;await 替换，毕竟 async 函数调用后返回的也是一个 promise，也是 yieldable 的。</li>
</ol>
</li>
<li>性能比较呢？<ol>
<li>node@8+ 下 async&#x2F;await 完胜 co。</li>
</ol>
</li>
</ol>
<h2 id="3-2-5-yield-gt-yield-遇到的坑"><a href="#3-2-5-yield-gt-yield-遇到的坑" class="headerlink" title="3.2.5 yield -&gt; yield* 遇到的坑"></a>3.2.5 yield -&gt; yield* 遇到的坑</h2><p>上面讲到，可以将 yield generator 改成 yield * generator，这里面有一个坑，是由于不明白 co 的原理而滥用 co 导致的。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const co = require(&#x27;co&#x27;)</span><br><span class="line"></span><br><span class="line">function * genFunc () &#123;</span><br><span class="line">  return Promise.resolve(&#x27;genFunc&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(function * () &#123;</span><br><span class="line">  console.log(yield genFunc()) // =&gt; genFunc</span><br><span class="line">  console.log(yield * genFunc()) // =&gt; Promise &#123; &#x27;genFunc&#x27; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：genFunc 这个 generatorFunction 在执行后会返回一个 promise，当使用 <code>yield genFunc()</code> 的时候，co 判断返回了一个 promise 会继续帮我们调用它的 then 从而得到真正的字符串。如果使用 <code>yield * genFunc()</code>，就用了语言原生的特性而不经过 co，直接返回一个 promise。</p>
<p><strong>解决方法（任选其一）</strong>：</p>
<ol>
<li><code>function * genFunc</code> -&gt; <code>function genFunc</code>，用 <code>yield genFunc()</code>。</li>
<li><code>return Promise.resolve(&#39;genFunc&#39;)</code> -&gt; <code>return yield Promise.resolve(&#39;genFunc&#39;)</code>，用 <code>yield* genFunc()</code>。</li>
</ol>
<p>不过，建议最终转换到 async&#x2F;await + Promise 上来，毕竟 co + generator 只是一个过渡产物。</p>
<h2 id="3-2-6-async-bluebird"><a href="#3-2-6-async-bluebird" class="headerlink" title="3.2.6 async + bluebird"></a>3.2.6 async + bluebird</h2><p>如果是使用 async&#x2F;await + bluebird 的情况呢？代码如下：</p>
<p><strong>async_bluebird.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const profiler = require(&#x27;v8-profiler&#x27;)</span><br><span class="line">const Promise = require(&#x27;bluebird&#x27;)</span><br><span class="line"></span><br><span class="line">async function A () &#123;</span><br><span class="line">  return await Promise.resolve(&#x27;A&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function B () &#123;</span><br><span class="line">  return await A()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(async function asyncBluebirdWrap () &#123;</span><br><span class="line">  const start = Date.now()</span><br><span class="line">  profiler.startProfiling()</span><br><span class="line">  while (Date.now() - start &lt; 10000) &#123;</span><br><span class="line">    await B()</span><br><span class="line">  &#125;</span><br><span class="line">  const profile = profiler.stopProfiling()</span><br><span class="line">  profile.export()</span><br><span class="line">    .pipe(fs.createWriteStream(&#x27;async_bluebird.cpuprofile&#x27;))</span><br><span class="line">    .on(&#x27;finish&#x27;, () =&gt; &#123;</span><br><span class="line">      profile.delete()</span><br><span class="line">      console.error(&#x27;async_bluebird.cpuprofile export success&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：调用栈比 co_blueblird.js 的还乱。</p>
<h2 id="3-2-7-参考链接"><a href="#3-2-7-参考链接" class="headerlink" title="3.2.7 参考链接"></a>3.2.7 参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://medium.com/@markherhold/generators-vs-async-await-performance-806d8375a01a">https://medium.com/@markherhold/generators-vs-async-await-performance-806d8375a01a</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://marvinliu1.github.io/2019/04/21/3.1.1%20PromiseA+%20%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marvin Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marvin's Blog">
      <meta itemprop="description" content="Take in the good!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Marvin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/21/3.1.1%20PromiseA+%20%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">Node in Debugging, 3.1 PromiseA standard</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-21 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-21T00:00:00-06:00">2019-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Node-in-Debugging/" itemprop="url" rel="index"><span itemprop="name">Node in Debugging</span></a>
        </span>
    </span>

  
    <span id="/2019/04/21/3.1.1%20PromiseA+%20%E8%A7%84%E8%8C%83/" class="post-meta-item leancloud_visitors" data-flag-title="Node in Debugging, 3.1 PromiseA standard" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging">Node in Debugging</a></p>
<p>如何写出清晰优雅的代码也是调试重要的一部分，而在过去很长一段时间内，JavaScript 最令人吐槽的就是回调地狱（callback hell）了。先看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">step1(function  (err, value1) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    ...</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  step2(value1, function (err, value2) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      ...</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    step3(value2, function (err, value3) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        ...</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      // Do something with value3</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码依次执行 step1、step2、step3，且后一个函数用到了前一个函数执行的结果。这只是一个简单的例子，真实环境下可能会写出嵌套更深的回调函数，代码形成一个倒金字塔。如果使用 Promise，代码就优雅很多了，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">step1()</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .catch((e) =&gt; &#123;</span><br><span class="line">    // Do something with error</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>Promise 的出现就是为了解决回调地狱的问题，它最早是由社区提出和实现的，衍生的规范也有很多，最终 ES6 采用了 Promise&#x2F;A+ 规范，并将其写进了语言标准，统一了用法。</p>
<h2 id="3-1-1-Promise-x2F-A-规范"><a href="#3-1-1-Promise-x2F-A-规范" class="headerlink" title="3.1.1 Promise&#x2F;A+ 规范"></a>3.1.1 Promise&#x2F;A+ 规范</h2><p>Promise 规范有很多，如 Promise&#x2F;A，Promise&#x2F;B，Promise&#x2F;D 以及 Promise&#x2F;A 的升级版 Promise&#x2F;A+，细节各有不同，最终 ES6 中采用了 Promise&#x2F;A+ 规范。在讲解 Promise 实现之前，当然要先了解 Promise&#x2F;A+ 规范，Promise&#x2F;A+ 规范参考：</p>
<ul>
<li>英文版：<a target="_blank" rel="noopener" href="https://promisesaplus.com/">https://promisesaplus.com/</a></li>
<li>中文版：<a target="_blank" rel="noopener" href="http://www.ituring.com.cn/article/66566">http://www.ituring.com.cn/article/66566</a></li>
</ul>
<p>规范虽然不长，但细节也比较多，笔者挑出几个要点简单说明一下：</p>
<ol>
<li>Promise 本质是一个状态机。每个 promise 只能是 3 种状态中的一种：pending、fulfilled 或 rejected。状态转变只能是 pending -&gt; fulfilled 或者 pending -&gt; rejected。状态转变不可逆。</li>
<li>then 方法可以被同一个 promise 调用多次。</li>
<li>then 方法必须返回一个 promise，从而可以实现链式调用。</li>
<li>值穿透。下面会讲。</li>
</ol>
<p>Promise 的 API 并不多，但是 Promise 并不简单，如何彻底理解并玩转 Promise 呢？当然是从头实现一遍 Promise 啦。我们假设读者已经熟悉了 Promise 的基本用法，本节内容分为两部分：第一部分讲解如何从零开始实现一个 Promise，第二部分通过十道题巩固读者对 Promise 的理解。</p>
<h2 id="3-1-2-从零开始实现-Promise"><a href="#3-1-2-从零开始实现-Promise" class="headerlink" title="3.1.2 从零开始实现 Promise"></a>3.1.2 从零开始实现 Promise</h2><p>我们知道 Promise 是本质是一个构造函数，需要用 new 调用，并有以下几个 api：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Promise (resolver) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function () &#123;&#125;</span><br><span class="line">Promise.prototype.catch = function () &#123;&#125;</span><br><span class="line"></span><br><span class="line">Promise.resolve = function () &#123;&#125;</span><br><span class="line">Promise.reject = function () &#123;&#125;</span><br><span class="line">Promise.all = function () &#123;&#125;</span><br><span class="line">Promise.race = function () &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>创建以下初始代码，然后开始一步一步构建完整的 Promise 实现。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function INTERNAL () &#123;&#125;</span><br><span class="line">function isFunction (func) &#123;</span><br><span class="line">  return typeof func === &#x27;function&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function isObject (obj) &#123;</span><br><span class="line">  return typeof obj === &#x27;object&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function isArray (arr) &#123;</span><br><span class="line">  return Array.isArray(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const PENDING = &#x27;pending&#x27;</span><br><span class="line">const FULFILLED = &#x27;fulfilled&#x27;</span><br><span class="line">const REJECTED = &#x27;rejected&#x27;</span><br><span class="line"></span><br><span class="line">module.exports = Promise</span><br><span class="line"></span><br><span class="line">function Promise (resolver) &#123;</span><br><span class="line">  if (!isFunction(resolver)) &#123;</span><br><span class="line">    throw new TypeError(&#x27;resolver must be a function&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  this.state = PENDING</span><br><span class="line">  this.value = void 0</span><br><span class="line">  this.queue = []</span><br><span class="line">  if (resolver !== INTERNAL) &#123;</span><br><span class="line">    safelyResolveThen(this, resolver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：以下 promise 均指代 Promise 实例。</p>
<p>INTERNAL 就是一个空函数，后面会用来传入 Promise 构造函数生成一个 promise 实例。定义了 3 个辅助函数：isFunction、isObject 和 isArray。定义了 3 种状态：PENDING、FULFILLED 和 REJECTED。safelyResolveThen 后面会讲。promise 内部有三个变量：</p>
<ol>
<li>state：当前 promise 的状态，初始值为 PENDING。状态改变只能是 PENDING -&gt; FULFILLED 或 PENDING -&gt; REJECTED。</li>
<li>value：初始值是 void 0（即 undefined），当 state 是 FULFILLED 时存储返回值，当 state 是 REJECTED 时存储错误。</li>
<li>queue：promise 内部的回调队列，后面会讲它的作用。</li>
</ol>
<h2 id="3-1-3-Promise-实现原理"><a href="#3-1-3-Promise-实现原理" class="headerlink" title="3.1.3 Promise 实现原理"></a>3.1.3 Promise 实现原理</h2><p>笔者发布了一个 Promise&#x2F;A+ 规范实现的模块——appoint，我们拿这个模块研究一下它是如何实现 Promise 的。看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Promise = require(&#x27;appoint&#x27;)</span><br><span class="line">const promise = new Promise((resolve) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;haha&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">const a = promise.then(function onSuccess () &#123;&#125;)</span><br><span class="line">const b = promise.catch(function onError () &#123;&#125;)</span><br><span class="line">console.dir(promise, &#123; depth: 10 &#125;)</span><br><span class="line">console.log(promise.queue[0].promise === a)</span><br><span class="line">console.log(promise.queue[1].promise === b)</span><br></pre></td></tr></table></figure>

<p>运行后打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Promise &#123;</span><br><span class="line">  state: &#x27;pending&#x27;,</span><br><span class="line">  value: undefined,</span><br><span class="line">  queue:</span><br><span class="line">   [ QueueItem &#123;</span><br><span class="line">       promise: Promise &#123; state: &#x27;pending&#x27;, value: undefined, queue: [] &#125;,</span><br><span class="line">       callFulfilled: [Function],</span><br><span class="line">       callRejected: [Function] &#125;,</span><br><span class="line">     QueueItem &#123;</span><br><span class="line">       promise: Promise &#123; state: &#x27;pending&#x27;, value: undefined, queue: [] &#125;,</span><br><span class="line">       callFulfilled: [Function],</span><br><span class="line">       callRejected: [Function] &#125; ] &#125;</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：原生 Promise 是没有 queue 属性的，appoint 的实现中添加了这个属性。</p>
<p>可以看出，queue 数组中有两个对象。因为规范中规定：<strong>then 方法可以被同一个 promise 调用多次</strong>。上例中在调用 .then 和 .catch 时 promise 并没有被 resolve，所以将 .then 和 .catch 生成的新 promise（a 和 b） 和正确时的回调（onSuccess 包装成 callFulfilled）和错误时的回调（onError 包装成 callRejected）生成一个 QueueItem 实例并 push 到 queue 数组里，所以两个 console.log 都打印 true。当 promise 状态改变时遍历内部 queue 数组，统一执行成功（callFulfilled）或失败（callRejected）的回调（传入 promise 的 value 值），生成的结果分别设置 a 和 b 的 state 和 value，这就是 Promise 实现的基本原理。 再来看另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Promise = require(&#x27;appoint&#x27;)</span><br><span class="line">const promise = new Promise((resolve) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;haha&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">  .then(() =&gt; &#123;&#125;)</span><br><span class="line">  .then(() =&gt; &#123;&#125;)</span><br><span class="line">  .then(() =&gt; &#123;&#125;)</span><br><span class="line">console.dir(promise, &#123; depth: 10 &#125;)</span><br></pre></td></tr></table></figure>

<p>打印出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Promise &#123;</span><br><span class="line">  state: &#x27;pending&#x27;,</span><br><span class="line">  value: undefined,</span><br><span class="line">  queue:</span><br><span class="line">   [ QueueItem &#123;</span><br><span class="line">       promise:</span><br><span class="line">        Promise &#123;</span><br><span class="line">          state: &#x27;pending&#x27;,</span><br><span class="line">          value: undefined,</span><br><span class="line">          queue:</span><br><span class="line">           [ QueueItem &#123;</span><br><span class="line">               promise:</span><br><span class="line">                Promise &#123;</span><br><span class="line">                  state: &#x27;pending&#x27;,</span><br><span class="line">                  value: undefined,</span><br><span class="line">                  queue:</span><br><span class="line">                   [ QueueItem &#123;</span><br><span class="line">                       promise: Promise &#123; state: &#x27;pending&#x27;, value: undefined, queue: [] &#125;,</span><br><span class="line">                       callFulfilled: [Function],</span><br><span class="line">                       callRejected: [Function] &#125; ] &#125;,</span><br><span class="line">               callFulfilled: [Function],</span><br><span class="line">               callRejected: [Function] &#125; ] &#125;,</span><br><span class="line">       callFulfilled: [Function],</span><br><span class="line">       callRejected: [Function] &#125; ] &#125;</span><br></pre></td></tr></table></figure>

<p>链式调用了 3 次 .then，每次调用 .then 将它生成的 promise 放到了调用它的 promise 队列里，形成了 3 层调用关系。当最外层的 promise 状态改变时，遍历它的 queue 数组调用对应的回调，设置子 promise 的 state 和 value 并遍历它的 queue 数组调用对应的回调……以此类推。</p>
<p><strong>注意</strong>：这里 queue 是嵌套的，而不是像上个例子中 queue 是平铺的。</p>
<h2 id="3-1-4-safelyResolveThen"><a href="#3-1-4-safelyResolveThen" class="headerlink" title="3.1.4 safelyResolveThen"></a>3.1.4 safelyResolveThen</h2><p>接下来完成 safelyResolveThen 的逻辑，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function safelyResolveThen (self, then) &#123;</span><br><span class="line">  let called = false</span><br><span class="line">  try &#123;</span><br><span class="line">    then(function (value) &#123;</span><br><span class="line">      if (called) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      called = true</span><br><span class="line">      doResolve(self, value)</span><br><span class="line">    &#125;, function (error) &#123;</span><br><span class="line">      if (called) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      called = true</span><br><span class="line">      doReject(self, error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    if (called) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    called = true</span><br><span class="line">    doReject(self, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>safelyResolveThen 顾名思义用来 “安全的执行 then 函数”，这里的 then 函数指 “第一个参数是 resolve 函数第二个参数是 reject 函数的函数”，适用于以下两种情况：</p>
<ol>
<li>构造函数的参数，即这里的 resolver：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function resolver (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;haha&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>promise 的 then：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(resolve, reject)</span><br></pre></td></tr></table></figure>

<p>safelyResolveThen 有 3 个作用：</p>
<ol>
<li>try…catch 用来捕获函数内抛出的异常，如构造函数内抛出异常：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function resolver (resolve, reject) &#123;</span><br><span class="line">  throw new Error(&#x27;Oops&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>called 控制 resolve 或 reject 只执行一次，多次调用没有任何作用。即：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const Promise = require(&#x27;appoint&#x27;)</span><br><span class="line">const promise = new Promise(function resolver (resolve, reject) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;haha&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">  reject(&#x27;error&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(console.log)</span><br><span class="line">promise.catch(console.error)</span><br></pre></td></tr></table></figure>

<p>打印 error，不会再打印 haha。</p>
<ol>
<li>没有错误则执行 doResolve，有错误则执行 doReject。</li>
</ol>
<h2 id="3-1-5-doResolve-和-doReject"><a href="#3-1-5-doResolve-和-doReject" class="headerlink" title="3.1.5 doResolve 和 doReject"></a>3.1.5 doResolve 和 doReject</h2><p>doResolve 和 doReject 相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function doResolve (self, value) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const then = getThen(value)</span><br><span class="line">    if (then) &#123;</span><br><span class="line">      safelyResolveThen(self, then)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      self.state = FULFILLED</span><br><span class="line">      self.value = value</span><br><span class="line">      self.queue.forEach(function (queueItem) &#123;</span><br><span class="line">        queueItem.callFulfilled(value)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return self</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    return doReject(self, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doReject (self, error) &#123;</span><br><span class="line">  self.state = REJECTED</span><br><span class="line">  self.value = error</span><br><span class="line">  self.queue.forEach(function (queueItem) &#123;</span><br><span class="line">    queueItem.callRejected(error)</span><br><span class="line">  &#125;)</span><br><span class="line">  return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doReject 用来设置 promise 的 state 为 REJECTED，value 为 error，然后遍历 queue，设置所有子 promise 的状态为 REJECTED 和值为 error。doResolve 结合 safelyResolveThen 使用不断地解包 promise，直至返回值是非 promise 对象后，设置 promise 的状态和值，然后设置子 promise 的状态和值。</p>
<p>这里有个辅助函数 getThen：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getThen (promise) &#123;</span><br><span class="line">  const then = promise &amp;&amp; promise.then</span><br><span class="line">  if (promise &amp;&amp; (isObject(promise) || isFunction(promise)) &amp;&amp; isFunction(then)) &#123;</span><br><span class="line">    return function applyThen () &#123;</span><br><span class="line">      then.apply(promise, arguments)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getThen 实现了规范中规定的：<strong>如果 then 是函数，将 x（即被调用的 promise） 作为函数的 this 调用。</strong></p>
<h2 id="3-1-6-Promise-prototype-then-和-Promise-prototype-catch"><a href="#3-1-6-Promise-prototype-then-和-Promise-prototype-catch" class="headerlink" title="3.1.6 Promise.prototype.then 和 Promise.prototype.catch"></a>3.1.6 Promise.prototype.then 和 Promise.prototype.catch</h2><p>接下来实现 Promise.prototype.then 和 Promise.prototype.catch，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.then = function (onFulfilled, onRejected) &#123;</span><br><span class="line">  if ((!isFunction(onFulfilled) &amp;&amp; this.state === FULFILLED) ||</span><br><span class="line">    (!isFunction(onRejected) &amp;&amp; this.state === REJECTED)) &#123;</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">  const promise = new this.constructor(INTERNAL)</span><br><span class="line">  if (this.state !== PENDING) &#123;</span><br><span class="line">    const resolver = this.state === FULFILLED ? onFulfilled : onRejected</span><br><span class="line">    unwrap(promise, resolver, this.value)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.queue.push(new QueueItem(promise, onFulfilled, onRejected))</span><br><span class="line">  &#125;</span><br><span class="line">  return promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.catch = function (onRejected) &#123;</span><br><span class="line">  return this.then(null, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的 <code>return this</code> 实现了值穿透，后面会细讲。可以看出，then 方法中生成了一个新的 promise 然后返回。如果 promise 的状态改变了，则调用 unwrap，否则将生成的 promise 加入到当前 promise 的回调队列 queue 里，之前已经讲解了如何消费 queue。有 3 点需要讲解：</p>
<ol>
<li>Promise 构造函数传入了一个 INTERNAL 空函数，因为这个新产生的 promise 可以认为是内部的 promise，需要根据外部的 promise 的状态和值产生自身的状态和值，不需要传入回调函数，而外部 Promise 需要传入回调函数决定它的状态和值，所以之前 Promise 的构造函数里做了判断区分外部调用还是内部调用：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (resolver !== INTERNAL) &#123;</span><br><span class="line">  safelyResolveThen(this, resolver)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>QueueItem 代码如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function QueueItem (promise, onFulfilled, onRejected) &#123;</span><br><span class="line">  this.promise = promise</span><br><span class="line">  this.callFulfilled = function (value) &#123;</span><br><span class="line">    doResolve(this.promise, value)</span><br><span class="line">  &#125;</span><br><span class="line">  this.callRejected = function (error) &#123;</span><br><span class="line">    doReject(this.promise, error)</span><br><span class="line">  &#125;</span><br><span class="line">  if (isFunction(onFulfilled)) &#123;</span><br><span class="line">    this.callFulfilled = function (value) &#123;</span><br><span class="line">      unwrap(this.promise, onFulfilled, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (isFunction(onRejected)) &#123;</span><br><span class="line">    this.callRejected = function (error) &#123;</span><br><span class="line">      unwrap(this.promise, onRejected, error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>promise 为 then 生成的新 promise，onFulfilled 和 onRejected 即是 then 参数中的 onFulfilled 和 onRejected。从上面代码可以看出：当 promise 状态变为 FULFILLED 时，之前注册的 then 函数通过 callFulfilled 调用 unwrap 进行解包最终得出 promise 的状态和值；之前注册的 catch 函数，用 callRejected 直接调用 doReject，设置队列里 promise 的状态和值。当 promise 状态变为 REJECTED 类似。</p>
<ol>
<li>unwrap 代码如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unwrap (promise, func, value) &#123;</span><br><span class="line">  process.nextTick(function () &#123;</span><br><span class="line">    let returnValue</span><br><span class="line">    try &#123;</span><br><span class="line">      returnValue = func(value)</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      return doReject(promise, error)</span><br><span class="line">    &#125;</span><br><span class="line">    if (returnValue === promise) &#123;</span><br><span class="line">      doReject(promise, new TypeError(&#x27;Cannot resolve promise with itself&#x27;))</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      doResolve(promise, returnValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unwrap 函数从名字也可以看出是用来解包的，即拿到父 promise 的结果设置当前 promise 的状态和值。第一个参数是 promise，第二个参数是父 promise 的 then 的回调（onFulfilled&#x2F;onRejected），第三个参数是父 promise 的值（正常值&#x2F;错误）。有 3 点需要说明：</p>
<ol>
<li>使用 process.nextTick 将代码异步执行，这也是规范里明确规定的。看一段代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Promise = require(&#x27;appoint&#x27;)</span><br><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;haha&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">  promise.then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;1&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(&#x27;2&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打印 2 1，去掉 process.nextTick 则打印 1 2。</p>
<ol>
<li>try…catch 用来捕获 then&#x2F;catch 函数内抛出的异常，并调用 doReject，如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;haha&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(() =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;haha&#x27;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>返回的值不能是 promise 本身，否则会造成死循环，如下代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;haha&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">const a = promise.then(() =&gt; &#123;</span><br><span class="line">  return a</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">a.catch(console.log)// [TypeError: Chaining cycle detected for promise #&lt;Promise&gt;]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：promise.catch(onRejected) 就是 promise.then(null, onRejected) 的语法糖。</p>
<p>至此，Promise 的核心部分就实现完了。</p>
<h2 id="3-1-7-值穿透"><a href="#3-1-7-值穿透" class="headerlink" title="3.1.7 值穿透"></a>3.1.7 值穿透</h2><p>上面提到过好几次值穿透，什么是值穿透呢？上面的 Promise.prototype.then 的实现中有这么一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.then = function (onFulfilled, onRejected) &#123;</span><br><span class="line">  if ((!isFunction(onFulfilled) &amp;&amp; this.state === FULFILLED) ||</span><br><span class="line">    (!isFunction(onRejected) &amp;&amp; this.state === REJECTED)) &#123;</span><br><span class="line">    return this</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>值穿透即传入 then&#x2F;catch 的参数如果不为函数，则忽略该值，返回上一个 promise 的结果。看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;haha&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">  .then(&#x27;hehe&#x27;)</span><br><span class="line">  .then(console.log)</span><br></pre></td></tr></table></figure>

<p>最终打印 haha 而不是 hehe。</p>
<p>通过 <code>return this</code> 只实现了值穿透的一种情况，其实值穿透有两种情况：</p>
<ol>
<li>promise 已经是 FULFILLED&#x2F;REJECTED 时，通过 <code>return this</code> 实现的值穿透：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const Promise = require(&#x27;appoint&#x27;)</span><br><span class="line">const promise = new Promise(function (resolve) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;haha&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">  promise.then().then((res) =&gt; &#123;// (1)</span><br><span class="line">    console.log(res)// haha</span><br><span class="line">  &#125;)</span><br><span class="line">  promise.catch().then((res) =&gt; &#123;// (2)</span><br><span class="line">    console.log(res)// haha</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(promise.then() === promise.catch())// true</span><br><span class="line">  console.log(promise.then(1) === promise.catch(&#123; name: &#x27;nswbmw&#x27; &#125;))// true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码 (1)、(2) 处 promise 已经是 FULFILLED 了符合条件所以执行了 <code>return this</code>。</p>
<ol>
<li>promise 是 PENDING 时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 状态改变时调用 callFulfilled-&gt;doResolve 或 callRejected-&gt;doReject（因为 then&#x2F;catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态和值。看一段代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const Promise = require(&#x27;appoint&#x27;)</span><br><span class="line">const promise = new Promise((resolve) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;haha&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">const a = promise.then()</span><br><span class="line">a.then((res) =&gt; &#123;</span><br><span class="line">  console.log(res)// haha</span><br><span class="line">&#125;)</span><br><span class="line">const b = promise.catch()</span><br><span class="line">b.then((res) =&gt; &#123;</span><br><span class="line">  console.log(res)// haha</span><br><span class="line">&#125;)</span><br><span class="line">console.log(a === b)// false</span><br></pre></td></tr></table></figure>

<h2 id="3-1-8-Promise-resolve-和-Promise-reject"><a href="#3-1-8-Promise-resolve-和-Promise-reject" class="headerlink" title="3.1.8 Promise.resolve 和 Promise.reject"></a>3.1.8 Promise.resolve 和 Promise.reject</h2><p>Promise.resolve 和 Promise.reject 是 Promise 的两个静态方法，用来快捷的生成一个状态为 fulfilled 或者 rejected 的 promise 实例。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve = resolve</span><br><span class="line">function resolve (value) &#123;</span><br><span class="line">  if (value instanceof this) &#123;</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line">  return doResolve(new this(INTERNAL), value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.reject = reject</span><br><span class="line">function reject (reason) &#123;</span><br><span class="line">  return doReject(new this(INTERNAL), reason)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Promise.resolve 参数是一个 promise 时，直接返回该值。</p>
<h2 id="3-1-9-Promise-all"><a href="#3-1-9-Promise-all" class="headerlink" title="3.1.9 Promise.all"></a>3.1.9 Promise.all</h2><p>Promise.all 接收一个数组，用来并行执行一组 promise。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Promise.all = all</span><br><span class="line">function all (iterable) &#123;</span><br><span class="line">  const self = this</span><br><span class="line">  if (!isArray(iterable)) &#123;</span><br><span class="line">    return this.reject(new TypeError(&#x27;must be an array&#x27;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const len = iterable.length</span><br><span class="line">  let called = false</span><br><span class="line">  if (!len) &#123;</span><br><span class="line">    return this.resolve([])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const values = new Array(len)</span><br><span class="line">  let resolved = 0</span><br><span class="line">  let i = -1</span><br><span class="line">  const promise = new this(INTERNAL)</span><br><span class="line"></span><br><span class="line">  while (++i &lt; len) &#123;</span><br><span class="line">    allResolver(iterable[i], i)</span><br><span class="line">  &#125;</span><br><span class="line">  return promise</span><br><span class="line">  function allResolver (value, i) &#123;</span><br><span class="line">    self.resolve(value).then(resolveFromAll, function (error) &#123;</span><br><span class="line">      if (!called) &#123;</span><br><span class="line">        called = true</span><br><span class="line">        doReject(promise, error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    function resolveFromAll (outValue) &#123;</span><br><span class="line">      values[i] = outValue</span><br><span class="line">      if (++resolved === len &amp;&amp; !called) &#123;</span><br><span class="line">        called = true</span><br><span class="line">        doResolve(promise, values)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Promise.all 用来并行执行多个 promise&#x2F;值，当所有 promise&#x2F;值执行完毕或有一个 promise 状态变为 rejected 时返回。以上代码可以看出：</p>
<ol>
<li>Promise.all 内部生成了一个新的 promise 返回。</li>
<li>called 用来控制即使有多个 promise rejected 也只有第一个生效。</li>
<li>values 用来存储执行结果。</li>
<li>当最后一个 promise 状态改变后，使用 doResolve(promise, values) 设置 promise 的 state 为 FULFILLED，value 为结果数组 values。</li>
</ol>
<h2 id="3-1-10-Promise-race"><a href="#3-1-10-Promise-race" class="headerlink" title="3.1.10 Promise.race"></a>3.1.10 Promise.race</h2><p>Promise.race 接收一个数组，当数组中有一个 promise 状态发生改变（ pending -&gt; fulfilled&#x2F;rejected）时返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Promise.race = race</span><br><span class="line">function race (iterable) &#123;</span><br><span class="line">  const self = this</span><br><span class="line">  if (!isArray(iterable)) &#123;</span><br><span class="line">    return this.reject(new TypeError(&#x27;must be an array&#x27;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const len = iterable.length</span><br><span class="line">  let called = false</span><br><span class="line">  if (!len) &#123;</span><br><span class="line">    return this.resolve([])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let i = -1</span><br><span class="line">  const promise = new this(INTERNAL)</span><br><span class="line"></span><br><span class="line">  while (++i &lt; len) &#123;</span><br><span class="line">    resolver(iterable[i])</span><br><span class="line">  &#125;</span><br><span class="line">  return promise</span><br><span class="line">  function resolver (value) &#123;</span><br><span class="line">    self.resolve(value).then(function (response) &#123;</span><br><span class="line">      if (!called) &#123;</span><br><span class="line">        called = true</span><br><span class="line">        doResolve(promise, response)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, function (error) &#123;</span><br><span class="line">      if (!called) &#123;</span><br><span class="line">        called = true</span><br><span class="line">        doReject(promise, error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Promise.race 与 Promise.all 代码相近，只不过这里用 called 控制只要有任何一个 promise 状态改变则立即去设置返回的 promise 的状态和值。</p>
<p>至此，Promise 的实现全部讲解完毕。</p>
<h2 id="3-1-11-十道题"><a href="#3-1-11-十道题" class="headerlink" title="3.1.11 十道题"></a>3.1.11 十道题</h2><p>现在，我们以十道题巩固一下前面所学到的 Promise 的知识点。</p>
<h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  resolve()</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">  console.log(3)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(4)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。</p>
<h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const promise1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;success&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">const promise2 = promise1.then(() =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;error!!!&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&#x27;promise1&#x27;, promise1)</span><br><span class="line">console.log(&#x27;promise2&#x27;, promise2)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;, promise1)</span><br><span class="line">  console.log(&#x27;promise2&#x27;, promise2)</span><br><span class="line">&#125;, 2000)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">promise1 Promise &#123; &lt;pending&gt; &#125;</span><br><span class="line">promise2 Promise &#123; &lt;pending&gt; &#125;</span><br><span class="line">(node:50928) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: error!!!</span><br><span class="line">(node:50928) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br><span class="line">promise1 Promise &#123; &#x27;success&#x27; &#125;</span><br><span class="line">promise2 Promise &#123;</span><br><span class="line">  &lt;rejected&gt; Error: error!!!</span><br><span class="line">    at promise.then (...)</span><br><span class="line">    at &lt;anonymous&gt; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：promise 有 3 种状态：pending、fulfilled 或 rejected。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。上面的 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。</p>
<h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&#x27;success1&#x27;)</span><br><span class="line">  reject(&#x27;error&#x27;)</span><br><span class="line">  resolve(&#x27;success2&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;then: &#x27;, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;catch: &#x27;, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">then: success1</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：构造函数中的 resolve 或 reject 只有在第 1 次执行时有效，多次调用没有任何作用，再次印证代码二的结论：promise 状态一旦改变则不能再变。</p>
<p>再看两个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  return Promise.reject(new Error(&#x27;haha&#x27;))</span><br><span class="line">&#125;)</span><br><span class="line">promise.then((res) =&gt; &#123;</span><br><span class="line">  console.log(2, res)</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">  console.error(3, err)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(4)</span><br><span class="line">console.log(promise)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">Promise &#123; &lt;pending&gt; &#125;</span><br><span class="line">(node:22493) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: haha</span><br><span class="line">(node:22493) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  throw new Error(&#x27;haha&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then((res) =&gt; &#123;</span><br><span class="line">  console.log(2, res)</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">  console.error(3, err)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(4)</span><br><span class="line">console.log(promise)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">Promise &#123;</span><br><span class="line">  &lt;rejected&gt; Error: haha</span><br><span class="line">    at Promise (/Users/nswbmw/Desktop/test/app.js:6:9)</span><br><span class="line">    ...</span><br><span class="line">3 Error: haha</span><br><span class="line">    at Promise (/Users/nswbmw/Desktop/test/app.js:6:9)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：构造函数内只能通过调用 resolve(pending-&gt;fullfiled) 或者 reject(pending-&gt;rejected) 或者 throw 一个 error(pending-&gt;rejected) 改变状态。所以第一个例子的 promise 状态是 pending，也就不会调用 .then&#x2F;.catch。</p>
<h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">    return 2</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((err) =&gt; &#123;</span><br><span class="line">    return 3</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 在每次调用 .then 或者 .catch 时都会返回一个新的 promise，从而可以实现链式调用。</p>
<h3 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;once&#x27;)</span><br><span class="line">    resolve(&#x27;success&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const start = Date.now()</span><br><span class="line">promise.then((res) =&gt; &#123;</span><br><span class="line">  console.log(res, Date.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then((res) =&gt; &#123;</span><br><span class="line">  console.log(res, Date.now() - start)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">once</span><br><span class="line">success 1005</span><br><span class="line">success 1007</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说，promise 内部状态一经改变，并且有了一个值，则后续在每次调用 .then 或者 .catch 时都会直接拿到该值。</p>
<h3 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    return new Error(&#x27;error!!!&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;then: &#x27;, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;catch: &#x27;, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">then: Error: error!!!</span><br><span class="line">    at Promise.resolve.then (...)</span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成如下其中一种：</p>
<ol>
<li>return Promise.reject(new Error(‘error!!!’))</li>
<li>throw new Error(‘error!!!’)</li>
</ol>
<p>因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 <code>return new Error(&#39;error!!!&#39;)</code> 等价于 <code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>。</p>
<h3 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const promise = Promise.resolve()</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    return promise</span><br><span class="line">  &#125;)</span><br><span class="line">promise.catch(console.error)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:188:7)</span><br><span class="line">    at Function.Module.runMain (module.js:667:11)</span><br><span class="line">    at startup (bootstrap_node.js:187:16)</span><br><span class="line">    at bootstrap_node.js:607:3</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(function tick () &#123;</span><br><span class="line">  console.log(&#x27;tick&#x27;)</span><br><span class="line">  process.nextTick(tick)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(2)</span><br><span class="line">  .then(Promise.resolve(3))</span><br><span class="line">  .then(console.log)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。</p>
<h3 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">  .then(function success (res) &#123;</span><br><span class="line">    throw new Error(&#x27;error&#x27;)</span><br><span class="line">  &#125;, function fail1 (e) &#123;</span><br><span class="line">    console.error(&#x27;fail1: &#x27;, e)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function fail2 (e) &#123;</span><br><span class="line">    console.error(&#x27;fail2: &#x27;, e)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fail2: Error: error</span><br><span class="line">    at success (...)</span><br><span class="line">    at ...</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：.then 可以接收两个参数，第 1 个是处理成功的函数，第 2 个是处理错误的函数。.catch 是 .then 第 2 个参数的简便写法，但是在用法上有一点需要注意：.then 的第 2 个处理错误的函数（fail1）捕获不了第 1 个处理成功的函数（success）抛出的错误，而后续的 .catch 方法（fail2）可以捕获之前的错误。当然，以下代码也可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">  .then(function success1 (res) &#123;</span><br><span class="line">    throw new Error(&#x27;error&#x27;)</span><br><span class="line">  &#125;, function fail1 (e) &#123;</span><br><span class="line">    console.error(&#x27;fail1: &#x27;, e)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function success2 (res) &#123;</span><br><span class="line">  &#125;, function fail2 (e) &#123;</span><br><span class="line">    console.error(&#x27;fail2: &#x27;, e)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">  .then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;then&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;nextTick&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;setImmediate&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;end&#x27;)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">end</span><br><span class="line">nextTick</span><br><span class="line">then</span><br><span class="line">setImmediate</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：process.nextTick 和 promise.then 都属于 microtask（但 process.nextTick 的优先级大于 promise.then），而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，以上代码本身（macrotask）在执行完后会执行一次 microtask。</p>
<h2 id="3-1-12-参考链接"><a href="#3-1-12-参考链接" class="headerlink" title="3.1.12 参考链接"></a>3.1.12 参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise">http://es6.ruanyifeng.com/#docs/promise</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></li>
<li><a target="_blank" rel="noopener" href="https://promisesaplus.com/">https://promisesaplus.com/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://marvinliu1.github.io/2019/04/18/2.4.1%20%E4%BD%BF%E7%94%A8%20cpu-memory-monitor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Marvin Liu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Marvin's Blog">
      <meta itemprop="description" content="Take in the good!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Marvin's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/18/2.4.1%20%E4%BD%BF%E7%94%A8%20cpu-memory-monitor/" class="post-title-link" itemprop="url">Node in Debugging, 2.4 Cpu-memory monitor</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-04-18 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-18T00:00:00-06:00">2019-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Node-in-Debugging/" itemprop="url" rel="index"><span itemprop="name">Node in Debugging</span></a>
        </span>
    </span>

  
    <span id="/2019/04/18/2.4.1%20%E4%BD%BF%E7%94%A8%20cpu-memory-monitor/" class="post-meta-item leancloud_visitors" data-flag-title="Node in Debugging, 2.4 Cpu-memory monitor" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://github.com/nswbmw/node-in-debugging">Node in Debugging</a></p>
<p>前面介绍了 heapdump 和 memwatch-next 的用法，但在实际使用时并不那么方便，我们总不能一直盯着服务器的状况，在发现内存持续增长并超过心里的阈值时，再手动去触发 Core Dump 吧？在大多数情况下发现问题时，就已经错过了现场。所以，我们可能需要 <a target="_blank" rel="noopener" href="https://github.com/nswbmw/cpu-memory-monitor">cpu-memory-monitor</a>。顾名思义，这个模块可以用来监控 CPU 和 Memory 的使用情况，并可以根据配置策略自动 dump CPU 的使用情况（cpuprofile）和内存快照（heapsnapshot）。</p>
<h2 id="2-4-1-使用-cpu-memory-monitor"><a href="#2-4-1-使用-cpu-memory-monitor" class="headerlink" title="2.4.1 使用 cpu-memory-monitor"></a>2.4.1 使用 cpu-memory-monitor</h2><p>我们先来看看如何使用 cpu-memory-monitor，其实很简单，只需在进程启动的入口文件中引入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">require(&#x27;cpu-memory-monitor&#x27;)(&#123;</span><br><span class="line">  cpu: &#123;</span><br><span class="line">    interval: 1000,</span><br><span class="line">    duration: 30000,</span><br><span class="line">    threshold: 60,</span><br><span class="line">    profileDir: &#x27;/tmp&#x27;,</span><br><span class="line">    counter: 3,</span><br><span class="line">    limiter: [5, &#x27;hour&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>上述代码的作用是</strong>：每 <strong>1000ms</strong>(interval)检查一次 CPU 的使用情况，如果发现连续 <strong>3</strong>(counter)次 CPU 使用率大于 <strong>60%</strong>(threshold)，则 dump <strong>30000ms</strong>(duration) CPU 的使用情况，生成 <code>cpu-$&#123;process.pid&#125;-$&#123;Date.now()&#125;.cpuprofile</code> 到 <strong>&#x2F;tmp</strong>(profileDir) 目录下，<strong>1</strong>(limiter[1]) 小时最多 dump <strong>5</strong>(limiter[0]) 次。</p>
<p>以上是自动 dump CPU 使用情况的策略。dump Memory 使用情况的策略同理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require(&#x27;cpu-memory-monitor&#x27;)(&#123;</span><br><span class="line">  memory: &#123;</span><br><span class="line">    interval: 1000,</span><br><span class="line">    threshold: &#x27;1.2gb&#x27;,</span><br><span class="line">    profileDir: &#x27;/tmp&#x27;,</span><br><span class="line">    counter: 3,</span><br><span class="line">    limiter: [3, &#x27;hour&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>上述代码的作用是</strong>：每 <strong>1000ms</strong>(interval) 检查一次 Memory 的使用情况，如果发现连续 <strong>3</strong>(counter) 次 Memory 大于 <strong>1.2gb</strong>(threshold)，则 dump 一次 Memory，生成 <code>memory-$&#123;process.pid&#125;-$&#123;Date.now()&#125;.heapsnapshot</code> 到 <strong>&#x2F;tmp</strong>(profileDir) 目录下，<strong>1</strong>(limiter[1]) 小时最多 dump <strong>3</strong>(limiter[0]) 次。</p>
<p><strong>注意</strong>：memory 的配置没有 duration 参数，因为 Memroy 的 dump 只是某一时刻的，而不是一段时间的。</p>
<p>聪明的你肯定会问了：能不能将 cpu 和 memory 配置一块使用？比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">require(&#x27;cpu-memory-monitor&#x27;)(&#123;</span><br><span class="line">  cpu: &#123;</span><br><span class="line">    interval: 1000,</span><br><span class="line">    duration: 30000,</span><br><span class="line">    threshold: 60,</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  memory: &#123;</span><br><span class="line">    interval: 10000,</span><br><span class="line">    threshold: &#x27;1.2gb&#x27;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>答案是：可以，但不要这么做。因为这样做可能会出现这种情况：内存高了且达到设定的阈值 -&gt; 触发 Memory Dump&#x2F;GC -&gt; 导致 CPU 使用率高且达到设定的阈值 -&gt; 触发 CPU Dump -&gt; 导致堆积的请求越来越多（比如内存中堆积了很多 SQL 查询）-&gt; 触发 Memory Dump -&gt; 导致雪崩。</p>
<p>通常情况下，只使用其中一种就可以了。</p>
<h2 id="2-4-2-源码解读"><a href="#2-4-2-源码解读" class="headerlink" title="2.4.2 源码解读"></a>2.4.2 源码解读</h2><p>cpu-memory-monitor 的源代码不过百余行，大体逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">const processing = &#123;</span><br><span class="line">  cpu: false,</span><br><span class="line">  memory: false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const counter = &#123;</span><br><span class="line">  cpu: 0,</span><br><span class="line">  memory: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dumpCpu(cpuProfileDir, cpuDuration) &#123; ... &#125;</span><br><span class="line">function dumpMemory(memProfileDir) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">module.exports = function cpuMemoryMonitor(options = &#123;&#125;) &#123;</span><br><span class="line">  ...</span><br><span class="line">  if (options.cpu) &#123;</span><br><span class="line">    const cpuTimer = setInterval(() =&gt; &#123;</span><br><span class="line">      if (processing.cpu) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      pusage.stat(process.pid, (err, stat) =&gt; &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">          clearInterval(cpuTimer)</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        if (stat.cpu &gt; cpuThreshold) &#123;</span><br><span class="line">          counter.cpu += 1</span><br><span class="line">          if (counter.cpu &gt;= cpuCounter) &#123;</span><br><span class="line">            memLimiter.removeTokens(1, (limiterErr, remaining) =&gt; &#123;</span><br><span class="line">              if (limiterErr) &#123;</span><br><span class="line">                return</span><br><span class="line">              &#125;</span><br><span class="line">              if (remaining &gt; -1) &#123;</span><br><span class="line">                dumpCpu(cpuProfileDir, cpuDuration)</span><br><span class="line">                counter.cpu = 0</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            counter.cpu = 0</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, cpuInterval)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (options.memory) &#123;</span><br><span class="line">    ...</span><br><span class="line">    memwatch.on(&#x27;leak&#x27;, () =&gt; &#123;</span><br><span class="line">      dumpMemory(...)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看出</strong>：cpu-memory-monitor 没有用到什么新鲜的东西，还是之前讲解过的 v8-profiler、heapdump、memwatch-next 的组合使用而已。</p>
<p>有以下几点需要注意：</p>
<ol>
<li>只有传入了 cpu 或者 memory 的配置，才会去监听相应的 CPU 或者 Memory。</li>
<li>在传入 memory 配置时，因为用 memwatch-next 额外监听了 leak 事件，也会 dump Memory，格式是 <code>leak-memory-$&#123;process.pid&#125;-$&#123;Date.now()&#125;.heapsnapshot</code>。</li>
<li>顶部引入了 heapdump，所以即使没有 memory 配置，也可以通过 <code>kill -USR2 &lt;PID&gt;</code> 手动触发 Memory Dump。</li>
</ol>
<h2 id="2-4-3-参考链接"><a href="#2-4-3-参考链接" class="headerlink" title="2.4.3 参考链接"></a>2.4.3 参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/node-inspector/v8-profiler">https://github.com/node-inspector/v8-profiler</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/bnoordhuis/node-heapdump">https://github.com/bnoordhuis/node-heapdump</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/marcominetti/node-memwatch">https://github.com/marcominetti/node-memwatch</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018  
  <!-- <span itemprop="copyrightYear">2022</span> -->
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Marvin Liu</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"appid":"qAsjmBkdw5m0pBHIrH2owQQT-MdYXbMMI","appkey":"xmNL8CNHrbd2QvJOzWwbj3ny","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>



</body>
</html>
