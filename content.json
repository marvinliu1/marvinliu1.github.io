{"meta":{"title":"Marvin's Blog","subtitle":"","description":"Take in the good!","author":"Marvin Liu","url":"https://marvinliu1.github.io","root":"/"},"pages":[{"title":"","date":"2020-10-21T08:57:00.000Z","updated":"2022-05-21T10:04:11.949Z","comments":true,"path":"about/index.html","permalink":"https://marvinliu1.github.io/about/index.html","excerpt":"","text":"About me . . . A passionate coder Fantastic troubleshooter And enthusiastic software developer $(\"#code\").typewriter();"},{"title":"categories","date":"2022-05-21T07:31:25.000Z","updated":"2022-05-21T07:31:40.888Z","comments":true,"path":"categories/index.html","permalink":"https://marvinliu1.github.io/categories/index.html","excerpt":"","text":""},{"title":"Favorite Links","date":"2022-05-24T22:20:17.136Z","updated":"2022-05-24T22:20:17.136Z","comments":true,"path":"links/index.html","permalink":"https://marvinliu1.github.io/links/index.html","excerpt":"","text":"NodeJS Usefull Links Nuxt authentication A very good auth implementation by Chimezie Enyinnaya Official Tutorials about NodeJS & Vue & Nuxt Vue Tutorial Vue's tutorial from vuejs.org MDN - Getting started with Vue MDN's fine introduction about vue NuxtJS - Tutorials Discover tutorials made by the Nuxt community."},{"title":"tags","date":"2022-05-21T07:32:07.000Z","updated":"2022-05-21T07:32:16.953Z","comments":true,"path":"tags/index.html","permalink":"https://marvinliu1.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo - How to add external links","slug":"Adding links into Hexo NexT8 ","date":"2021-05-22T18:11:00.000Z","updated":"2022-05-25T15:23:53.533Z","comments":true,"path":"2021/05/22/Adding links into Hexo NexT8 /","link":"","permalink":"https://marvinliu1.github.io/2021/05/22/Adding%20links%20into%20Hexo%20NexT8%20/","excerpt":"","text":"本文转载自Cu Blog NexT 主题自带的并没有友链页面，本着 “可以不用但必须有” 的思想，我通过搜索引擎找到了可行的解决方案，在此记录，希望能帮到其他人。 NexT 版本：8.10.1。 先看一下最终效果吧： NexT 配置文件修改打开_config.next.yml 文件，搜索_data，能够找到这样一条被注释的语句：style: source/_data/styles.styl，取消注释即可。 然后在 source 文件夹下新建_data 目录，并创建文件 styles.styl，在里面写入以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#links &#123; margin-top: 5rem;&#125;.links-content &#123; margin-top:1rem;&#125;.link-navigation::after &#123; content: &quot; &quot;; display: block; clear: both;&#125;.card &#123; width: 300px; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex;&#125;.card:nth-child(odd) &#123; float: left;&#125;.card:nth-child(even) &#123; float: right;&#125;.card:hover &#123; transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);&#125;.card a &#123; border:none;&#125;.card .ava &#123; width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px;&#125;.card .card-header &#123; font-style: italic; overflow: hidden; width: 236px;&#125;.card .card-header a &#123; font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none;&#125;.card .card-header a:hover &#123; color: #d480aa; text-decoration: none;&#125;.card .card-header .info &#123; font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;&#125; 然后修改主页面板： 1友链: /links || fas fa-link 创建友链页面使用 hexo new page link 可以新建一个 link 页面，我们将其作为友链页面。创建完成后，写入以下内容（自己使用时请按需修改）： 123456789101112131415161718192021222324252627282930313233343536373839404142---title: 友链type: links---&lt;div class=&quot;links-content&quot;&gt;&lt;div class=&quot;no-icon note warning&quot;&gt;&lt;div class=&quot;link-info&quot;&gt;欢迎与我交换友链！&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;link-navigation&quot;&gt;&#123;% for link in site.data.links %&#125;&lt;div class=&quot;card&quot;&gt;&lt;img class=&quot;ava nomediumzoom&quot; src=&quot;&#123;&#123; link.avatar &#125;&#125;&quot;/&gt;&lt;div class=&quot;card-header&quot;&gt;&lt;div&gt;&lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt; &#123;&#123; link.name &#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;div class=&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endfor %&#125;&lt;/div&gt;------&#123;% note success %&#125;**友链申请条件：**- 网站内容符合中国大陆法律- 已开启HTTPS，且至少有3篇博客，最新一篇为三个月之内发表- 网站内容以原创为主，技术性博客优先，娱乐性博客除非特别感兴趣，否则不会考虑**友链格式：**```yaml- name: Cu Blog site: https://www.litcu.cn info: 安全新人小醋的快乐收集处 avatar: https://img.litcu.cn/avatar/avatar1.jpg```&#123;% endnote %&#125; 核心是 HTML 代码中的那个 for 循环，site.data 就是 source/_data 目录，后面的 links 就是我们之后要创建的 links.yml 友链文件。如果后续没有正常显示友链，可以看看这里是否出现了问题。 添加友链在 source/_data/ 目录下新建 link.yml 文件，写入以下内容： 1234- name: Cu Blog site: https://www.litcu.cn info: 安全新人小醋的快乐收集处 avatar: https://img.litcu.cn/avatar/avatar1.jpg 然后 hexo cl &amp;&amp; hexo g &amp;&amp; hexo s 就可以看到效果啦！","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/tags/Hexo/"}]},{"title":"How To Implement Authentication in a Nuxt.js App","slug":"How-To-Implement-Auth-in-Nuxt","date":"2020-09-25T06:12:31.000Z","updated":"2022-05-24T22:31:18.910Z","comments":true,"path":"2020/09/25/How-To-Implement-Auth-in-Nuxt/","link":"","permalink":"https://marvinliu1.github.io/2020/09/25/How-To-Implement-Auth-in-Nuxt/","excerpt":"","text":"Original published and copy-righted by Chimezie EnyinnayaView more on digitalocean.com IntroductionIn this tutorial, you’ll implement authentication in a Nuxt.js app using the Auth module. For the purpose of this tutorial, you’ll be using JWT for authentication. Below is a quick demo of what you’ll be building in this tutorial: You can find the source code for this application at GitHub. Warning: Several of the packages in this tutorial now contain dependencies with known vulnerabilities. In a production setting, you would resolve these issues by upgrading these packages, finding alternatives, or creating forked versions with patched fixes. However, within the limited context of a tutorial, it provides educational value as-is. PrerequisitesTo complete this tutorial, you will need: Node.js installed locally, which you can do by following How to Install Node.js and Create a Local Development Environment. A valid Git installation is optionally required for cloning the API, consult Getting Started with Git. Some familiarity with Vue.js and Nuxt.js may be beneficial. You can refer to this post if you’re getting started with Nuxt.js. This tutorial was verified with Node v13.13.0, npm v6.14.4, vue v2.6.11, and nuxt v2.12.2. Step 1 — Spinning up a Sample APIYou are free to use whatever framework that works best for you. However, for quick development, this tutorial will clone an API built with AdonisJs. The API utilizes: JWT (JSON Web Tokens) for authentication SQLite CORS enabled The API has three endpoints: /register: endpoint for user registration /login: endpoint for authenticating users /me: endpoint for getting details for the currently authenticated user and it is protected by an auth middleware, which means a user must be authenticated to access the endpoint First, run the following command in your terminal window: 1git clone https://github.com/do-community/jwt-auth-api.git Copy Then, navigate to the project directory: 1cd jwt-auth-api Copy And install the API dependencies: 1npm install Copy Note: When running install, you may encounter issues with sqlite3 version 4.0.1 depending on the version of Node you are running. Refer to the changelog to determine compatibility with your environment. At the time of original publication, the latest version of Node was 10. One option is to downgrade your version of Node to 10.20.1 (with the understanding that it is nearing end-of-life support). Then, run npm install. A second option is to remove the package-lock.json file which will cause the system to look for 4.2.0 which is supported up to Node 13. You may need to also downgrade your version of Node to 13.13.0. Then, run npm install. A third option would be to modify package.json to a version of sqlite3 supported by your current version of Node, remove package-lock.json, and run npm install. However, at the time of testing, 5.0.0 is not yet released to handle Node 14+ support. Other symptoms of incompatibility include the following errors: TypeError: Cannot read property &#39;data&#39; of undefined and Error: Cannot find module &#39;[...]/node_modules/sqlite3/lib/binding/[...]/node_sqlite3.node&#39;. Next, rename .env.example to .env: 1mv .env.example .env Copy And generate an APP_KEY: 1npx @adonisjs/cli@4.0.12 key:generate Copy You should see: 1Outputgenerated: unique APP_KEY Copy Once that’s coomplete, let’s run the migrations: 1npx @adonisjs/cli@4.0.12 migration:run Copy Now, you can start the API: 12# ensure that you are in the `jwt-auth-api` project directorynpm start Copy You can access the API on http://127.0.0.1:3333/api. Leave this running in a terminal window for the rest of the duration of the tutorial. Step 2 — Creating a Nuxt.js AppNow, you can create a Nuxt.js app. Open a new terminal window and use vue-cli to initialize a new Vue project with the Nuxt starter template: 1npx vue-cli@2.9.6 init nuxt/starter nuxt-auth Copy Note: At the time of testing, vue-cli is deprecated. @vue/cli is the current command line tool for Vue projects. And @vue/cli-init is the recommended approach for legacy vue-cli projects. However, create-nuxt-app is the recommended approach for modern Nuxt projects. Next, you need to navigate to the project directory: 1cd nuxt-auth Copy And install the dependencies: 1npm install Then, you can launch the app: 1npm run dev Copy The app should be running on http://localhost:3000. You can view the application in a web browser to see the default Vue application created by vue-cli. Step 3 — Installing Necessary Nuxt.js ModulesNow, let’s install the Nuxt.js modules that you’ll be needing for your app. You’ll be using the Nuxt Auth module and the Nuxt Axios module, since the auth module makes use of Axios internally: 12# ensure that you are in the `nuxt-auth` project directorynpm install @nuxtjs/auth@4.5.1 @nuxtjs/axios@5.3.1 --save Copy Once that’s completed, open nuxt.config.js: 1nano nuxt.config.js Copy Add the code below to nuxt.config.js: nuxt.config.js 12345678module.exports = &#123; // ... modules: [ &#x27;@nuxtjs/axios&#x27;, &#x27;@nuxtjs/auth&#x27; ],&#125; Copy Note: At this point, newer versions of Nuxt may encounter the error: Enable vuex store by creating &#39;store/index.js&#39;. This error can be resolved by adding an empty index.js file to the store directory. Next, you need to set up the modules. Paste the code below into nuxt.config.js: nuxt.config.js 12345678910111213141516171819module.exports = &#123; // ... axios: &#123; baseURL: &#x27;http://127.0.0.1:3333/api&#x27; &#125;, auth: &#123; strategies: &#123; local: &#123; endpoints: &#123; login: &#123; url: &#x27;login&#x27;, method: &#x27;post&#x27;, propertyName: &#x27;data.token&#x27; &#125;, user: &#123; url: &#x27;me&#x27;, method: &#x27;get&#x27;, propertyName: &#x27;data&#x27; &#125;, logout: false &#125; &#125; &#125; &#125;&#125; Copy Here, you set the base URL that Axios will use when making requests. In our case, we are referencing the sample API we set up earlier. Then, you define the authentication endpoints for the local strategy corresponding to those on your API: On successful authentication, the token will be available in the response as a token object inside a data object. Similarly, the response from the /me endpoint will be inside a data object. Lastly, you set logout to false since your API doesn’t have an endpoint for logout. You’ll just remove the token from localStorage when a user logs out. Step 4 — Creating a Navbar ComponentTo style your app, you can make use of Bulma. Open nuxt.config.js and paste the code below within the link object that is inside the head object: nuxt.config.js 1234567891011121314module.exports = &#123; // ... head: &#123; // ... link [ // ... &#123; rel: &#x27;stylesheet&#x27;, href: &#x27;https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css&#x27; &#125; ] &#125;, // ...&#125; Copy Now, let’s create the Navbar component: 1nano components/Navbar.vue Copy And add the following code: components&#x2F;Navbar.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;nav class=&quot;navbar is-light&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-brand&quot;&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/&quot;&gt;Nuxt Auth&lt;/nuxt-link&gt; &lt;button class=&quot;button navbar-burger&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;navbar-menu&quot;&gt; &lt;div class=&quot;navbar-end&quot;&gt; &lt;div class=&quot;navbar-item has-dropdown is-hoverable&quot;&gt; &lt;a class=&quot;navbar-link&quot;&gt; My Account &lt;/a&gt; &lt;div class=&quot;navbar-dropdown&quot;&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/profile&quot;&gt;My Profile&lt;/nuxt-link&gt; &lt;hr class=&quot;navbar-divider&quot;/&gt; &lt;a class=&quot;navbar-item&quot;&gt;Logout&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;template&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/register&quot;&gt;Register&lt;/nuxt-link&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/login&quot;&gt;Log In&lt;/nuxt-link&gt; &lt;/template&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;&lt;/template&gt; Copy The Navbar component contains links to login, register, profile, and logout. Next, let’s update the default layout to make use of the Navbar component. Open default.vue: 1nano layouts/default.vue Copy And replace the content with the following: layouts&#x2F;default.vue 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;Navbar/&gt; &lt;nuxt/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Navbar from &#x27;~/components/Navbar&#x27;export default &#123; components: &#123; Navbar &#125;&#125;&lt;/script&gt; Copy Also, let’s update the homepage. Open index.vue: 1nano pages/index.vue Copy And replace the content with the following: pages&#x2F;index.vue 1234567&lt;template&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;Nuxt Auth&lt;/h1&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt; Copy At this point, you should have an application that displays a title of &quot;Nuxt Auth&quot; with a header bar with navigation links: Step 5 — Handling User RegistrationInside the pages directory, create a new register.vue file: 1nano pages/register.vue Copy And add the following code: pages&#x2F;register.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;template&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column is-4 is-offset-4&quot;&gt; &lt;h2 class=&quot;title has-text-centered&quot;&gt;Register!&lt;/h2&gt; &lt;Notification :message=&quot;error&quot; v-if=&quot;error&quot;/&gt; &lt;form method=&quot;post&quot; @submit.prevent=&quot;register&quot;&gt; &lt;div class=&quot;field&quot;&gt; &lt;label class=&quot;label&quot;&gt;Username&lt;/label&gt; &lt;div class=&quot;control&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;input&quot; name=&quot;username&quot; v-model=&quot;username&quot; required /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;label class=&quot;label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;control&quot;&gt; &lt;input type=&quot;email&quot; class=&quot;input&quot; name=&quot;email&quot; v-model=&quot;email&quot; required /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;label class=&quot;label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;control&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;input&quot; name=&quot;password&quot; v-model=&quot;password&quot; required /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;control&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;button is-dark is-fullwidth&quot;&gt;Register&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;div class=&quot;has-text-centered&quot; style=&quot;margin-top: 20px&quot;&gt; Already got an account? &lt;nuxt-link to=&quot;/login&quot;&gt;Login&lt;/nuxt-link&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;import Notification from &#x27;~/components/Notification&#x27;export default &#123; components: &#123; Notification, &#125;, data() &#123; return &#123; username: &#x27;&#x27;, email: &#x27;&#x27;, password: &#x27;&#x27;, error: null &#125; &#125;, methods: &#123; async register() &#123; try &#123; await this.$axios.post(&#x27;register&#x27;, &#123; username: this.username, email: this.email, password: this.password &#125;) await this.$auth.loginWith(&#x27;local&#x27;, &#123; data: &#123; email: this.email, password: this.password &#125;, &#125;) this.$router.push(&#x27;/&#x27;) &#125; catch (e) &#123; this.error = e.response.data.message &#125; &#125; &#125;&#125;&lt;/script&gt; Copy This contains a form with three fields: username, email, and password. Each field is bound to corresponding data on the component. When the form is submitted, a register method will be called. Using the Axios module, you make a post request to the /register endpoint, passing along the user data. If the registration was successful, you make use of the Auth module’s loginWith(), using the local strategy and passing the user data to log the user in. Then, you redirect the user to the homepage. If there is an error during the registration, you set the error data as the error message gotten from the API response. If there is an error, the error message is displayed by a Notification component. Create a new Notification.vue file inside components: 1nano components/Notifaction.vue Copy And paste the code below in it: components&#x2F;Notification.vue 123456789101112&lt;template&gt; &lt;div class=&quot;notification is-danger&quot;&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Notification&#x27;, props: [&#x27;message&#x27;]&#125;&lt;/script&gt; Copy The Notification component accepts a message props, which is the error message. Now, you can test out user registration: Step 6 — Handling LoggedUsers Logged In and Logged OutUpon successful registration, users should be logged in but there is currently no way for the app to know whether users are logged in or not. So let’s fix that by updating the Navbar component and adding some computed properties. Before you do just that, let’s first activate the Vuex store by creating an index.js file inside the store directory. The Auth module stores user authentication status as well as user details inside Vuex state in an auth object. So you can check if a user is logged in or not with this.$store.state.auth.loggedIn, which will either return true or false. Similarly, you can get a user’s details with this.$store.state.auth.user, which will be null if no user is logged in. Note: You can also access the user authentication status as well as the user details directly with the Auth module using this.$auth.loggedIn and this.$auth.user respectively. Since you might want to use the computed properties in multiple places in your app, let’s create store getters. Open index.js: 1nano store/index.js Copy And paste the code below in it: store&#x2F;index.js 123456789export const getters = &#123; isAuthenticated(state) &#123; return state.auth.loggedIn &#125;, loggedInUser(state) &#123; return state.auth.user &#125;&#125; Copy Here, you create two getters. The first one (isAuthenticated) will return the authentication status of a user and the second (loggedInUser) will return the details or the logged in user. Next, let’s update the Navbar component to make use of the getters. Replace the content of components/Navbar.vue with the following: components&#x2F;Navbar.vue 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;nav class=&quot;navbar is-light&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-brand&quot;&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/&quot;&gt;Nuxt Auth&lt;/nuxt-link&gt; &lt;button class=&quot;button navbar-burger&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;navbar-menu&quot;&gt; &lt;div class=&quot;navbar-end&quot;&gt; &lt;div class=&quot;navbar-item has-dropdown is-hoverable&quot; v-if=&quot;isAuthenticated&quot;&gt; &lt;a class=&quot;navbar-link&quot;&gt; &#123;&#123; loggedInUser.username &#125;&#125; &lt;/a&gt; &lt;div class=&quot;navbar-dropdown&quot;&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/profile&quot;&gt;My Profile&lt;/nuxt-link&gt; &lt;hr class=&quot;navbar-divider&quot;/&gt; &lt;a class=&quot;navbar-item&quot;&gt;Logout&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;template v-else&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/register&quot;&gt;Register&lt;/nuxt-link&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/login&quot;&gt;Log In&lt;/nuxt-link&gt; &lt;/template&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123; computed: &#123; ...mapGetters([&#x27;isAuthenticated&#x27;, &#x27;loggedInUser&#x27;]) &#125;&#125;&lt;/script&gt; Copy You create the computed properties by using the spread operator (...) to extract the getters from mapGetters. Then using isAuthenticated, you display the user menu or links to login or register depending on whether the user is logged in or not. Also, you use loggedInUser to display the authenticated user username. Now, if you give your app a refresh, you should see something similar to below: Step 7 — Handling User Log InNow, let’s allow returning users the ability to log in. Create a new login.vue file inside the pages directory: 1nano pages/login.vue And paste the code below in it: pages&#x2F;login.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;template&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column is-4 is-offset-4&quot;&gt; &lt;h2 class=&quot;title has-text-centered&quot;&gt;Welcome back!&lt;/h2&gt; &lt;Notification :message=&quot;error&quot; v-if=&quot;error&quot;/&gt; &lt;form method=&quot;post&quot; @submit.prevent=&quot;login&quot;&gt; &lt;div class=&quot;field&quot;&gt; &lt;label class=&quot;label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;control&quot;&gt; &lt;input type=&quot;email&quot; class=&quot;input&quot; name=&quot;email&quot; v-model=&quot;email&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;label class=&quot;label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;control&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;input&quot; name=&quot;password&quot; v-model=&quot;password&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;control&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;button is-dark is-fullwidth&quot;&gt;Log In&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;div class=&quot;has-text-centered&quot; style=&quot;margin-top: 20px&quot;&gt; &lt;p&gt; Don&#x27;t have an account? &lt;nuxt-link to=&quot;/register&quot;&gt;Register&lt;/nuxt-link&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;import Notification from &#x27;~/components/Notification&#x27;export default &#123; components: &#123; Notification, &#125;, data() &#123; return &#123; email: &#x27;&#x27;, password: &#x27;&#x27;, error: null &#125; &#125;, methods: &#123; async login() &#123; try &#123; await this.$auth.loginWith(&#x27;local&#x27;, &#123; data: &#123; email: this.email, password: this.password &#125; &#125;) this.$router.push(&#x27;/&#x27;) &#125; catch (e) &#123; this.error = e.response.data.message &#125; &#125; &#125;&#125;&lt;/script&gt; Copy This is quite similar to the register page. The form contains two fields: email and password. When the form is submitted, a login method will be called. Using the Auth module loginWith() and passing along the user data, you log the user in. If the authentication was successful, you redirect the user to the homepage. Otherwise, set error to the error message gotten from the API response. Again, you are using the Notification component from earlier on to display the error message. Step 8 — Displaying the User ProfileLet’s allow logged in users to view their profile. Create a new profile.vue file inside the pages directory: 1nano pages/profile.vue Copy And paste the code below in it: pages&#x2F;profile.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;My Profile&lt;/h2&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt; &lt;strong&gt;Username:&lt;/strong&gt; &#123;&#123; loggedInUser.username &#125;&#125; &lt;/p&gt; &lt;p&gt; &lt;strong&gt;Email:&lt;/strong&gt; &#123;&#123; loggedInUser.email &#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123; computed: &#123; ...mapGetters([&#x27;loggedInUser&#x27;]) &#125;&#125;&lt;/script&gt; Copy Notice how you are using the loggedInUser getter from earlier on to display the user details. Clicking on the My Profile link should result in a My Profile page being displayed. Step 9 — Logging Users OutUpdate the logout link inside the Navbar component. Open Navbar.vue: 1nano components/Navbar.vue Copy Modify the logout link to use @click=&quot;logout&quot;: components&#x2F;Navbar.vue 1234567// ...&lt;div class=&quot;navbar-dropdown&quot;&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/profile&quot;&gt;My Profile&lt;/nuxt-link&gt; &lt;hr class=&quot;navbar-divider&quot;/&gt; &lt;a class=&quot;navbar-item&quot; @click=&quot;logout&quot;&gt;Logout&lt;/a&gt;&lt;/div&gt;// ... Copy When the logout link is clicked, it will trigger a logout method. Next, let’s add the logout method inside the script section of the Navbar component: components&#x2F;Navbar.vue 12345678910// ...export default &#123; // ... methods: &#123; async logout() &#123; await this.$auth.logout(); &#125;, &#125;,&#125; Copy You call the logout() of the Auth module. This will delete the user’s token from localstorage and redirect the user to the homepage. Step 10 — Restricting the Profile PageAs it stands now, anybody can visit the profile page. And if the user is not logged in, it will result in an error. To fix this, you need to restrict the profile page to only logged in users. Luckily for us, you can achieve that with the Auth module. The Auth module comes with an auth middleware, which you can use in this scenario. So let’s add the auth middleware to the profile page. Update the script section as below: pages&#x2F;profile.vue 123456// ...export default &#123; middleware: &#x27;auth&#x27;, // ...&#125; Copy Now when a user that is not logged in tries to visit the profile page, the user will be redirected to the login page. Step 11 — Creating a Guest MiddlewareAgain as it stands, even as a logged in user, you can still access the login and register pages. One way to fix that is to restrict login and register pages to only users that are not logged in. You can do that by creating a guest middleware. Inside the middleware directory, create a new guest.js file: 1nano middleware/guest.js Copy And paste the code below in it: middleware&#x2F;guest.js 12345export default function (&#123; store, redirect &#125;) &#123; if (store.state.auth.loggedIn) &#123; return redirect(&#x27;/&#x27;) &#125;&#125; Copy A middleware accepts the context as its first argument. So you extract store and redirect from the context. Then, you check if the user is logged in then redirect the user to the homepage. Otherwise, you allow the normal execution of the request. Next, let’s make use of this middleware. Update the script section of both login and register as below: pages&#x2F;login.vue and pages&#x2F;register.vue 123456// ...export default &#123; middleware: &#x27;guest&#x27;, // ...&#125; Copy Now, everything will be working as expected. ConclusionIn this tutorial, you looked at how to implement authentication in a Nuxt.js application using the Auth module. You also saw how to keep the authentication flow sleek by making use of middleware. To learn more about the Auth module, check out the docs. If you’d like to learn more about Vue.js, check out our Vue.js topic page for exercises and programming projects.","categories":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://marvinliu1.github.io/categories/Nuxt/"}],"tags":[{"name":"NeXt","slug":"NeXt","permalink":"https://marvinliu1.github.io/tags/NeXt/"},{"name":"Vue","slug":"Vue","permalink":"https://marvinliu1.github.io/tags/Vue/"}]},{"title":"Markdown Handbook","slug":"Markdown公式用法大全","date":"2020-05-21T06:12:31.000Z","updated":"2022-05-25T04:06:46.126Z","comments":true,"path":"2020/05/21/Markdown公式用法大全/","link":"","permalink":"https://marvinliu1.github.io/2020/05/21/Markdown%E5%85%AC%E5%BC%8F%E7%94%A8%E6%B3%95%E5%A4%A7%E5%85%A8/","excerpt":"","text":"基本语法Markdown是一种轻量级标记语言 123456789# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题**加粗***斜体*==高亮== 两种代码引用方式1``式或```式 插入链接并描述1[博客](https://www.cnblogs.com/ &quot;博客&quot;) 插入图片1![路飞](https://pic.baike.soso.com/ugc/baikepic2/0/ori-20190529230042-1249666563_jpeg_640_960_59726.jpg/800 &#x27;路飞&#x27;) 有序列表1231.one2.two3.three 无序列表123* one* two* three 分割线1--- 表格123name | age | sex:-: | :- | -:tony|20|男 name age sex tony 20 男 注：代码中第二行分别表示居中，右对齐，左对齐，若结果不显示，转化成源代码模式去掉行与行之间的空行。 如何插入公式数学公式有两种：行中公式（与文字搭配使用）和独立公式（独立成行） 行内公式表示：$ 数学公式 $ 独立公式表示：$$ 数学公式 $$ 如何输入上下标^ 表示上标, _ 表示下标。如果上下标的内容多于一个字符，需要用 &#123;&#125; 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。 如：$$ x^&#123;y^z&#125;=(1+&#123;\\rm e&#125;^x)^&#123;-2xy^w&#125; $$,显示：$x{yz}&#x3D;(1+{\\rm e}x){-2xy^w} $ 另外，如果要在左右两边都有上下标，可以用 \\sideset 命令。 如：$$ \\sideset&#123;^1_2&#125;&#123;^3_4&#125;\\bigotimes $$,显示：$ \\sideset{1_2}{3_4}\\bigotimes $ 如何输入括号和分隔符()、[] 和 | 表示符号本身，使用 \\&#123;\\&#125; 来表示 &#123;&#125; 。当要显示大号的括号或分隔符时，要用 \\left 和 \\right 命令。 输入 显示 输入 显示 \\langle ⟨⟨ \\rangle ⟩⟩ \\lceil ⌈⌈ \\rceil ⌉⌉ \\lfloor ⌊⌊ \\rfloor ⌋⌋ \\lbrace { { \\rbrace } } 如：$$ f(x,y,z) = 3y^2z \\left( 3+\\frac&#123;7x+5&#125;&#123;1+y^2&#125; \\right) $$,显示：f(x,y,z)&#x3D;3y2z(3+7x+51+y2)f(x,y,z)&#x3D;3y2z(3+7x+51+y2) 有时候要用 \\left. 或 \\right. 进行匹配而不显示本身。 如：$$ \\left. \\frac&#123;&#123;\\rm d&#125;u&#125;&#123;&#123;\\rm d&#125;x&#125; \\right| _&#123;x=0&#125; $$`,显示：[MathProcessingError]dudx∣∣x=0[MathProcessingError]dudx|x=0 ### 如何输入分数 通常使用 `\\frac &#123;分子&#125; &#123;分母&#125;` 命令产生一个分数，分数可嵌套。便捷情况可直接输入 `\\frac ab` 来快速生成一个 abab 。 如果分式很复杂，亦可使用 `分子 \\over 分母` 命令，此时分数仅有一层。 如：`$$ \\frac&#123;a-1&#125;&#123;b-1&#125; \\quad and \\quad &#123;a+1\\over b+1&#125; $$`,显示：a−1b−1anda+1b+1a−1b−1anda+1b+1 ### 如何输入开方 使用 `\\sqrt [根指数，省略时为2] &#123;被开方数&#125;` 命令输入开方。 如：`$$ \\sqrt&#123;2&#125; \\quad and \\quad \\sqrt[n]&#123;3&#125; $$`,显示：2–√and3–√n2and3n ### 如何输入省略号 数学公式中常见的省略号有两种，`\\ldots` 表示与文本底线对齐的省略号，`\\cdots` 表示与文本中线对齐的省略号。 如：`$$ f(x_1,x_2,\\underbrace&#123;\\ldots&#125;_&#123;\\rm ldots&#125; ,x_n) = x_1^2 + x_2^2 + \\underbrace&#123;\\cdots&#125;_&#123;\\rm cdots&#125; + x_n^2 $$`,显示：$ f(x_1,x_2,\\underbrace&#123;\\ldots&#125;*&#123;\\rm ldots&#125; ,x_n) = x_1^2 + x_2^2 + \\underbrace&#123;\\cdots&#125;*&#123;\\rm cdots&#125; + x_n^2 $ ### 如何输入矢量 使用 `\\vec&#123;矢量&#125;` 来自动产生一个矢量。也可以使用 `\\overrightarrow` 等命令自定义字母上方的符号。 如：`$$ \\vec&#123;a&#125; \\cdot \\vec&#123;b&#125;=0 $$`,显示： a⃗ ⋅b⃗ =0a→⋅b→=0 如：`$$ \\overleftarrow&#123;xy&#125; \\quad and \\quad \\overleftrightarrow&#123;xy&#125; \\quad and \\quad \\overrightarrow&#123;xy&#125; $$`,显示： xy←−andxy←→andxy−→xy←andxy↔andxy→ ### 如何输入积分 使用 `\\int_积分下限^积分上限 &#123;被积表达式&#125;` 来输入一个积分。 如：`$$ \\int_0^1 &#123;x^2&#125; \\,&#123;\\rm d&#125;x $$`,显示：∫10x2,dx∫01x2,dx,例中 `\\,` 和 `&#123;\\rm d&#125;` 部分可省略，建议加入，使式子更美观。 ### 如何输入极限运算 使用 `\\lim_&#123;变量 \\to 表达式&#125; 表达式` 来输入一个极限。如有需求，可以更改 `\\to` 符号至任意符号。 如：`$$ \\lim_&#123;n \\to +\\infty&#125; \\frac&#123;1&#125;&#123;n(n+1)&#125; \\quad and \\quad \\lim_&#123;x\\leftarrow&#123;示例&#125;&#125; \\frac&#123;1&#125;&#123;n(n+1)&#125; $$,显示： limn→+∞1n(n+1)andlimx←示例1n(n+1)limn→+∞1n(n+1)andlimx←示例1n(n+1) 如何输入累加、累乘运算使用 \\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125; 来输入一个累加。与之类似，使用 \\prod \\bigcup \\bigcap 来分别输入累乘、并集和交集。此类符号在行内显示时上下标表达式将会移至右上角和右下角。 如：$$ \\sum_&#123;i=1&#125;^n \\frac&#123;1&#125;&#123;i^2&#125; \\quad and \\quad \\prod_&#123;i=1&#125;^n \\frac&#123;1&#125;&#123;i^2&#125; \\quad and \\quad \\bigcup_&#123;i=1&#125;^&#123;2&#125; R $$,显示：∑ni&#x3D;11i2and∏ni&#x3D;11i2and⋃2i&#x3D;1R∑i&#x3D;1n1i2and∏i&#x3D;1n1i2and⋃i&#x3D;12R 如何输入希腊字母输入 \\小写希腊字母英文全称 和 \\首字母大写希腊字母英文全称 来分别输入小写和大写希腊字母,对于大写希腊字母与现有字母相同的，直接输入大写字母即可。 输入 显示 输入 显示 输入 显示 输入 显示 \\alpha αα A AA \\beta ββ B BB \\gamma γγ \\Gamma ΓΓ \\delta δδ \\Delta ΔΔ \\epsilon ϵϵ E EE \\zeta ζζ Z ZZ \\eta ηη H HH \\theta θθ \\Theta ΘΘ \\iota ιι I II \\kappa κκ K KK \\lambda λλ \\Lambda ΛΛ \\mu μμ M MM \\nu νν N NN \\xi ξξ \\Xi ΞΞ o oo O OO \\pi ππ \\Pi ΠΠ \\rho ρρ P PP \\sigma σσ \\Sigma ΣΣ \\tau ττ T TT \\upsilon υυ \\Upsilon ΥΥ \\phi ϕϕ \\Phi ΦΦ \\chi χχ X XX \\psi ψψ \\Psi ΨΨ \\omega ωω \\Omega ΩΩ 部分字母有变量专用形式，以 \\var- 开头。 小写形式 大写形式 变量形式 显示 \\epsilon E \\varepsilon ϵ∣E∣εϵ∣E∣ε \\theta \\Theta \\vartheta θ∣Θ∣ϑθ∣Θ∣ϑ \\rho P \\varrho ρ∣P∣ϱρ∣P∣ϱ \\sigma \\Sigma \\varsigma σ∣Σ∣ςσ∣Σ∣ς \\phi \\Phi \\varphi ϕ∣Φ∣φϕ∣Φ∣φ 如何输入其它特殊字符若需要显示更大或更小的字符，在符号前插入 \\large 或 \\small 命令。若找不到需要的符号，使用 Detexify2Detexify2 来画出想要的符号。 关系运算符 输入 显示 输入 显示 输入 显示 输入 显示 \\pm ±± \\times ×× \\div ÷÷ \\mid ∣∣ \\nmid ∤∤ \\cdot ⋅⋅ \\circ ∘∘ \\ast ∗∗ \\bigodot ⨀⨀ \\bigotimes ⨂⨂ \\bigoplus ⨁⨁ \\leq ≤≤ \\geq ≥≥ \\neq ≠≠ \\approx ≈≈ \\equiv ≡≡ \\sum ∑∑ \\prod ∏∏ \\coprod ∐∐ \\backslash ∖∖ 集合运算符 输入 显示 输入 显示 输入 显示 \\emptyset ∅∅ \\in ∈∈ \\notin ∉∉ \\subset ⊂⊂ \\supset ⊃⊃ \\subseteq ⊆⊆ \\supseteq ⊇⊇ \\bigcap ⋂⋂ \\bigcup ⋃⋃ \\bigvee ⋁⋁ \\bigwedge ⋀⋀ \\biguplus ⨄⨄ 对数运算符 输入 显示 输入 显示 输入 显示 \\log loglog \\lg lglg \\ln lnln 三角运算符 输入 显示 输入 显示 输入 显示 30^\\circ 30∘30∘ \\bot ⊥⊥ \\angle A ∠A∠A \\sin sinsin \\cos coscos \\tan tantan \\csc csccsc \\sec secsec \\cot cotcot 微积分运算符 输入 显示 输入 显示 输入 显示 \\int ∫∫ \\iint ∬∬ \\iiint ∭∭ \\iiiint ∬∬⨌ \\oint ∮∮ \\prime ′′ \\lim limlim \\infty ∞∞ \\nabla ∇∇ 逻辑运算符 输入 显示 输入 显示 输入 显示 \\because ∵∵ \\therefore ∴∴ \\forall ∀∀ \\exists ∃∃ \\not\\subset ⊄⊄ \\not&lt; ≮≮ \\not&gt; ≯≯ \\not&#x3D; ≠≠ 戴帽符号 输入 显示 输入 显示 \\hat{xy} xy^xy^ \\widehat{xyz} xyzˆxyz^ \\tilde{xy} xyxy \\widetilde{xyz} xyz˜xyz~ \\check{x} xˇxˇ \\breve{y} y˘y˘ \\grave{x} xx \\acute{y} y´y´ 连线符号 输入 显示 \\fbox{a+b+c+d} a+b+c+da+b+c+d \\overleftarrow{a+b+c+d} a+b+c+d←−−−a+b+c+d← \\overrightarrow{a+b+c+d} a+b+c+d−→−−a+b+c+d→ \\overleftrightarrow{a+b+c+d} a+b+c+d←→−a+b+c+d↔ \\underleftarrow{a+b+c+d} a+b+c+d←−−−a+b+c+d← \\underrightarrow{a+b+c+d} a+b+c+d−→−−a+b+c+d→ \\underleftrightarrow{a+b+c+d} a+b+c+d←→−a+b+c+d↔ \\overline{a+b+c+d} a+b+c+d¯¯¯¯¯¯¯¯¯¯¯a+b+c+d¯ \\underline{a+b+c+d} a+b+c+d–––––a+b+c+d_ \\overbrace{a+b+c+d}^{Sample} a+b+c+dSamplea+b+c+d⏞Sample \\underbrace{a+b+c+d}_{Sample} a+b+c+dSamplea+b+c+d⏟Sample \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} a+b+c1.0+d2.0a+b+c⏟1.0+d⏞2.0 \\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}} a⋅a⋯ab timesa⋅a⋯a⏟b times 箭头符号 推荐使用符号：|输入|显示|输入|显示|输入|显示||:–😐:–😐:–😐:–😐:–😐:–😐|\\to|$ \\to|↦||↦| \\mapsto||||⟹|||||⟹| \\implies|⟺||⟺| \\iff|⟸||⟸| \\impliedby$| 其它可用符号：|输入|显示|输入|显示||:–😐:–😐:–😐:–😐|\\uparrow|$ \\uparrow|⇑||⇑| \\Uparrow||↓|||↓| \\downarrow|⇓||⇓| \\Downarrow||←|||←| \\leftarrow|⇐||⇐| \\Leftarrow||→|||→| \\rightarrow|⇒||⇒| \\Rightarrow||↔|||↔| \\leftrightarrow|⇔||⇔| \\Leftrightarrow||⟵|||⟵| \\longleftarrow|⟸||⟸| \\Longleftarrow||⟶|||⟶| \\longrightarrow|⟹||⟹| \\Longrightarrow||⟷|||⟷| \\longleftrightarrow|⟺||⟺| \\Longleftrightarrow$| 如何进行字体转换若要对公式的某一部分字符进行字体转换，可以用 &#123;\\字体 &#123;需转换的部分字符&#125;&#125; 命令，其中 \\字体 部分可以参照下表选择合适的字体。一般情况下，公式默认为意大利体 italicitalic 。示例中 全部大写 的字体仅大写可用。 输入 说明 显示 输入 说明 显示 \\rm 罗马体 SampleSample \\cal 花体 SAMPLESAMPLE \\it 意大利体 SampleSample \\Bbb 黑板粗体 SAMPLESAMPLE \\bf 粗体 SampleSample \\mit 数学斜体 SAMPLESAMPLE \\sf 等线体 SampleSample \\scr 手写体 SAMPLESAMPLE \\tt 打字机体 SampleSample \\frak 旧德式字体 SampleSample 转换字体十分常用，例如在积分中： 12345\\begin&#123;array&#125;&#123;cc&#125;\\mathrm&#123;Bad&#125; &amp; \\mathrm&#123;Better&#125; \\\\\\hline \\\\\\int_0^1 x^2 dx &amp; \\int_0^1 x^2 \\,&#123;\\rm d&#125;x\\end&#123;array&#125; 显示：\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\hline \\\\int_0^1 x^2 dx &amp; \\int_0^1 x^2 ,{\\rm d}x\\end{array}\\begin{array}{cc} \\mathrm{Bad} &amp; \\mathrm{Better} \\ \\hline \\ \\int_0^1 x^2 dx &amp; \\int_0^1 x^2 ,{\\rm d}x \\end{array},注意比较两个式子间 dxdx 与 dxdx 的不同。 如何使用大括号和行标使用 \\left 和 \\right 来创建自动匹配高度的 (圆括号)，[方括号] 和 {花括号} ，在每个公式末尾前使用 \\tag&#123;行标&#125; 来实现行标。 例如： 123456789101112131415$$f\\left( \\left[ \\frac&#123; 1+\\left\\&#123;x,y\\right\\&#125; &#125;&#123; \\left( \\frac&#123;x&#125;&#123;y&#125;+\\frac&#123;y&#125;&#123;x&#125; \\right) \\left(u+1\\right) &#125;+a \\right]^&#123;3/2&#125;\\right)\\tag&#123;行标&#125;$$ 显示： f⎛⎝⎜⎜⎡⎣⎢1+{x,y}(xy+yx)(u+1)+a⎤⎦⎥3&#x2F;2⎞⎠⎟⎟(行标)(行标)f([1+{x,y}(xy+yx)(u+1)+a]3&#x2F;2) 如果你需要在不同的行显示对应括号，可以在每一行对应处使用 \\left. 或 \\right. 来放一个”影子”括号： 例如： 123456$$\\begin&#123;aligned&#125;a=&amp;\\left(1+2+3+ \\cdots \\right. \\\\&amp; \\cdots+ \\left. \\infty-2+\\infty-1+\\infty\\right)\\end&#123;aligned&#125;$$ 显示： a&#x3D;(1+2+3+⋯⋯+∞−2+∞−1+∞)a&#x3D;(1+2+3+⋯⋯+∞−2+∞−1+∞) 如果你需要将行内显示的分隔符也变大，可以使用 \\middle 命令： 例如： 123456789$$\\left\\langle q\\middle\\| \\frac&#123;\\frac&#123;x&#125;&#123;y&#125;&#125;&#123;\\frac&#123;u&#125;&#123;v&#125;&#125;\\middle| p \\right\\rangle$$ 显示： ⟨q∥∥∥xyuv∣∣∣p⟩⟨q‖xyuv|p⟩ 其它公式定义新的符号\\operatorname如：$$ \\operatorname&#123;Symbol&#125; A $$，显示： SymbolASymbol⁡A 添加注释文字 \\text在 \\text &#123;文字&#125; 中仍可以使用 $公式$ 插入其它公式。 如：$$ f(n)= \\begin&#123;cases&#125; n/2, &amp; \\text &#123;if $n$ is even&#125; \\\\ 3n+1, &amp; \\text&#123;if $n$ is odd&#125; \\end&#123;cases&#125; $$ 显示：$ f(n)&#x3D; \\begin{cases} n&#x2F;2, &amp; \\text {if nn is even} \\ 3n+1, &amp; \\text{if nn is odd} \\end{cases} $ 在字符间加入空格有四种宽度的空格可以使用： \\,、\\;、\\quad 和 \\qquad 。 如：$$ a \\, b \\mid a \\; b \\mid a \\quad b \\mid a \\qquad b $$,显示：a,b∣a;b∣ab∣aba,b∣a;b∣ab∣ab 当然，使用 \\text &#123;n个空格&#125; 也可以达到同样效果。 更改文字颜色使用 \\color&#123;颜色&#125;&#123;文字&#125; 来更改特定的文字颜色,更改文字颜色 需要浏览器支持，如果浏览器不知道你所需的颜色，那么文字将被渲染为黑色。对于较旧的浏览器（HTML4与CSS2），以下颜色是被支持的： 输入 显示 输入 显示 black texttext grey texttext silver texttext white texttext maroon texttext red texttext yellow texttext lime texttext olive texttext green texttext teal texttext auqa texttext blue texttext navy texttext purple texttext fuchsia texttext 对于较新的浏览器（HTML5与CSS3），额外的124种颜色将被支持：输入 &#96;\\color","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/categories/Hexo/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://marvinliu1.github.io/tags/MarkDown/"},{"name":"Next","slug":"Next","permalink":"https://marvinliu1.github.io/tags/Next/"}]},{"title":"Node in Debugging - 8.2 Alinode","slug":"8.2 alinode","date":"2020-03-08T07:12:31.000Z","updated":"2022-05-25T04:31:30.684Z","comments":true,"path":"2020/03/08/8.2 alinode/","link":"","permalink":"https://marvinliu1.github.io/2020/03/08/8.2%20alinode/","excerpt":"","text":"Node in Debugging 8.2.1 什么是 alinode？ Node.js 性能平台（原 alinode）是面向中大型 Node.js 应用提供性能监控、安全提醒、故障排查、性能优化等服务的整体性解决方案。alinode 团队凭借对 Node.js 内核的深入理解，提供了完善的工具链和服务，协助客户主动、快速地发现和定位线上问题。 8.2.2 创建 alinode 应用访问官网 https://www.aliyun.com/product/nodejs，如未开通，则使用阿里云账号登录并免费开通即可。 登录后进入控制台，单击 “创建新应用”，创建一个名为 test_alinode 的应用。 进入设置页面，如下所示： App ID 和 App Secret 后面会用到。 8.2.3 安装 alinodealinode 的整套服务由 alinode 运行时、agenthub（原 agentx + commdx 命令集）和服务平台组成，所以在自己的服务器上部署时需要安装 alinode 运行时和 agenthub。 我们使用交互式一键安装 alinode 和 agenthub： 123456$ uname -a # 阿里云 ECS Ubuntu@16.04Linux nswbmw 4.4.0-105-generic #128-Ubuntu SMP Thu Dec 14 12:42:11 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux$ wget https://raw.githubusercontent.com/aliyun-node/alinode-all-in-one/master/alinode_all.sh$ bash -i alinode_all.sh # App ID 和 App Secret 填写上面生成的...$ node -p &#x27;process.alinode&#x27; # 查看 alinode 版本 注意：如果遇到 wget 报错 wget: unable to resolve host address &#39;raw.githubusercontent.com&#39;，需要修改 DNS 配置，在 &#x2F;etc&#x2F;resolv.conf 最上面添加 nameserver 8.8.8.8。 生成一个 yourconfig.json 配置文件，内容如下： 1234567891011&#123; &quot;server&quot;: &quot;agentserver.node.aliyun.com:8080&quot;, &quot;appid&quot;: &quot;xxx&quot;, &quot;secret&quot;: &quot;xxx&quot;, &quot;logdir&quot;: &quot;/tmp/&quot;, &quot;reconnectDelay&quot;: 10, &quot;heartbeatInterval&quot;: 60, &quot;reportInterval&quot;: 60, &quot;error_log&quot;: [], &quot;packages&quot;: []&#125; 使用该配置启动 agenthub： 1$ nohup agenthub yourconfig.json &amp; agenthub 将以常驻进程的方式运行。 下面通过两个例子使用 alinode 分别调试内存泄露和 CPU 性能瓶颈的问题。 8.2.4 使用 alinode 诊断内存泄露我们以一段内存泄露代码为例，演示如何使用 alinode 调试内存泄漏的问题。代码如下： server.js 12345678910111213141516171819const Paloma = require(&#x27;paloma&#x27;)const session = require(&#x27;koa-generic-session&#x27;)const app = new Paloma()app.keys = [&#x27;some secret&#x27;]app.use(session())class User &#123; constructor () &#123; this.name = new Array(1e6).join(&#x27;*&#x27;) &#125;&#125;app.use((ctx) =&gt; &#123; ctx.session.user = new User() ctx.status = 204&#125;)app.listen(3000) 这段代码内存泄露的原因是：koa-generic-session 默认将 session 信息存储到了内存中。 client.js 12345const axios = require(&#x27;axios&#x27;)setInterval(() =&gt; &#123; axios.get(&#x27;http://localhost:3000&#x27;)&#125;, 1000) 打开两个终端，分别运行 ： 12$ ENABLE_NODE_LOG=YES node server # 开启 alinode 的 log 功能，使得 agenthub 可以监控内核级的性能数据$ node client # 1s 发起一次请求 过一会儿就可以在 alinode 控制台看到数据了，如下所示： 可以看出，alinode 监控了： 异常日志 慢 HTTP 日志 模块依赖 系统监控数据（包含非常详尽的图表数据，有 Memory、CPU、Load、QPS、GC、Apdex、Apdex detail、node 进程数、磁盘） 单击 “堆快照” 生成一个 heapsnapshot 文件，单击左侧的 “文件”，查看刚才生成的堆快照： 在转储后单击 “分析”，选择 “对象簇视图” 的树状列表，展开后如下所示： 可以看出：MemoryStore 的 sessions 对象中存储了 97 个 session，并且每个 session.user 上有一个 name 字段是长字符串。 8.2.5 使用 alinode 诊断 CPU 性能瓶颈测试代码如下： server.js 12345678910111213const crypto = require(&#x27;crypto&#x27;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/encrypt&#x27;, controller: function encryptRouter (ctx) &#123; const password = ctx.query.password || &#x27;test&#x27; const salt = crypto.randomBytes(128).toString(&#x27;base64&#x27;) const encryptedPassword = crypto.pbkdf2Sync(password, salt, 10000, 64, &#x27;sha512&#x27;).toString(&#x27;hex&#x27;) ctx.body = encryptedPassword&#125;&#125;)app.listen(3000) client.js 123456789const axios = require(&#x27;axios&#x27;)setInterval(() =&gt; &#123; const tps = Math.floor(Math.random() * 10) for (let i = 0; i &lt; tps; i++) &#123; axios.get(&#x27;http://localhost:3000/encrypt?password=123456&#x27;) &#125; console.log(`Sent $&#123;tps&#125; requests`)&#125;, 1000) 打开两个终端，分别运行： 12$ ENABLE_NODE_LOG=YES node server$ node client 回到 alinode 控制台，单击 “CPU Profile”，然后到 “文件” 查看刚才生成的 cpuprofile 文件，转储后单击 “分析”，可以看到生成的火焰图。展开后如下所示： 可以看出：server.js 的第 5 行，即 encryptRouter 占用 CPU 较多，而 encryptRouter 里的 exports.pbkdf2Sync 占用了 encryptRouter 绝大部分 CPU 时间。 回到 “文件”，选择 “devtools 分析”，如下所示： 可以看出：alinode 已经帮我们把可疑的 CPU 性能瓶颈的元凶标红显示了。 小提示：不管是生成的 heapsnapshot 还是 cpuprofile，都可以选择 “下载” 后使用 Chrome DevTools 分析。 我们在上面只演示了 “堆快照” 和 “CPU Profile” 的使用，alinode 支持抓取以下 5 种数据： 堆快照 堆时间线 CPU Profile GC Trace Heap Profile 本节就不一一演示了。 alinode 如此强大，而且免费使用，可以说是开发 Node.js 应用必不可少的好伙伴了。 8.2.6 参考链接 https://www.aliyun.com/product/nodejs https://github.com/aliyun-node/agenthub https://cnodejs.org/topic/561f289b4928c5872abc18ee 上一节：8.1 node-clinic","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging - 8.1 Node-clinic","slug":"8.1 node-clinic","date":"2020-02-01T07:00:00.000Z","updated":"2022-05-25T04:30:57.228Z","comments":true,"path":"2020/02/01/8.1 node-clinic/","link":"","permalink":"https://marvinliu1.github.io/2020/02/01/8.1%20node-clinic/","excerpt":"","text":"Node in Debugging 8.1.1 使用 node-clinicnode-clinic（简称 clinic） 是一个开箱即用的 Node.js 应用诊断工具。 首先，安装 Node.js@9+ 1$ nvm install 9 全局安装 clinic： 1$ npm i clinic -g 创建测试代码： app.js 12345678910111213const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()function sleep (ms) &#123; const future = Date.now() + ms while (Date.now() &lt; future);&#125;app.use(() =&gt; &#123; sleep(50)&#125;)app.listen(3000) 使用 clinic doctor 启动并诊断 Node.js 应用： 1$ clinic doctor -- node app.js 使用 ab 压测： 1$ ab -c 10 -n 200 &quot;http://localhost:3000/&quot; CTRL+C 终止测试程序，终端打印出： 123Warning: Trace event is an experimental feature and could change at any time.^Canalysing datagenerated HTML file is 51485.clinic-doctor.html 用浏览器打开 51485.clinic-doctor.html，如下所示： 可以看出：Event Loop 被阻塞，CPU Usage 也居高不下，一定是有 CPU 密集计算，与我们的测试代码吻合。 clinic 也给出了猜测和解决方案，我们尝试使用 clinic flame 生成火焰图： 1$ clinic flame -- node app.js 也可以用以下命令代替： 12$ clinic flame --collect-only -- node app.js # 只收集数据$ clinic flame --visualize-only PID.flamegraph # 将数据生成火焰图 使用同样的 ab 命令压测后，生成的火焰图如下： 可以看出：app.js 第 4 行的 sleep 函数占用了大量的 CPU 计算。 8.1.2 参考链接 https://www.nearform.com/blog/introducing-node-clinic-a-performance-toolkit-for-node-js-developers/ 上一节：7.2 Telegraf + InfluxDB + Grafana(下) 下一节：8.2 alinode","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging - 7.2 Telegraf + InfluxDB + Grafana(2)","slug":"7.2 Telegraf + InfluxDB + Grafana(下)","date":"2019-11-28T07:00:00.000Z","updated":"2022-05-25T04:31:46.056Z","comments":true,"path":"2019/11/28/7.2 Telegraf + InfluxDB + Grafana(下)/","link":"","permalink":"https://marvinliu1.github.io/2019/11/28/7.2%20Telegraf%20+%20InfluxDB%20+%20Grafana(%E4%B8%8B)/","excerpt":"","text":"Node in Debugging 上一小节主要讲解了 Telegraf(StatsD) + InfluxDB + Grafana 的搭建和基本用法，并创建了请求量和响应时间这两种图表。本节讲解几个高级用法： 如何将 Grafana（监控）跟 ELK（日志）结合起来。 Grafana 监控报警。 脚本一键生成图表。 7.2.1 Grafana + ELK在观察 Grafana 监控时，我们发现某个 api 接口的响应时间突然有一个尖刺，这个时候想查一查到底是什么原因导致的。在前面介绍过 koa-await-breakpoint + ELK 的用法，是否可以结合 Grafana 使用呢？答案是可以的。 因为涉及的代码量大，所以笔者写了一个 demo 托管到了 GitHub 上，有两个 repo，分别为： grafana-to-elk：包含 web server 和模拟请求的 client，分别将统计信息发送到 StatsD 和将日志发送到 ELK。 grafana-to-elk-extension：Chrome 扩展，作用是： 格式化从 Grafana 跳转到 ELK 的时间范围。 添加 requestId 的链接。 高亮显示重要的字段。 首先 clone 到本地： 12$ git clone https://github.com/nswbmw/grafana-to-elk.git$ git clone https://github.com/nswbmw/grafana-to-elk-extension.git 测试步骤如下： 按照 7.2 节启动 Telegraf（StatsD）+ InfluxDB + Grafana。 按照 6.3 节启动 ELK。 到 grafana-to-elk 目录下运行： 12$ npm i$ node server 打开另外一个终端运行： 1$ node client 此时，ELK 应该有日志了。 加载 Chrome 扩展。打开 Chrome 扩展程序页 -&gt; 加载已解压的扩展程序… -&gt; 加载 grafana-to-elk-extension（非测试环境下需要修改 manifest.json 的 matches 字段）。 回到 Grafana 的 “getHome 响应时间” 图表，进入编辑页的 General tab，如下填写： 在保存后，图表的左上角会出现一个类似分享的按钮，鼠标悬浮到上面出现 “Go to ELK”，单击它跳转到 ELK。 ELK 显示如下： grafana-to-elk-extension 插件会自动处理并跳转到对应 Grafana 中的时间段并且查询出了我们关心的结果。单击第 1 个 requestId，将会跳转并显示该请求所有的日志，如下所示： 错误请求的日志如下： 7.2.2 监控报警Grafana 有内置的监控报警，设置步骤如下： 进入 Alerting -&gt; Notifications 页，单击 New Notification 添加新的报警组，如下所示： 回到 “getHome 响应时间” 图表，进入编辑页的 Alert tab，单击 Create Alert 创建报警规则，如下所示： 报警规则为：每 60s 检查一次过去 1min 的 mean（B 在 Metrics 里面代表了别名为 mean 的折线图）折线图的平均值是否大于 50，如果是则触发报警。 注意：如需发邮件，则需要设置 Grafana 的 SMTP settings。 我们还可以给 “getHome 请求量” 设置错误报警监控，如下所示： 每 60s 检查一次过去 1min 内是否有 400 报错，如果有则触发报警，其中 B 代表了别名为 400 的折线图。 小提示：报警信息可以发送到 Email、Slack、DingTalk 或者 Webhook 等等。报警的内容可以包含图表的截图，需要配置 external image uploader。 小提示：Grafana 配置文件在 &#x2F;etc&#x2F;grafana&#x2F;grafana.ini，如需修改步骤如下： 1234$ docker exec -it docker-statsd-influxdb-grafana bash # 进入 docker 容器$ apt update$ apt install vim$ vim /etc/grafana/grafana.ini 7.2.3 脚本一键生成图表我们只创建了一个接口的两种（请求量和响应时间）图表，每个图表要设置 link、alert 等等就很麻烦了。如果我们的 api 有几百个接口，岂不成了灾难了。 Grafana 虽然有 Template 的功能，但我们接下来讲一个奇技淫巧。 我们在保存图表的时候从 Chrome DevTools 的 Network 看到发起了一个 Ajax 请求，如下所示： dashboard 就是包含了当前仪表盘页所有图表的完整 JSON，其中： dashboard：包含一到多行 row。 rows：一行 row 包含一到多个 panel。 panels：一个 panel 是一个具体的图表。 在拿到这个 JSON 后，我们就可以不断地尝试修改它，然后用 axios 带上浏览器拿到的 Cookie 发送到图中的 URL，模拟浏览器的保存操作，这里就不再展开讲解了。 7.2.4 参考链接 http://docs.grafana.org/alerting/notifications/ 上一节：7.1 Telegraf + InfluxDB + Grafana(上) 下一节：8.1 node-clinic","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging - 7.1 Telegraf + InfluxDB + Grafana(1)","slug":"7.1 Telegraf + InfluxDB + Grafana(上)","date":"2019-11-26T07:00:00.000Z","updated":"2022-05-25T04:30:08.253Z","comments":true,"path":"2019/11/26/7.1 Telegraf + InfluxDB + Grafana(上)/","link":"","permalink":"https://marvinliu1.github.io/2019/11/26/7.1%20Telegraf%20+%20InfluxDB%20+%20Grafana(%E4%B8%8A)/","excerpt":"","text":"Node in Debugging 本节将会讲解如何使用 Telegraf(StatsD) + InfluxDB + Grafana 搭建一套完整的监控系统。 7.1.1 Telegraf(StatsD) + InfluxDB + Grafana 简介Telegraf 是一个使用 Go 语言开发的代理程序，可收集系统和服务或者其他来源（inputs）的数据，并将其写入 InfluxDB（outputs）数据库，支持多种 inputs 和 outputs 插件。StatsD 是一个使用 Node.js 开发的网络守护进程，通过 UDP 或者 TCP 方式收集各种统计信息，包括计数器和定时器等。 InfluxDB 是一个使用 Go 语言开发的开源的分布式时序、事件和指标数据库，无需外部依赖，其设计目标是实现分布式和水平伸缩扩展。 Grafana 是一个使用 Angular + Go 语言开发的开源的、功能齐全的、漂亮的仪表盘和图表的编辑器，可用来做日志的分析与展示曲线图（如 api 的请求日志），支持多种 backend，如 ElasticSearch、InfluxDB、OpenTSDB 等等。 工作流程：Telegraf 将 StatsD（inputs）和 InfluxDB（outputs）结合起来，即发往 StatsD 的数据，最终通过 Telegraf 写入了 InfluxDB，然后 Grafana 读取 InfluxDB 的数据展示成图表。 7.1.2 启动 docker-statsd-influxdb-grafana我们使用 Docker 一键启动 Telegraf(StatsD)+ InfluxDB + Grafana，节省搭建环境的时间。 12345678$ docker run -d \\ --name docker-statsd-influxdb-grafana \\ -p 3003:3003 \\ -p 3004:8083 \\ -p 8086:8086 \\ -p 22022:22 \\ -p 8125:8125/udp \\ samuelebistoletti/docker-statsd-influxdb-grafana:latest 端口映射关系如下： 1234567Host Container Service-----------------------------------3003 3003 grafana3004 8083 influxdb-admin8086 8086 influxdb8125 8125 statsd22022 22 sshd 7.1.3 熟悉 InfluxDB容器启动后，浏览器访问 localhost:3004（以下称为 influxdb-admin），如下所示： InfluxDB 的基本概念如下： database：数据库。 measurement：数据库中的表。 point：表里面的一行数据，由时间戳（time）、数据（field）和标签（tag）组成 time：每条数据记录的时间戳，是数据库中的主索引（会自动生成）。 field：各种记录的值（没有索引的属性）。 tag：各种有索引的属性。 … InfluxDB 采用了类 SQL 的查询语法，例如： show databases：列出所有数据库。 show measurements：列出当前数据库的所有表。 select * from xxx：列出 xxx 表的所有数据。 … 我们在 Query 中输入： 1show databases 查询结果如下： _interal 是 InfluxDB 内部使用的数据库，telegraf 是我们当前 Docker 容器启动后默认创建的测试数据库。 7.1.4 配置 Grafana用浏览器打开 localhost:3003，如下所示： 输入用户名 root 和密码 root 登录，进入初始化配置页，单击 “Add data source”，如下填写： 单击 “Save &amp; Test” 保存配置。目前配置好了 Grafana 默认的 datasource 是名为 api 的 InfluxDB，接下来创建测试代码，产生测试数据。 7.1.5 node-statsdnode-statsd 是一个 statsd 的 Node.js client。创建以下测试代码： 12345678910111213141516const StatsD = require(&#x27;node-statsd&#x27;)const statsdClient = new StatsD(&#123; host: &#x27;localhost&#x27;, port: 8125&#125;)setInterval(() =&gt; &#123; const responseTime = Math.floor(Math.random() * 100) statsdClient.timing(&#x27;api&#x27;, responseTime, function (error, bytes) &#123; if (error) &#123; console.error(error) &#125; else &#123; console.log(`Successfully sent $&#123;bytes&#125; bytes, responseTime $&#123;responseTime&#125;ms`) &#125; &#125;)&#125;, 1000) 运行以上代码，每一秒钟会产生一个 0~99 之间的随机值（模拟响应时间，单位为毫秒），发送到 StatsD，StatsD 会通过 Telegraf 将这些数据写入 InfluxDB 的 telegraf 数据库。 回到 influxdb-admin，单击右上角的下拉菜单切换到 telegraf 数据库，然后输入 show measurements 查看已经存在 api 表了，然后输入： 1select * from api 查询结果如下： 可以看出 api 表有以下几个字段： time：InfluxDB 默认添加的时间戳。 90_percentile：所有记录中从小到大 90% 那个点的值。 count：一次收集的日志数量，可以看出每条记录（point）的 count 值接近或等于 10，而我们的测试代码是 1s 发送一条数据，也就说明 Telegraf 默认设置是 10s 收集一次数据，默认配置也的确是这样的，见：https://github.com/samuelebistoletti/docker-statsd-influxdb-grafana/blob/master/telegraf/telegraf.conf。 host：机器地址。 lower：最小的那条记录的值。 mean：所有记录的平均值。 metric_type：metric 类型。 stddev：所有记录的标准差。 upper：最大的那条记录的值。 7.1.6 创建 Grafana 图表回到 Grafana，单击左上角 Grafana 图标的下拉菜单，单击 Dashboards 回到仪表盘页继续完成配置，单击 “New dashboard”，然后单击创建 Graph 类型的图表，就创建了一个空的图表，如下所示： 单击当前的图表，选择 Edit，修改如下几个地方： Metrics 配置中选择 FROM -&gt; api 表，SELECT -&gt; field(mean) 字段。 Display 配置中 “Null value” 选择 connected，将每个点连成折线。 效果如下所示： 7.1.7 模拟真实环境middlewares&#x2F;statsd.js 1234567891011121314151617181920const StatsD = require(&#x27;node-statsd&#x27;)const statsdClient = new StatsD(&#123; host: &#x27;localhost&#x27;, port: 8125&#125;)module.exports = function (routerName) &#123; return async function statsdMiddleware (ctx, next) &#123; const start = Date.now() try &#123; await next() const spent = Date.now() - start statsdClient.timing(`api_$&#123;routerName&#125;`, spent) &#125; catch (e) &#123; statsdClient.increment(`api_$&#123;routerName&#125;_$&#123;e.status || (ctx.status !== 404 ? ctx.status : 500)&#125;`) throw e &#125; &#125;&#125; server.js 12345678910111213141516171819202122const Bluebird = require(&#x27;bluebird&#x27;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()const statsd = require(&#x27;./middlewares/statsd&#x27;)app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/&#x27;, controller: [ statsd(&#x27;getHome&#x27;), async (ctx) =&gt; &#123; // 模拟十分之一出错概率 if (Math.random() &lt; 0.1) &#123; console.error(&#x27;error&#x27;) ctx.throw(400) &#125; // 模拟 1-100 毫秒响应时间 const responseTime = Math.floor(Math.random() * 100 + 1) await Bluebird.delay(responseTime) console.log(`Spent $&#123;responseTime&#125;ms`) ctx.status = 200 &#125;]&#125;)app.listen(3000) client.js 123456789const axios = require(&#x27;axios&#x27;)setInterval(() =&gt; &#123; // 模拟 1-10 的 tps const tps = Math.floor(Math.random() * 10 + 1) for (let i = 0; i &lt; tps; i++) &#123; axios.get(&#x27;http://localhost:3000&#x27;) &#125;&#125;, 1000) 打开两个终端，分别运行： 12$ node server.js$ node client.js 回到 influxdb-admin，输入： 1show measurements 可以看到已经有 api_getHome 和 api_getHome_400 表了。回到 Grafana，在一行（row）里创建两个图表，分别为： 请求量：包含了正常请求（200）和错误请求（4xx、5xx 等等）请求量的折线图。 响应时间：正常请求的最低（lower）、平均（mean）、最高（upper）响应时间的折线图。 以 “getHome 响应时间” 的图表为例，Metrics 配置截图如下： 7.1.8 参考链接 https://www.cnblogs.com/shhnwangjian/p/6897216.html 上一节：6.5 Sentry 下一节：7.2 Telegraf + InfluxDB + Grafana(下)","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging - 6.5 Sentry","slug":"6.5 Sentry","date":"2019-11-03T06:00:00.000Z","updated":"2022-05-25T04:29:30.953Z","comments":true,"path":"2019/11/03/6.5 Sentry/","link":"","permalink":"https://marvinliu1.github.io/2019/11/03/6.5%20Sentry/","excerpt":"","text":"Node in Debugging 6.5.1 什么是 Sentry？Sentry官网的介绍： Sentry’s real-time error tracking gives you insight into production deployments and information to reproduce and fix crashes. 简而言之：Sentry 是一个开源的实时错误日志收集平台。 6.5.2 安装 Sentry我们使用 Docker 安装并启动 Sentry，步骤如下： 启动一个 Redis 容器，命名为 sentry-redis： 1$ docker run -d --name sentry-redis redis 启动一个 Postgres 容器，命名为 sentry-postgres： 12345$ docker run -d \\ --name sentry-postgres \\ -e POSTGRES_PASSWORD=secret \\ -e POSTGRES_USER=sentry \\ postgres 生成一个 Sentry 的 secret key： 1$ docker run --rm sentry config generate-secret-key 将下面的 &lt;secret-key&gt; 都替换成上面生成的 secret key。 如果是新的数据库（第 1 次运行），则需要运行 upgrade： 12345$ docker run -it --rm \\ -e SENTRY_SECRET_KEY=&#x27;&lt;secret-key&gt;&#x27; \\ --link sentry-postgres:postgres \\ --link sentry-redis:redis \\ sentry upgrade 按步骤填写自己的信息： 最终创建了一个超级管理员和一个默认的名为 sentry 的组织（organization）。 启动 Sentry，并对外暴露 9000 端口： 1234567$ docker run -d \\ --name my-sentry \\ -e SENTRY_SECRET_KEY=&#x27;&lt;secret-key&gt;&#x27; \\ --link sentry-redis:redis \\ --link sentry-postgres:postgres \\ -p 9000:9000 \\ sentry 启动 Celery cron 和 Celery workers： 123456$ docker run -d \\ --name sentry-cron \\ -e SENTRY_SECRET_KEY=&#x27;&lt;secret-key&gt;&#x27; \\ --link sentry-postgres:postgres \\ --link sentry-redis:redis \\ sentry run cron 123456$ docker run -d \\ --name sentry-worker-1 \\ -e SENTRY_SECRET_KEY=&#x27;&lt;secret-key&gt;&#x27; \\ --link sentry-postgres:postgres \\ --link sentry-redis:redis \\ sentry run worker 小提示：Celery 是用 Python 写的一个分布式任务调度模块。 完成！ 用浏览器打开 localhost:9000，就能看到 Sentry 的登录页面了，如下所示： 首次登录时需要填写一些必要信息 ，如下所示： 单击 Continue 进入 Sentry 仪表盘（Dashboard）。单击右上角的 New Project 按钮创建一个项目，选择 Node.js 并填写项目名称为 API，然后单击 Create Project 按钮创建项目。如下所示： 创建成功后进入 Node.js 使用示例页面，我们选择使用 Koa 测试，在右侧选择 Koa： 上图所示是 koa@1 的示例代码，我们以 Paloma（基于 koa@2）为例，编写测试代码： 1234567891011121314151617const Raven = require(&#x27;raven&#x27;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()Raven.config(DSN).install()app.on(&#x27;error&#x27;, (err) =&gt; &#123; Raven.captureException(err, (err, eventId) =&gt; &#123; console.log(&#x27;Reported error &#x27; + eventId) &#125;)&#125;)app.use((ctx) =&gt; &#123; throw new Error(&#x27;test&#x27;)&#125;)app.listen(3000) raven 是 Node.js 版的 Sentry SDK，用来收集和发送错误日志。 小提示：将 DSN 替换为上图中的 http://xxx@localhost:9000/2，DSN 既告诉客户端 Sentry 服务器的地址，也用来当做身份认证的 token。 运行以上测试代码，访问 localhost:3000，错误信息会发送给 Sentry。Sentry 展示如下： 点进去可以看到详细的信息： Sentry 还有许多功能，比如：错误归类、展示错误的频率柱状图、将错误指派给组织中的某个人、给错误添加标签、查看这类错误事件的历史、标记错误为已解决、在错误下发表评论、警报等等功能。 6.5.3 koa-raven笔者将 raven 封装成 Koa 的一个中间件。使用如下： 1234567891011const raven = require(&#x27;koa-raven&#x27;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.use(raven(DSN))app.use((ctx) =&gt; &#123; throw new Error(&#x27;test&#x27;)&#125;)app.listen(3000) 或者使用 ctx.raven： 1234567891011121314151617const raven = require(&#x27;koa-raven&#x27;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.use(raven(DSN))app.use((ctx) =&gt; &#123; try &#123; throw new Error(&#x27;test&#x27;) &#125; catch (e) &#123; ctx.raven.captureException(e, &#123; extra: &#123; name: &#x27;tom&#x27; &#125; &#125;) ctx.status = 500 ctx.body = e.stack &#125;&#125;)app.listen(3000) 6.5.4 参考链接 https://sentry.io/ 上一节：6.4 OpenTracing + Jaeger 下一节：7.1 Telegraf + InfluxDB + Grafana(上)","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging - 6.4 OpenTracing + Jaeger","slug":"6.4 OpenTracing + Jaeger","date":"2019-10-28T06:00:00.000Z","updated":"2022-05-25T04:29:03.625Z","comments":true,"path":"2019/10/28/6.4 OpenTracing + Jaeger/","link":"","permalink":"https://marvinliu1.github.io/2019/10/28/6.4%20OpenTracing%20+%20Jaeger/","excerpt":"","text":"Node in Debugging 6.4.1 什么是 OpenTracing？OpenTracing 是一个分布式追踪规范。OpenTracing 通过提供平台无关、厂商无关的 API，为分布式追踪提供统一的概念和数据标准，使得开发人员能够方便的添加（或更换）追踪系统的实现。OpenTracing 定义了如下几个术语： Span：代表了系统中的一个逻辑工作单元，它具有操作名、操作开始时间以及持续时长。Span 可能会有嵌套或排序，从而对因果关系建模。 Tags：每个 Span 可以有多个键值对（key: value）形式的 Tags，Tags 是没有时间戳的，支持简单地对 Span 进行注解和补充。 Logs：每个 Span 可以进行多次 Log 操作，每一次 Log 操作，都需要一个带时间戳的时间名称，以及可选的任意大小的存储结构。 Trace：代表了系统中的一个数据&#x2F;执行路径（一个或多个 Span），可以将其理解为 Span 的有向无环图。 OpenTracing 还有其他一些概念，这里不过多解释。我们看个传统的调用关系例子，如下所示： 在一个分布式系统中，追踪一个事务或者调用流一般如上图所示。虽然这种图对于看清各组件的组合关系是很有用的，但是，它不能很好显示组件的调用时间，以及是串行调用还是并行调用。如果展现更复杂的调用关系，会更加复杂，甚至无法画出这样的图。另外，这种图也无法显示调用间的时间间隔以及是否通过定时调用来启动调用。一种更有效的展现一个典型的 trace 过程，如下图所示： 这种展现方式增加了执行时间的上下文，相关服务间的层次关系，进程或者任务的串行或并行调用关系。这样的视图有助于发现系统调用的关键路径。通过关注关键路径的执行过程，项目团队可能专注于优化路径中的关键位置，最大幅度地提升系统的性能。例如：可以通过追踪一个资源定位的调用情况，明确底层的调用情况，发现哪些操作有阻塞的情况。 6.4.2 什么是 Jaeger?Jaeger 是 OpenTracing 的一个实现，是 Uber 开源的一个分布式追踪系统，其灵感来源于Dapper 和 OpenZipkin。从 2016 年开始，该系统已经在 Uber 内部得到了广泛的应用，它可以用于微服务架构应用的监控，特性包括分布式上下文传播（Distributed context propagation）、分布式事务监控、根原因分析、服务依赖分析以及性能优化。该项目已经被云原生计算基金会（Cloud Native Computing Foundation，CNCF）接纳为第 12 个项目。 6.4.3 启动 Jaeger + Jaeger UI我们使用 Docker 启动 Jaeger + Jaeger UI（Jaeger 可视化 web 控制台），运行如下命令： 1234567$ docker run -d -p5775:5775/udp \\ -p 6831:6831/udp \\ -p 6832:6832/udp \\ -p 5778:5778 \\ -p 16686:16686 \\ -p 14268:14268 \\ jaegertracing/all-in-one:latest 用浏览器打开 localhost:16686，如下所示： 现在并没有任何数据，接下来我们看看如何使用 Jaeger 接收并查询日志。 6.4.4 如何使用 OpenTracing + Jaeger?OpenTracing 和 Jaeger 分别提供了 JavaScript&#x2F;Node.js 的 SDK： opentracing&#x2F;opentracing-javascript jaegertracing&#x2F;jaeger-client-node opentracing 示例代码如下： 123456789101112131415161718192021222324252627282930const http = require(&#x27;http&#x27;)const opentracing = require(&#x27;opentracing&#x27;)// NOTE: the default OpenTracing tracer does not record any tracing information.// Replace this line with the tracer implementation of your choice.const tracer = new opentracing.Tracer()const span = tracer.startSpan(&#x27;http_request&#x27;)const opts = &#123; host : &#x27;example.com&#x27;, method: &#x27;GET&#x27;, port : &#x27;80&#x27;, path: &#x27;/&#x27;,&#125;http.request(opts, res =&gt; &#123; res.setEncoding(&#x27;utf8&#x27;) res.on(&#x27;error&#x27;, err =&gt; &#123; // assuming no retries, mark the span as failed span.setTag(opentracing.Tags.ERROR, true) span.log(&#123;&#x27;event&#x27;: &#x27;error&#x27;, &#x27;error.object&#x27;: err, &#x27;message&#x27;: err.message, &#x27;stack&#x27;: err.stack&#125;) span.finish() &#125;) res.on(&#x27;data&#x27;, chunk =&gt; &#123; span.log(&#123;&#x27;event&#x27;: &#x27;data_received&#x27;, &#x27;chunk_length&#x27;: chunk.length&#125;) &#125;) res.on(&#x27;end&#x27;, () =&gt; &#123; span.log(&#123;&#x27;event&#x27;: &#x27;request_end&#x27;&#125;) span.finish() &#125;)&#125;).end() 有以下两点需要解释： 需要将上面的 const tracer = new opentracing.Tracer() 替换成自己的 tracer 实现，即 Jaeger 的实现。 通过 tracer.startSpan 启动一个 Span，span.setTag 用来设置 Tags，span.log 用来设置 Logs，span.finish 用来结束一个 Span。 这有点类似于我们的手动埋点，只不过变成了一个规范而已。但 OpenTracing 的功能不止如此，上面只是一个 Span 的用法，Span 之间还可以关联调用关系，最后得到一个 DAG（有向无环图）。 举个例子：假如我们正在做微服务，多个服务之间有调用关系（不管是 HTTP 还是 RPC 等），每次调用服务在内部可能产生多个 Span，最终会在 Jaeger 控制台页面看到一个完整的 Trace 和 DAG 图（微服务之间的调用关系）。 jaeger-client-node 使用如下： 12345const tracer = new jaeger.Tracer( serviceName, new jaeger.RemoteReporter(new UDPSender()), new jaeger.RateLimitingSampler(1)) 创建一个 tracer，可以接收 3 个参数： serviceName：服务名。 Reporter：上报器，即往哪发日志，如上述代码是通过 UDP 发送日志，默认地址 localhost:6832。 Sampler：采样器，即日志如何采样，如上述代码是限制 1 秒采样一次。 这里不再详细介绍其它选项，读者可自行去查阅 jaeger-client-node 的文档。 6.4.5 koa-await-breakpoint-jaeger通过上面的例子我们知道，在使用 Jaeger 时需要手动埋点。前面我们介绍了 koa-await-breakpoint 日志自动打点，可自定义 store，koa-await-breakpoint-jaeger 是为 koa-await-breakpoint 写的 store 的 adaptor，在实现上有一些小技巧，有兴趣的读者可以去读下源码。 还是以 koa-await-breakpoint 的 example 举例，只添加了两行代码引入 jaeger 的使用。代码如下： app.js 1234567891011121314const JaegerStore = require(&#x27;koa-await-breakpoint-jaeger&#x27;)const koaAwaitBreakpoint = require(&#x27;koa-await-breakpoint&#x27;)(&#123; name: &#x27;api&#x27;, files: [&#x27;./routes/*.js&#x27;], store: new JaegerStore()&#125;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.use(koaAwaitBreakpoint)app.route(&#123; method: &#x27;POST&#x27;, path: &#x27;/users&#x27;, controller: require(&#x27;./routes/user&#x27;).createUser &#125;)app.listen(3000) 运行： 1$ curl -XPOST localhost:3000/users 刷新 localhost:16686，可以看到已经有日志了，如下所示： 选择 Sercice -&gt; api，Operation -&gt; POST &#x2F;users，单击 Find Traces 查看所有结果，右侧展示了一条日志，点进去如下所示： 小提示：可以根据 tags 过滤结果。 注意：Jaeger 是分布式追踪系统，通常用来追踪多个服务之间的调用关系，而这里用来追踪一个服务的多个函数之间的调用关系。 修改 routes&#x2F;user.js 的 createComment 函数 throw 一个 new Error(&#39;test&#39;)，重新运行，如下所示： 可以看出，Jaeger 完美地展现了在一个请求到来时，函数之间的调用关系、层级关系及耗时，甚至函数体和错误栈都有！然后，我们可以用 requestId 去 ELK 中查询日志了。 6.4.6 参考链接 https://wu-sheng.gitbooks.io/opentracing-io/content/ https://segmentfault.com/a/1190000008895129 http://www.infoq.com/cn/news/2017/11/Uber-open-spurce-Jaeger 上一节：6.3 ELK 下一节：6.5 Sentry","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging - 6.3 ELK","slug":"6.3 ELK","date":"2019-10-15T06:00:00.000Z","updated":"2022-05-25T04:28:29.086Z","comments":true,"path":"2019/10/15/6.3 ELK/","link":"","permalink":"https://marvinliu1.github.io/2019/10/15/6.3%20ELK/","excerpt":"","text":"Node in Debugging ELK 是 ElasticSearch + Logstash + Kibana 这套组合工具的简称，是一个常用的日志系统。 ElasticSearch：是一款开源的基于 Lucene 之上实现的一个分布式搜索引擎，也是一个存储引擎（例如：日志），它的特点有：分布式、零配置、自动发现、索引自动分片、索引副本机制、Restful 风格的接口、多数据源和自动搜索负载等。 Logstash：是一款开源的日志收集工具，它可以对日志进行收集、分析、过滤，并将其存储（例如：ElasticSearch）起来供以后使用。 Kibana：是一款开源的可视化工具，可以为 ElasticSearch 提供的日志分析友好的 Web 界面，可以汇总、分析和搜索重要的数据日志。 6.3.1 安装 ELK我们使用 Docker 安装 ELK，运行如下命令： 12345$ docker run -p 5601:5601 \\ -p 9200:9200 \\ -p 5044:5044 \\ -p 15044:15044/udp \\ -it --name elk sebp/elk 进入容器： 1$ docker exec -it elk /bin/bash 运行以下命令设置 logstash 的 input 和 output： 12# /opt/logstash/bin/logstash --path.data /tmp/logstash/data \\ -e &#x27;input &#123; udp &#123; codec =&gt; &quot;json&quot; port =&gt; 15044 &#125; &#125; output &#123; elasticsearch &#123; hosts =&gt; [&quot;localhost&quot;] &#125; &#125;&#x27; 这里我们启动一个 15044 的 UDP 端口，用来接收通过 UDP 发送到 Logstash 的日志。 用浏览器打开 localhost:5601，如下所示： 目前还没有指定 index（ElasticSearch 的 index 类似于 MySQL&#x2F;MongoDB 中的 database），即日志来源。下面我们尝试向 ELK 中写入一些日志。 6.3.2 使用 ELK这里仍然以使用 koa-await-breakpoint 为例，来演示如何将日志发送到 ELK。 app.js 12345678910111213const koaAwaitBreakpoint = require(&#x27;koa-await-breakpoint&#x27;)(&#123; name: &#x27;api&#x27;, files: [&#x27;./routes/*.js&#x27;], store: require(&#x27;./logger&#x27;)&#125;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.use(koaAwaitBreakpoint)app.route(&#123; method: &#x27;POST&#x27;, path: &#x27;/users&#x27;, controller: require(&#x27;./routes/user&#x27;).createUser &#125;)app.listen(3000) logger.js 1234567891011121314151617const Logstash = require(&#x27;logstash-client&#x27;)const logstash = new Logstash(&#123; type: &#x27;udp&#x27;, host: &#x27;localhost&#x27;, port: 15044&#125;)module.exports = &#123; save (log) &#123; if (log.error) &#123; log.errMsg = log.error.message log.errStack = log.error.stack &#125; logstash.send(log) &#125;&#125; routes&#x2F;user.js 1234567891011121314151617181920212223242526272829303132333435363738const Mongolass = require(&#x27;mongolass&#x27;)const mongolass = new Mongolass(&#x27;mongodb://localhost:27017/test&#x27;)const User = mongolass.model(&#x27;User&#x27;)const Post = mongolass.model(&#x27;Post&#x27;)const Comment = mongolass.model(&#x27;Comment&#x27;)exports.createUser = async function (ctx) &#123; const name = ctx.query.name || &#x27;default&#x27; const age = +ctx.query.age || 18 await createUser(name, age) ctx.status = 204&#125;async function createUser (name, age) &#123; const user = (await User.create(&#123; name, age &#125;)).ops[0] await createPost(user)&#125;async function createPost (user) &#123; const post = (await Post.create(&#123; uid: user._id, title: &#x27;post&#x27;, content: &#x27;post&#x27; &#125;)).ops[0] await createComment(user, post)&#125;async function createComment (user, post) &#123; await Comment.create(&#123; userId: user._id, postId: post._id, content: &#x27;comment&#x27; &#125;)&#125; 运行： 1$ curl -XPOST localhost:3000/users 此时刷新 Kibana，如下所示： 在初次使用 Kibana 时，需要配置 Kibana 从 ElasticSearch 的哪些 index 中搜索日志，我们在 Index pattern 处填 logstash-*，然后单击 Next step 按钮，在 Time Filter field name 中选择 timestamp，单击 Create index pattern 完成配置。 注意：我们选择 timestamp 而不是默认的 @timestamp，是因为在 koa-await-breakpoint 的日志中有 timestamp 字段。 单击左侧目录的 Discover，我们发现已经有日志了。分别单击左侧出现的 Available Fields 的 fn、type、step、take，然后按 step 升序展示，如下所示： 是不是一目了然！我们把每个请求的每一步的函数及其执行时间都记录下来了。 修改 routes&#x2F;users.js 的 createComment，throw 一个 new Error(&#39;test&#39;)。重启程序并发起一个请求，ELK 显示如下： 小提示：在实际应用中会有非常多的日志，我们可以通过 requestId 找到一个请求的所有日志，在 7.2 小节会讲解。 ELK 非常强大，基本能满足所有日志查询需求，Kibana 的查询使用 lucene 语法，用 10 分钟左右就能大体上手。Kibana 还能创建各种仪表盘和聚合图表，读者可自行尝试。 6.3.3 参考链接 http://blog.51cto.com/baidu/1676798 http://elk-docker.readthedocs.io 上一节：6.2 async_hooks 下一节：6.4 OpenTracing + Jaeger","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging - 6.2 Async Hooks","slug":"6.2 async_hooks","date":"2019-09-29T06:00:00.000Z","updated":"2022-05-25T04:28:09.798Z","comments":true,"path":"2019/09/29/6.2 async_hooks/","link":"","permalink":"https://marvinliu1.github.io/2019/09/29/6.2%20async_hooks/","excerpt":"","text":"Node in Debugging 上一小节讲解了 koa-await-breakpoint 的用法，但 koa-await-breakpoint 仍然有一个很大的缺憾，即无法记录除 routes&#x2F;controllers 外的函数的执行时间（因为获取不到当前请求的 ctx）。举个通俗的例子：在一个路由的 controller 里面调用了 A ，A 调用了其他文件的 B ，B 又调用了其他文件的 C…这是非常常见的用法，但之前使用 koa-await-breakpoint 只能获取 A 的执行时间，无法获取 B 和 C 的执行时间。 根本原因在于：无法知道函数之间的调用关系，即 B 不知道是 A 调用的它，即便知道也不知道是哪次请求到来时执行的 A 调用的它。 但是，&#110;&#x6f;&#100;&#x65;&#x40;&#56;&#46;&#49; 引入了一个黑魔法——Async Hooks。 6.2.1 Async Hooks我们先看看 async_hooks 是什么。Node.js 官网对 async_hooks 的介绍为： The async_hooks module provides an API to register callbacks tracking the lifetime of asynchronous resources created inside a Node.js application. 一句话概括：async_hooks 用来追踪 Node.js 中异步资源的生命周期。 我们来看段测试代码： 1234567891011121314151617181920212223242526272829303132333435363738const fs = require(&#x27;fs&#x27;)const async_hooks = require(&#x27;async_hooks&#x27;)async_hooks.createHook(&#123; init (asyncId, type, triggerAsyncId, resource) &#123; fs.writeSync(1, `$&#123;type&#125;($&#123;asyncId&#125;): trigger: $&#123;triggerAsyncId&#125;\\n`) &#125;, destroy (asyncId) &#123; fs.writeSync(1, `destroy: $&#123;asyncId&#125;\\n`); &#125;&#125;).enable()async function A () &#123; fs.writeSync(1, `A -&gt; $&#123;async_hooks.executionAsyncId()&#125;\\n`) setTimeout(() =&gt; &#123; fs.writeSync(1, `A in setTimeout -&gt; $&#123;async_hooks.executionAsyncId()&#125;\\n`) B() &#125;)&#125;async function B () &#123; fs.writeSync(1, `B -&gt; $&#123;async_hooks.executionAsyncId()&#125;\\n`) process.nextTick(() =&gt; &#123; fs.writeSync(1, `B in process.nextTick -&gt; $&#123;async_hooks.executionAsyncId()&#125;\\n`) C() C() &#125;)&#125;function C () &#123; fs.writeSync(1, `C -&gt; $&#123;async_hooks.executionAsyncId()&#125;\\n`) Promise.resolve().then(() =&gt; &#123; fs.writeSync(1, `C in promise.then -&gt; $&#123;async_hooks.executionAsyncId()&#125;\\n`) &#125;)&#125;fs.writeSync(1, `top level -&gt; $&#123;async_hooks.executionAsyncId()&#125;\\n`)A() async_hooks.createHook 可以注册 4 个方法来跟踪所有异步资源的初始化（init）、回调之前（before）、回调之后（after）、销毁后（destroy）事件，并通过调用 .enable() 启用，调用 .disable() 关闭。 这里我们只关心异步资源的初始化和销毁的事件，并使用 fs.writeSync(1, msg) 打印到标准输出，writeSync 的第 1 个参数接收文件描述符，1 表示标准输出。为什么不使用 console.log 呢？因为 console.log 是一个异步操作，如果在 init、before、after 和 destroy 事件处理函数中出现，就会导致无限循环，同理也不能使用任何其他的异步操作。 运行该程序，打印如下： 123456789101112131415161718192021top level -&gt; 1PROMISE(6): trigger: 1A -&gt; 1Timeout(7): trigger: 1TIMERWRAP(8): trigger: 1A in setTimeout -&gt; 7PROMISE(9): trigger: 7B -&gt; 7TickObject(10): trigger: 7B in process.nextTick -&gt; 10C -&gt; 10PROMISE(11): trigger: 10PROMISE(12): trigger: 11C -&gt; 10PROMISE(13): trigger: 10PROMISE(14): trigger: 13C in promise.then -&gt; 12C in promise.then -&gt; 14destroy: 7destroy: 10destroy: 8 这段程序的打印结果包含了很多信息，下面逐一进行解释： 为了实现对异步资源的跟踪，Node.js 对每一个函数（不论异步还是同步）提供了一个 async scope，我们可以通过调用 async_hooks.executionAsyncId() 来获取函数当前的 async scope 的 id（称为 asyncId），通过调用 async_hooks.triggerAsyncId() 来获取当前函数调用者的 asyncId。 异步资源在创建时触发 init 事件函数，init 函数中的第 1 个参数代表该异步资源的 asyncId，type 表示异步资源的类型（例如 TCPWRAP、PROMISE、Timeout、Immediate、TickObject 等等），triggerAsyncId 表示该异步资源的调用者的 asyncId。异步资源在销毁时触发 destroy 事件函数，该函数只接收一个参数，即该异步资源的 asyncId。 函数调用关系明确。我们通过上面的打印结果可以很容易地看出（从下往上看） ：C（asyncId: 10）被 B（asyncId: 7）调用，B（asyncId: 7）被 A（asyncId: 1）调用。而且 C 的 promise.then 里面的 asyncId（值为 12&#x2F;14）也可以通过 12&#x2F;14 -&gt; 11&#x2F;13 -&gt; 10 定位到 C 的 asyncId（值为 10）。 同步函数每次调用的 asyncId 都一样，如上所示，C 调用了两次，都打印了 C -&gt; 10，与调用方的作用域的 asyncId 一致，即如上所示打印的 B in process.nextTick -&gt; 10。异步函数每次调用的 asyncId 都不一样，即如上所示打印的 C in promise.then -&gt; 12 和 C in promise.then -&gt; 14。 最外层作用域的 asyncId 总是 1，每个异步资源在创建时 asyncId 全局递增。 上面 5 条结论非常重要。接下来我们看看如何使用 async_hooks 改造 koa-await-breakpoint。 6.2.2 改造 koa-await-breakpoint我们通过前面的结论已经知道，使用 async_hooks 时可以通过 asyncId 串起函数的调用关系，但是如何将这些函数的调用链与 koa 接收的每个请求关联起来呢? 首先，定义一个全局 Map，存储函数的调用关系： 1234567891011121314151617181920212223242526const async_hooks = require(&#x27;async_hooks&#x27;)const asyncIdMap = new Map()async_hooks.createHook(&#123; init (asyncId, type, triggerAsyncId) &#123; const ctx = getCtx(triggerAsyncId) if (ctx) &#123; asyncIdMap.set(asyncId, ctx) &#125; else &#123; asyncIdMap.set(asyncId, triggerAsyncId) &#125; &#125;, destroy (asyncId) &#123; asyncIdMap.delete(asyncId) &#125;&#125;).enable()function getCtx (asyncId) &#123; if (!asyncId) &#123; return &#125; if (typeof asyncId === &#x27;object&#x27; &amp;&amp; asyncId.app) &#123; return asyncId &#125; return getCtx(asyncIdMap.get(asyncId))&#125; 有以下三点需要解释： 定义了一个全局 Map 来存储函数的调用关系，在适当的地方（下面会讲到）将当前请求的 ctx 存储到 Map 中，key 是 asyncId。 每个异步资源在初始化时，会尝试通过 asyncId 向上寻找祖先的 value 是否是 ctx（koa 应用中每个请求的 ctx），如果有，则直接将 value 设置为 ctx，否则将 value 设置为调用者的 asyncId（即 triggerAsyncId）。 在 destroy 事件函数里直接删除调用关系，保证了不会引起内存泄漏，即杜绝引用了 ctx 但没有释放的情况。 然后，修改 global[loggerName] 如下： 1234567891011121314151617181920212223242526272829303132global[loggerName] = async function (ctx, fn, fnStr, filename) &#123; const originalContext = ctx let requestId = _getRequestId() const asyncId = async_hooks.executionAsyncId() if (!requestId) &#123; const _ctx = getCtx(asyncId) if (_ctx) &#123; ctx = _ctx requestId = _getRequestId() &#125; &#125; else &#123; asyncIdMap.set(asyncId, ctx) &#125; if (requestId) &#123; _logger(&#x27;beforeAwait&#x27;) &#125; const result = await fn.call(originalContext) if (requestId) &#123; _logger(&#x27;afterAwait&#x27;, result) &#125; return result function _getRequestId () &#123; return ctx &amp;&amp; ctx.app &amp;&amp; _.get(ctx, requestIdPath) &#125; function _logger (type, result) &#123; ... &#125;&#125; 有以下两点需要解释： logger 函数传入的第 1 个参数 ctx，之前是每个请求的 ctx，现在可能是当前执行上下文的 this，所以先将 ctx 赋值给 originalContext，然后通过 await fn.call(originalContext) 让函数在执行时有正确的上下文。 如果传入的 ctx 是来自请求的 ctx 且能拿到 requestId，那么将当前 asyncId 和 ctx 写入 Map，如果不是来自请求的 ctx，则尝试从 Map 里向上寻找祖先的 value 是否是 ctx，如果找到，则覆盖当前的 ctx 并拿到 requestId。 至此，koa-await-breakpoint 全部改造完毕。接下来我们通过一个例子验证下升级后的 koa-await-breakpoint： app.js 1234567891011const koaAwaitBreakpoint = require(&#x27;koa-await-breakpoint&#x27;)(&#123; files: [&#x27;./routes/*.js&#x27;]&#125;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.use(koaAwaitBreakpoint)app.route(&#123; method: &#x27;POST&#x27;, path: &#x27;/users&#x27;, controller: require(&#x27;./routes/user&#x27;).createUser &#125;)app.listen(3000) routes&#x2F;users.js 1234567891011121314151617181920212223242526272829303132333435363738const Mongolass = require(&#x27;mongolass&#x27;)const mongolass = new Mongolass(&#x27;mongodb://localhost:27017/test&#x27;)const User = mongolass.model(&#x27;User&#x27;)const Post = mongolass.model(&#x27;Post&#x27;)const Comment = mongolass.model(&#x27;Comment&#x27;)exports.createUser = async function (ctx) &#123; const name = ctx.query.name || &#x27;default&#x27; const age = +ctx.query.age || 18 await createUser(name, age) ctx.status = 204&#125;async function createUser (name, age) &#123; const user = (await User.create(&#123; name, age &#125;)).ops[0] await createPost(user)&#125;async function createPost (user) &#123; const post = (await Post.create(&#123; uid: user._id, title: &#x27;post&#x27;, content: &#x27;post&#x27; &#125;)).ops[0] await createComment(user, post)&#125;async function createComment (user, post) &#123; await Comment.create(&#123; userId: user._id, postId: post._id, content: &#x27;comment&#x27; &#125;)&#125; 这段代码的意思是：在访问创建用户接口时，调用 createUser，createUser 里面又调用了 createPost，createPost 里面又调用了 createComment。运行： 1$ curl -XPOST localhost:3000/users 打印如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; type: &#x27;start&#x27;, step: 1, take: 0 ... &#125;&#123; type: &#x27;beforeAwait&#x27;, step: 2, fn: &#x27;createUser(name, age)&#x27;, take: 1 ... &#125;&#123; type: &#x27;beforeAwait&#x27;, step: 3, fn: &#x27;User.create(...)&#x27;, take: 1 ... &#125;&#123; type: &#x27;afterAwait&#x27;, step: 4, fn: &#x27;User.create(...)&#x27;, take: 36 ... &#125;&#123; type: &#x27;beforeAwait&#x27;, step: 5, fn: &#x27;createPost(user)&#x27;, take: 1 ... &#125;&#123; type: &#x27;beforeAwait&#x27;, step: 6, fn: &#x27;Post.create(...)&#x27;, take: 0 ... &#125;&#123; type: &#x27;afterAwait&#x27;, step: 7, fn: &#x27;Post.create(...)&#x27;, take: 3 ... &#125;&#123; type: &#x27;beforeAwait&#x27;, step: 8, fn: &#x27;createComment(user, post)&#x27;, take: 1 ... &#125;&#123; type: &#x27;beforeAwait&#x27;, step: 9, fn: &#x27;Comment.create(...)&#x27;, take: 0 ... &#125;&#123; type: &#x27;afterAwait&#x27;, step: 10, fn: &#x27;Comment.create(...)&#x27;, take: 1 ... &#125;&#123; type: &#x27;afterAwait&#x27;, step: 11, fn: &#x27;createComment(user, post)&#x27;, take: 1 ... &#125;&#123; type: &#x27;afterAwait&#x27;, step: 12, fn: &#x27;createPost(user)&#x27;, take: 6 ... &#125;&#123; type: &#x27;afterAwait&#x27;, step: 13, fn: &#x27;createUser(name, age)&#x27;, take: 44 ... &#125;&#123; type: &#x27;end&#x27;, step: 14, take: 0 ... &#125; 至此，一个全链路、无侵入、强大的日志打点工具就完成了。 注意：使用 async_hooks 在目前有较严重的性能损耗，见 https://github.com/bmeurer/async-hooks-performance-impact，请慎重在生产环境中使用。 6.2.3 参考链接 https://nodejs.org/dist/latest-v8.x/docs/api/async_hooks.html https://zhuanlan.zhihu.com/p/27394440 https://www.jianshu.com/p/4a568dac41ed 上一节：6.1 koa-await-breakpoint 下一节：6.3 ELK","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging - 6.1 Koa-await-breakpoint","slug":"6.1 koa-await-breakpoint","date":"2019-09-20T06:00:00.000Z","updated":"2022-05-25T04:27:36.571Z","comments":true,"path":"2019/09/20/6.1 koa-await-breakpoint/","link":"","permalink":"https://marvinliu1.github.io/2019/09/20/6.1%20koa-await-breakpoint/","excerpt":"","text":"Node in Debugging 日志打点一直是个调试最头疼的问题。如果直接在代码中插入埋点代码，不仅侵入性强而且工作量大也不够灵活，要是能做到智能打点就好了，koa-await-breakpoint 正是我们需要的。 6.1.1 什么是 koa-await-breakpoint？koa-await-breakpoint 是一个 Koa 的中间件，是一个在 routes&#x2F;controllers 里（作用域包含 ctx）的 await 表达式前后自动打点的工具，不用插入一行日志打点代码，只需要在引入时配置一下，就可以记录每个请求到来时 await 表达式前后的现场，例如： await 表达式所在的文件及行列号（filename）。 await 表达式是执行的第几步（step）。 await 表达式字符串形式（fn）。 执行 await 表达式所花费的毫秒（take）。 执行 await 表达式的结果（result）。 当前请求的 ctx。 使用方法如下： 1234567891011121314// On top of the main fileconst koaAwaitBreakpoint = require(&#x27;koa-await-breakpoint&#x27;)(&#123; name: &#x27;api&#x27;, files: [&#x27;./routes/*.js&#x27;]&#125;)const Koa = require(&#x27;koa&#x27;)const app = new Koa()// Generally, above other middlewaresapp.use(koaAwaitBreakpoint)...app.listen(3000) 6.1.2 实现原理 重载 Module.prototype._compile，相当于 hack 了 require，如果发现是 require 了配置里指定的文件，则进行下一步，否则返回原始代码的内容，相关源代码如下： 12345678shimmer.wrap(Module.prototype, &#x27;_compile&#x27;, function (__compile) &#123; return function koaBreakpointCompile(content, filename) &#123; if (!_.includes(filenames, filename)) &#123; return __compile.call(this, content, filename); &#125; ... &#125;;&#125;); 用 esprima 解析代码，生成 AST。例如： 123456789101112const Mongolass = require(&#x27;mongolass&#x27;)const mongolass = new Mongolass(&#x27;mongodb://localhost:27017/test&#x27;)const User = mongolass.model(&#x27;users&#x27;)exports.getUsers = async function getUsers(ctx) &#123; await User.create(&#123; name: &#x27;xx&#x27;, age: 18 &#125;) const users = await User.find() return users&#125; 会生成如下 AST，只截取了 await User.create(...) 相关的 AST： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Script &#123; ... AwaitExpression &#123; type: &#x27;AwaitExpression&#x27;, argument: CallExpression &#123; type: &#x27;CallExpression&#x27;, callee: StaticMemberExpression &#123; type: &#x27;MemberExpression&#x27;, computed: false, object: Identifier &#123; type: &#x27;Identifier&#x27;, name: &#x27;User&#x27;, loc: &#123; start: &#123; line: 6, column: 10 &#125;, end: &#123; line: 6, column: 14 &#125; &#125; &#125;, property: Identifier &#123; type: &#x27;Identifier&#x27;, name: &#x27;create&#x27;, loc: &#123; start: &#123; line: 6, column: 15 &#125;, end: &#123; line: 6, column: 21 &#125; &#125; &#125;, loc: &#123; start: &#123; line: 6, column: 10 &#125;, end: &#123; line: 6, column: 21 &#125; &#125; &#125;, arguments: [ ObjectExpression &#123; type: &#x27;ObjectExpression&#x27;, properties: [ Property &#123; type: &#x27;Property&#x27;, key: Identifier &#123; type: &#x27;Identifier&#x27;, name: &#x27;name&#x27;, loc: &#123; start: &#123; line: 7, column: 6 &#125;, end: &#123; line: 7, column: 10 &#125; &#125; &#125;, computed: false, value: Literal &#123; type: &#x27;Literal&#x27;, value: &#x27;xx&#x27;, raw: &#x27;\\&#x27;xx\\&#x27;&#x27;, loc: &#123; start: &#123; line: 7, column: 12 &#125;, end: &#123; line: 7, column: 16 &#125; &#125; &#125;, kind: &#x27;init&#x27;, method: false, shorthand: false, loc: &#123; start: &#123; line: 7, column: 6 &#125;, end: &#123; line: 7, column: 16 &#125; &#125; &#125;, Property &#123; type: &#x27;Property&#x27;, key: Identifier &#123; type: &#x27;Identifier&#x27;, name: &#x27;age&#x27;, loc: &#123; start: &#123; line: 8, column: 6 &#125;, end: &#123; line: 8, column: 9 &#125; &#125; &#125;, computed: false, value: Literal &#123; type: &#x27;Literal&#x27;, value: 18, raw: &#x27;18&#x27;, loc: &#123; start: &#123; line: 8, column: 11 &#125;, end: &#123; line: 8, column: 13 &#125; &#125; &#125;, kind: &#x27;init&#x27;, method: false, shorthand: false, loc: &#123; start: &#123; line: 8, column: 6 &#125;, end: &#123; line: 8, column: 13 &#125; &#125; &#125; ], loc: &#123; start: &#123; line: 6, column: 22 &#125;, end: &#123; line: 9, column: 5 &#125; &#125; &#125; ], loc: &#123; start: &#123; line: 6, column: 10 &#125;, end: &#123; line: 9, column: 6 &#125; &#125; &#125;, loc: &#123; start: &#123; line: 6, column: 4 &#125;, end: &#123; line: 9, column: 6 &#125; &#125; &#125;, ... 遍历找到 awaitExpression 节点，进行以下包装后生成 AST，替换掉原来的节点。 12345678global.logger( (typeof ctx !== &#x27;undefined&#x27; ? ctx : this), function()&#123; return awaitExpression &#125;, awaitExpressionString, filename) 相关源代码如下： 12345678910111213findAwaitAndWrapLogger(parsedCodes)try &#123; content = escodegen.generate(parsedCodes, &#123; format: &#123; indent: &#123; style: &#x27; &#x27; &#125; &#125;, sourceMap: filename, sourceMapWithCode: true &#125;)&#125; catch (e) &#123; console.error(&#x27;cannot generate code for file: %s&#x27;, filename) console.error(e.stack) process.exit(1)&#125;debug(&#x27;file %s regenerate codes:\\n%s&#x27;, filename, content.code) findAwaitAndWrapLogger 的作用就是遍历 AST，将 awaitExpression 替换成用日志函数包裹后新的 awaitExpression 的 AST。最后用 escodegen 将 AST 生成代码（支持 soucemap，所以错误栈对应的行数是正确的）。 核心：每个请求到来时，生成一个 requestId（可自定义，默认为 uuid）挂载到 ctx 上，这样就可以通过 requestId 将日志串起来了。 特点：可以记录每个请求的每一步（await 表达式）的现场及返回值，方便查日志。 6.1.3 使用 koa-await-breakpoint测试代码如下： app.js 12345678910111213const koaAwaitBreakpoint = require(&#x27;koa-await-breakpoint&#x27;)(&#123; name: &#x27;api&#x27;, files: [&#x27;./routes/*.js&#x27;]&#125;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()const userRouter = require(&#x27;./routes/user&#x27;)app.use(koaAwaitBreakpoint)app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/users&#x27;, controller: userRouter.getUsers &#125;)app.listen(3000) routes&#x2F;user.js 12345678910111213const Mongolass = require(&#x27;mongolass&#x27;)const mongolass = new Mongolass(&#x27;mongodb://localhost:27017/test&#x27;)const User = mongolass.model(&#x27;users&#x27;)exports.getUsers = async function getUsers (ctx) &#123; await User.create(&#123; name: &#x27;xx&#x27;, age: 18 &#125;) const users = await User.find() ctx.body = users&#125; 运行： 1$ DEBUG=koa-await-breakpoint node app.js 终端打印出转换后的代码，可以看出 routes&#x2F;users.js 被转换成了： 123456789101112131415const Mongolass = require(&#x27;mongolass&#x27;);const mongolass = new Mongolass(&#x27;mongodb://localhost:27017/test&#x27;);const User = mongolass.model(&#x27;users&#x27;);exports.getUsers = async function getUsers(ctx) &#123; await global.logger(typeof ctx !== &#x27;undefined&#x27; ? ctx : this, function () &#123; return User.create(&#123; name: &#x27;xx&#x27;, age: 18 &#125;); &#125;, &#x27;User.create(&#123;\\n name: \\&#x27;xx\\&#x27;,\\n age: 18\\n&#125;)&#x27;, &#x27;/Users/nswbmw/Desktop/test/routes/user.js:6:2&#x27;); const users = await global.logger(typeof ctx !== &#x27;undefined&#x27; ? ctx : this, function () &#123; return User.find(); &#125;, &#x27;User.find()&#x27;, &#x27;/Users/nswbmw/Desktop/test/routes/user.js:11:16&#x27;); ctx.body = users;&#125;; 访问 localhost:3000&#x2F;users，终端打印出: 123456&#123;&quot;name&quot;:&quot;api&quot;,&quot;requestId&quot;:&quot;50dbda0c-9e13-4659-acce-b237bc5178b7&quot;,&quot;timestamp&quot;:&quot;2018-02-26T06:31:31.100Z&quot;,&quot;this&quot;:...,&quot;type&quot;:&quot;start&quot;,&quot;step&quot;:1,&quot;take&quot;:0&#125;&#123;&quot;name&quot;:&quot;api&quot;,&quot;requestId&quot;:&quot;50dbda0c-9e13-4659-acce-b237bc5178b7&quot;,&quot;step&quot;:2,&quot;filename&quot;:&quot;/Users/nswbmw/Desktop/test/routes/user.js:6:2&quot;,&quot;timestamp&quot;:&quot;2018-02-26T06:31:31.104Z&quot;,&quot;this&quot;:...,&quot;type&quot;:&quot;beforeAwait&quot;,&quot;fn&quot;:&quot;User.create(&#123;\\n name: &#x27;xx&#x27;,\\n age: 18\\n&#125;)&quot;,&quot;take&quot;:4&#125;&#123;&quot;name&quot;:&quot;api&quot;,&quot;requestId&quot;:&quot;50dbda0c-9e13-4659-acce-b237bc5178b7&quot;,&quot;step&quot;:3,&quot;filename&quot;:&quot;/Users/nswbmw/Desktop/test/routes/user.js:6:2&quot;,&quot;timestamp&quot;:&quot;2018-02-26T06:31:31.175Z&quot;,&quot;this&quot;:...,&quot;type&quot;:&quot;afterAwait&quot;,&quot;fn&quot;:&quot;User.create(&#123;\\n name: &#x27;xx&#x27;,\\n age: 18\\n&#125;)&quot;,&quot;result&quot;:&#123;&quot;result&quot;:&#123;&quot;ok&quot;:1,&quot;n&quot;:1&#125;,&quot;ops&quot;:[&#123;&quot;name&quot;:&quot;xx&quot;,&quot;age&quot;:18,&quot;_id&quot;:&quot;5a93a9c3cf8c8797c9b47482&quot;&#125;],&quot;insertedCount&quot;:1,&quot;insertedIds&quot;:[&quot;5a93a9c3cf8c8797c9b47482&quot;]&#125;,&quot;take&quot;:71&#125;&#123;&quot;name&quot;:&quot;api&quot;,&quot;requestId&quot;:&quot;50dbda0c-9e13-4659-acce-b237bc5178b7&quot;,&quot;step&quot;:4,&quot;filename&quot;:&quot;/Users/nswbmw/Desktop/test/routes/user.js:11:16&quot;,&quot;timestamp&quot;:&quot;2018-02-26T06:31:31.175Z&quot;,&quot;this&quot;:...,&quot;type&quot;:&quot;beforeAwait&quot;,&quot;fn&quot;:&quot;User.find()&quot;,&quot;take&quot;:0&#125;&#123;&quot;name&quot;:&quot;api&quot;,&quot;requestId&quot;:&quot;50dbda0c-9e13-4659-acce-b237bc5178b7&quot;,&quot;step&quot;:5,&quot;filename&quot;:&quot;/Users/nswbmw/Desktop/test/routes/user.js:11:16&quot;,&quot;timestamp&quot;:&quot;2018-02-26T06:31:31.180Z&quot;,&quot;this&quot;:...,&quot;type&quot;:&quot;afterAwait&quot;,&quot;fn&quot;:&quot;User.find()&quot;,&quot;result&quot;:[&#123;&quot;_id&quot;:&quot;5a93a9c3cf8c8797c9b47482&quot;,&quot;name&quot;:&quot;xx&quot;,&quot;age&quot;:18&#125;],&quot;take&quot;:5&#125;&#123;&quot;name&quot;:&quot;api&quot;,&quot;requestId&quot;:&quot;50dbda0c-9e13-4659-acce-b237bc5178b7&quot;,&quot;timestamp&quot;:&quot;2018-02-26T06:31:31.181Z&quot;,&quot;this&quot;:...,&quot;type&quot;:&quot;end&quot;,&quot;step&quot;:6,&quot;take&quot;:1&#125; 注意：type 是以下其中一种，take 的单位是 ms。 start：请求到来时第 1 次打点。 beforeAwait：上一个 awaitExpression 之后到这一个 awaitExpression 之前。 afterAwait：这个 awaitExpression 开始到结束。 error：错误日志，包含了错误信息。 end：请求结束时打点。 6.1.4 自定义日志存储store 参数最好自己定义（默认打印日志到 stdout），该参数是一个对象并且有一个 save 方法即可。在 save 方法内可做一些逻辑修改或者日志策略，比如： 添加日志标识（例如：name）方便区分不同服务的日志。 针对错误日志，添加一些额外字段方便追踪现场。 将日志发送到 Logstash 或其他日志服务。 限制日志频率，比如：只有响应时间大于 500ms 的请求日志才会被记录。 koa_await_breakpoint_store.js 1234567891011121314exports.save = function save(record, ctx) &#123; record.name = &#x27;app name&#x27; record.env = process.env.NODE_ENV if (record.error) &#123; record.error = &#123; message: record.error.message, stack: record.error.stack, status: record.error.status || record.error.statusCode || 500 &#125; &#125; ... logstash.send(record)&#125; 6.1.5 参考链接 https://github.com/jquery/esprima https://github.com/estools/escodegen 上一节：5.2 Elastic APM 下一节：6.2 async_hooks","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging - 5.2 Elastic APM","slug":"5.2 Elastic APM","date":"2019-08-26T06:00:00.000Z","updated":"2022-05-25T04:27:00.216Z","comments":true,"path":"2019/08/26/5.2 Elastic APM/","link":"","permalink":"https://marvinliu1.github.io/2019/08/26/5.2%20Elastic%20APM/","excerpt":"","text":"Node in Debugging 5.2.1 什么是 Elastic APM？Elastic APM 是 Elastic 公司开源的一款 APM 工具，目前还处于 Beta 阶段，它有以下几个优势： 开源。我们可以免费使用，像使用 ELK 一样。 功能完善。API 比较完善，有 Agent、Transaction 和 Trace，默认创建响应时间和每分钟请求数两种图表，且可以使用 Kibana 的 Filter 过滤生成关心的数据的图表。 监控与日志统一。Elastic APM 依赖 ElasticSearch + Kibana，所以可以结合 ELK 使用，可在 Kibana 中查看监控，然后直接查询日志。 Elastic APM 架构如下： APM Agent（即在应用端引入的探针）将收集的日志发送到 APM Server（Go 写的 HTTP 服务），APM Server 将数据存储到 ElasticSearch 中，然后通过 Kibana 展示。 Kibana 展示如下： 5.2.2 启动 ELK我们使用 Docker 安装并启动 ELK，运行如下命令： 1234$ docker run -p 5601:5601 \\ -p 9200:9200 \\ -p 5044:5044 \\ -it --name elk sebp/elk 5.2.3 启动 APM Server首先，下载 APM Server 解压。然后运行以下命令： 12$ ./apm-server setup # 导入 APM 仪表盘到 Kibana$ ./apm-server -e # 启动 APM Server，默认监听 8200 端口 用浏览器打开 localhost:5601，进入 Dashboard 页，如下所示： 5.2.4 使用 Elastic APM测试代码如下： 123456789101112131415161718const apm = require(&#x27;elastic-apm-node&#x27;).start(&#123; appName: &#x27;test&#x27;&#125;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/&#x27;, controller (ctx) &#123; apm.setTransactionName(`$&#123;ctx.method&#125; $&#123;ctx._matchedRoute&#125;`) ctx.status = 200&#125;&#125;)app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/:name&#x27;, controller (ctx) &#123; apm.setTransactionName(`$&#123;ctx.method&#125; $&#123;ctx._matchedRoute&#125;`) ctx.status = 200&#125;&#125;)app.listen(3000) 运行该程序，发起两个请求： 12$ curl localhost:3000/$ curl localhost:3000/nswbmw 等待一会，Kibana 展示如下： 在 Elastic APM 中，有两个术语： transaction：一组 traces 的集合，例如：一个 HTTP 请求。 trace：一个事件及持续时间，例如：一个 SQL 查询。 5.2.5 错误日志现在，我们来测试下 Elastic APM 的错误收集功能。修改测试代码为： 1234567891011121314151617181920212223const apm = require(&#x27;elastic-apm-node&#x27;).start(&#123; appName: &#x27;test&#x27;&#125;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.use(async (ctx, next) =&gt; &#123; try &#123; await next() &#125; catch (e) &#123; apm.captureError(e) ctx.status = 500 ctx.message = e.message &#125;&#125;)app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/&#x27;, controller: function indexRouter (ctx) &#123; apm.setTransactionName(`$&#123;ctx.method&#125; $&#123;ctx._matchedRoute&#125;`) throw new Error(&#x27;error!!!&#x27;)&#125;&#125;)app.listen(3000) 重启测试程序，并发起一次请求。回到 Kibana，单击 Dashboard -&gt; [APM] Errors 可以看到错误日志记录（自动聚合）和图表，如下所示： 单击 View Error Details 进入错误详情页，如下所示： 可以看出：在错误日志中展示了错误代码及行数、上下几行代码、父级函数名和所在文件等信息。 5.2.6 参考链接 https://www.elastic.co/guide/en/apm/agent/nodejs/0.x/index.html https://www.elastic.co/guide/en/apm/agent/nodejs/0.x/custom-stack.html 上一节：5.1 NewRelic 下一节：6.1 koa-await-breakpoint","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 5.1 NewRelic","slug":"5.1 NewRelic","date":"2019-08-05T06:00:00.000Z","updated":"2022-05-25T04:24:35.358Z","comments":true,"path":"2019/08/05/5.1 NewRelic/","link":"","permalink":"https://marvinliu1.github.io/2019/08/05/5.1%20NewRelic/","excerpt":"","text":"Node in Debugging NewRelic 是一个老牌的应用性能监测工具，提供 14 天免费试用，本节将讲解如何使用 NewRelic 监控 Node.js 程序的性能。 测试代码如下： app.js 1234567891011121314151617181920212223require(&#x27;newrelic&#x27;)const crypto = require(&#x27;crypto&#x27;)const express = require(&#x27;express&#x27;)const app = express()const createUser = require(&#x27;./routes/users&#x27;).createUserapp.get(&#x27;/&#x27;, (req, res) =&gt; &#123; const salt = crypto.randomBytes(128).toString(&#x27;base64&#x27;) const hash = crypto.pbkdf2Sync(String(Math.random()), salt, 10000, 512, &#x27;sha512&#x27;).toString(&#x27;hex&#x27;) res.json(&#123; salt, hash &#125;)&#125;)app.get(&#x27;/error&#x27;, (req, res, next) =&gt; &#123; next(new Error(&#x27;error!!!&#x27;))&#125;)app.post(&#x27;/users/:user&#x27;, async (req, res) =&gt; &#123; const user = await createUser(req.params.user, 18) res.json(user)&#125;)app.listen(3000) routes&#x2F;users.js 123456789101112131415161718const Mongolass = require(&#x27;mongolass&#x27;)const mongolass = new Mongolass(&#x27;mongodb://localhost:27017/test&#x27;)const User = mongolass.model(&#x27;User&#x27;)exports.createUser = async function (ctx) &#123; const name = ctx.query.name || &#x27;default&#x27; const age = +ctx.query.age || 18 const user = await createUser(name, age) ctx.status = user&#125;async function createUser (name, age) &#123; const user = (await User.create(&#123; name, age &#125;)).ops[0] return user&#125; 5.1.1 使用 NewRelic首先，注册一个 NewRelic 账号。创建一个应用，如下所示： 选择 APM，进入下一步，选择 Node.js 应用，并拿到 license key： 在 Node.js 中使用 NewRelic 的步骤如下： 12$ npm i newrelic --save # 安装 NewRelic 的 Node.js SDK$ cp node_modules/newrelic/newrelic.js . # 将默认配置文件拷贝到项目根目录下 修改 newrelic.js，app_name 填写我们的应用名（例如：api），license_key 填写刚才生成的 license key。 启动测试程序，并发起几个请求，稍等几分钟，NewRelic 的后台将会收到并展示一些数据（例如：吞吐量，请求的 Urls，错误率、Apdex score 等），如下所示： 试用版的功能有限，升级到付费版可解锁更多功能，例如：数据库分析、错误分析甚至 Node.js VM 监控（CPU、内存、GC、Event Loop）等等。 类似的其他 APM 有： AppDynamics OneAPM DataDog atatus opbeat 用法大同小异，这里就不一一介绍了。 5.1.2 参考链接 https://newrelic.com/ 上一节：4.5 supervisor-hot-reload 下一节：5.2 Elastic APM","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 4.5 Supervisor-hot-reload","slug":"4.5 supervisor-hot-reload","date":"2019-08-03T06:00:00.000Z","updated":"2022-05-25T04:24:07.404Z","comments":true,"path":"2019/08/03/4.5 supervisor-hot-reload/","link":"","permalink":"https://marvinliu1.github.io/2019/08/03/4.5%20supervisor-hot-reload/","excerpt":"","text":"Node in Debugging 我们在本地开发 Node.js 程序时通常会使用 nodemon 或者 supervisor 这种进程管理工具，当有文件修改时自动重启应用。小项目还好，项目大了（尤其是前端应用）每次重启应用都用几秒到几十秒的时间，大部分时间都花在了加载及编译代码上。 这让笔者联想到前端比较火的一个名词——Hot Reload（热加载），比如 React 静态资源的热加载通过 webpack-dev-server 和 react-hot-loader 实现，webpack-dev-server 负责重新编译代码，react-hot-loader 负责热加载。 那在 Node.js 应用中，如何实现 Hot Reload 呢？最好能实现不重启应用便使新代码生效。幸好 ES6 引入了一个新特性——Proxy。 4.5.1 ProxyProxy 用于修改对象的默认行为，等同于在语言层面做出修改，属于一种 “元编程”。Proxy 在要访问的对象之前架设一层拦截，在访问该对象成员时必须先经过这层拦截。示例代码如下： 12345678910111213const obj = new Proxy(&#123;&#125;, &#123; get: function (target, key) &#123; console.log(`getting $&#123;key&#125;!`) return &#x27;haha&#x27; &#125;&#125;)console.log(obj.name)// getting name!// hahaconsole.log(obj.age)// getting age!// haha 可以看出：我们并没有在 obj 上定义 name 和 age 属性，所有获取 obj 上属性都会执行 get 方法然后打印 getting xxx! 和返回 haha。 这里 Proxy 的第 1 个参数是一个空对象，也可以是一个其他的对象，比如函数（毕竟在 JavaScript 中函数也是对象）。 123456789101112131415161718192021function user () &#123;&#125;const obj = new Proxy(user, &#123; get: function (target, key) &#123; console.log(`getting $&#123;key&#125;!`) return &#x27;haha&#x27; &#125;&#125;)console.log(user.name)// userconsole.log(user.age)// undefinedconsole.log(obj.name)// getting name!// hahaconsole.log(obj.age)// getting age!// hahanew Proxy(1, &#123;&#125;)// TypeError: Cannot create proxy with a non-object as target or handler 4.5.2 Proxy 实现 Hot Reload核心原理：使用 Proxy 将模块导出的对象包装一层 “代理”，即 module.exports 导出的是一个 Proxy 实例，定义一个 get 方法，使得获取实例上的属性其实是去获取最新的 require.cache 中的对象上的属性。同时，监听代码文件，如果有修改，则更新 require.cache。 简而言之：我们在获取对象的属性时，中间加了一层代理，通过代理间接获取原有属性的值，如果属性值有更新，则会更新 require.cache 的缓存，那么下次再获取对象的属性时，通过代理将获取该属性最新的值。可见，Proxy 可以实现属性访问拦截，也可实现断开强引用的作用。 笔者发布了一个 proxy-hot-reload 模块，核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152module.exports = function proxyHotReload(opts) &#123; const includes = [ ... ] const excludes = [ ... ] const filenames = _.difference(includes, excludes) chokidar .watch(filenames, &#123; usePolling: true &#125;) .on(&#x27;change&#x27;, (path) =&gt; &#123; try &#123; if (require.cache[path]) &#123; const _exports = require.cache[path].exports if (_.isPlainObject(_exports) &amp;&amp; !_.isEmpty(_exports)) &#123; delete require.cache[path] require(path) &#125; &#125; &#125; catch (e) &#123; ... &#125; &#125;) .on(&#x27;error&#x27;, (error) =&gt; console.error(error)) shimmer.wrap(Module.prototype, &#x27;_compile&#x27;, function (__compile) &#123; return function proxyHotReloadCompile(content, filename) &#123; if (!_.includes(filenames, filename)) &#123; try &#123; return __compile.call(this, content, filename) &#125; catch (e) &#123; ... &#125; &#125; else &#123; const result = __compile.call(this, content, filename) this._exports = this.exports // non-object return original compiled code if (!_.isPlainObject(this._exports)) &#123; return result &#125; try &#123; this.exports = new Proxy(this._exports, &#123; get: function (target, key, receiver) &#123; try &#123; if (require.cache[filename]) &#123; return require.cache[filename]._exports[key] &#125; else &#123; return Reflect.get(target, key, receiver) &#125; &#125; catch (e) &#123; ... &#125; &#125; &#125;) &#125; catch (e) &#123; ... &#125; &#125; &#125; &#125;)&#125; 简单讲解一下： 可传入 includes 和 excludes 参数，支持 glob 写法，用来设置监听哪些代码文件。 用 chokidar 模块监听文件，如果有改动则重新加载该文件。这里只针对 module.exports 导出的是纯对象的模块有用，做这个限制的原因是：对于非对象比如函数，一般我们导出一个函数会直接调用执行而不是获取函数上的属性或方法，这种导出非纯对象模块即使重建缓存也不会生效，所以干脆忽略。幸运的是，module.exports 导出对象占了大多数场景。 用 shimmer 模块重载 Module.prototype._compile 方法，如果是被监听的文件并且导出的是纯对象，则尝试将导出的对象包装成 Proxy 实例。这样，在获取该对象上的属性时，将从 require.cache 中读取最新的值。 使用示例： user.js 1234module.exports = &#123; id: 1, name: &#x27;nswbmw&#x27;&#125; app.js 123456789101112131415if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; require(&#x27;proxy-hot-reload&#x27;)(&#123; includes: &#x27;**/*.js&#x27; &#125;)&#125;const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()const user = require(&#x27;./user&#x27;)app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/&#x27;, controller (ctx) &#123; ctx.body = user&#125;&#125;)app.listen(3000) 浏览器访问 localhost:3000 查看结果，修改 user.js 中字段的值，然后刷新浏览器查看结果。 proxy-hot-reload 有个非常明显的缺点：只支持对导出的是纯对象的文件做代理，而且程序入口文件不会生效，比如上面的 app.js，修改端口号只能重启才会生效。Proxy 再怎么黑魔法也只能做到这个地步了，退一步想，如果修改了 proxy-hot-reload 覆盖不到的文件（例如：app.js）降级成自动重启就好了，如果将 proxy-hot-reload 和 supervisor 结合，会怎么样呢？ 4.5.3 supervisor-hot-reload如果要将 proxy-hot-reload 结合 supervisor 使用，需要解决以下几个难点： 非侵入式。即代码里不再写： 12345if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; require(&#x27;proxy-hot-reload&#x27;)(&#123; includes: &#x27;**/*.js&#x27; &#125;)&#125; 参数统一。supervisor 可接受 -w 参数表明监听哪些文件，-i 参数表明忽略哪些文件，这两个参数怎么与 proxy-hot-reload 的 includes 和 excludes 参数整合。 职责分明。修改代码文件并保存后，优先尝试 proxy-hot-reload 的热更新，如果 proxy-hot-reload 热更新不了，则使用 supervisor 重启。 首先，我们来看下 supervisor 的源码（lib&#x2F;supervisor.js），源码中有这么一段代码： 1234567891011121314var watchItems = watch.split(&#x27;,&#x27;);watchItems.forEach(function (watchItem) &#123; watchItem = path.resolve(watchItem); if ( ! ignoredPaths[watchItem] ) &#123; log(&quot;Watching directory &#x27;&quot; + watchItem + &quot;&#x27; for changes.&quot;); if(interactive) &#123; log(&quot;Press rs for restarting the process.&quot;); &#125; findAllWatchFiles(watchItem, function(f) &#123; watchGivenFile( f, poll_interval ); &#125;); &#125;&#125;); 以上代码的作用是：遍历找到所有需要监听的文件，然后调用 watchGivenFile 监听文件。watchGivenFile 代码如下： 123456789101112131415161718function watchGivenFile (watch, poll_interval) &#123; if (isWindowsWithoutWatchFile || forceWatchFlag) &#123; fs.watch(watch, &#123; persistent: true, interval: poll_interval &#125;, crashWin); &#125; else &#123; fs.watchFile(watch, &#123; persistent: true, interval: poll_interval &#125;, function(oldStat, newStat) &#123; // we only care about modification time, not access time. if ( newStat.mtime.getTime() !== oldStat.mtime.getTime() ) &#123; if (verbose) &#123; log(&quot;file changed: &quot; + watch); &#125; &#125; crash(); &#125;); &#125; if (verbose) &#123; log(&quot;watching file &#x27;&quot; + watch + &quot;&#x27;&quot;); &#125;&#125; watchGivenFile 的作用是：用 fs.watch&#x2F;fs.watchFile 监听文件，如果有改动则调用 crashWin&#x2F;crash 程序退出。supervisor 使用 child_process.spawn 将程序运行在子进程，子进程退出后会被 supervisor 重新启动。相关代码如下： 12345678function startProgram (prog, exec) &#123; var child = exports.child = spawn(exec, prog, &#123;stdio: &#x27;inherit&#x27;&#125;); ... child.addListener(&quot;exit&quot;, function (code) &#123; ... startProgram(prog, exec); &#125;);&#125; 大体理清 supervisor 的关键源码后，我们就知道如何解决上面提到的几个难点了。 首先需要修改 proxy-hot-reload，添加以下几个功能： 添加 includeFiles 和 excludeFiles 选项，值为数组，用来接收 supervisor 传来的文件列表。 添加 watchedFileChangedButNotReloadCache 参数。proxy-hot-reload 可以知道哪些代码文件可以热更新，哪些不可以。当监听到不能热更新的文件有修改时，则调用 watchedFileChangedButNotReloadCache 函数，这个函数里有 process.exit() 使进程退出。 难点及解决方案如下： 非侵入式。因为真正的程序试运行在 supervisor 创建的子进程中，所以我们无法在 supervisor 进程中引入 proxy-hot-reload，只能通过子进程用 node -r xxx 提前引入并覆盖 Module.prototype._compile。解决方案：将 supervisor 需要监听的文件数组（watchFiles）和 proxy-hot-reload 配置写到一个文件（例如：proxy-hot-reload.js）里，子进程通过 node -r proxy-hot-reload.js app.js 预加载此文件启动。 supervisor 相关代码如下： 12345678910111213// 获取 watchFilesfs.writeFileSync(path.join(__dirname, &#x27;proxy-hot-reload.js&#x27;), ` require(&#x27;$&#123;path.join(__dirname, &quot;..&quot;, &quot;node_modules&quot;, &quot;proxy-hot-reload&quot;)&#125;&#x27;)(&#123; includeFiles: $&#123;JSON.stringify(watchFiles)&#125;, excludeFiles: [], watchedFileChangedButNotReloadCache: function (filename) &#123; console.log(filename + &#x27; changed, restarting...&#x27;); setTimeout(function () &#123; process.exit(); &#125;, $&#123;poll_interval&#125;); &#125;&#125;);`);// startChildProcess() 参数统一。将上面的 watchItems.forEach 内异步遍历需要监听的文件列表修改为同步，代码如下： 123456789101112131415var watchFiles = []var watchItems = watch.split(&#x27;,&#x27;);watchItems.forEach(function (watchItem) &#123; watchItem = path.resolve(watchItem); if ( ! ignoredPaths[watchItem] ) &#123; log(&quot;Watching directory &#x27;&quot; + watchItem + &quot;&#x27; for changes.&quot;); if(interactive) &#123; log(&quot;Press rs for restarting the process.&quot;); &#125; findAllWatchFiles(watchItem, function(f) &#123; watchFiles.push(f) // watchGivenFile( f, poll_interval ); &#125;); &#125;&#125;); 注意：这里 findAllWatchFiles 虽然有回调函数，但却是同步的。将 findAllWatchFiles 内的 fs.lstat&#x2F;fs.stat&#x2F;fs.readdir 分别改为 fs.lstatSync&#x2F;fs.statSync&#x2F;fs.readdirSync，这里就不贴代码了。 职责分明。子进程使用 node -r proxy-hot-reload.js app.js 启动后，能热更新的则热更新，不能热更新的执行 watchedFileChangedButNotReloadCache，子进程退出，supervisor 会启动一个新的子进程，实现了职责分明。 笔者将改进后的 supervisor 发布成一个新的包——supervisor-hot-reload 。使用如下： user.js 1234module.exports = &#123; id: 1, name: &#x27;nswbmw&#x27;&#125; app.js 123456789const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()const user = require(&#x27;./user&#x27;)app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/&#x27;, controller (ctx) &#123; ctx.body = user&#125;&#125;)app.listen(3000) 全局安装并使用 supervisor-hot-reload： 12$ npm i supervisor-hot-reload -g$ DEBUG=proxy-hot-reload supervisor-hot-reload app.js 修改 user.js，程序不会重启，打印： 1proxy-hot-reload Reload file: /Users/nswbmw/Desktop/test/user.js 修改 app.js，程序会重启，打印： 12345/Users/nswbmw/Desktop/test/app.js changed, restarting...Program node app.js exited with code 0Starting child process with &#x27;node app.js&#x27;... 4.5.4 内存泄露问题这里需要声明一下，虽然修改 require.cache + Proxy 实现了我们想要的功能，但这样做存在内存泄漏问题，因为即使删除了一个模块的缓存，但父模块的缓存中还引用着旧的模块导出的对象。这个问题可以不用太关心，知道为什么就好，因为我们只是在开发环境使用 proxy-hot-reload。 4.5.5 参考链接 https://nodejs.org/dist/latest-v8.x/docs/api/async_hooks.html 上一节：4.4 debug + repl2 + power-assert 下一节：5.1 NewRelic","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 4.4 Debug","slug":"4.4.1 debug","date":"2019-07-30T06:00:00.000Z","updated":"2022-05-25T04:23:30.946Z","comments":true,"path":"2019/07/30/4.4.1 debug/","link":"","permalink":"https://marvinliu1.github.io/2019/07/30/4.4.1%20debug/","excerpt":"","text":"Node in Debugging 上一小节讲解了如何用使用 VS Code 调试 Node.js 代码，但调试不只是打断点，比如： 如何快速地切换输出的日志类型（或级别）? 我想用 moment 打印出年份，是使用 moment().format(&#39;YYYY&#39;)，还是 moment().format(&#39;yyyy&#39;)，还是两种写法都可以? 断言报错：AssertionError: false &#x3D;&#x3D; true，没啥有用信息，黑人问号??? 本节将介绍 3 款实用的调试工具，分别解决以上 3 种情况，来提高我们的调试效率。 4.4.1 debugdebug 是一个小巧却非常实用的日志模块，可以根据环境变量决定打印不同类型（或级别）的日志。代码如下： app.js 123456789101112131415const normalLog = require(&#x27;debug&#x27;)(&#x27;log&#x27;)const errorLowLog = require(&#x27;debug&#x27;)(&#x27;error:low&#x27;)const errorNormalLog = require(&#x27;debug&#x27;)(&#x27;error:normal&#x27;)const errorHighLog = require(&#x27;debug&#x27;)(&#x27;error:high&#x27;)setInterval(() =&gt; &#123; const value = Math.random() switch (true) &#123; case value &lt; 0.5: normalLog(value); break case value &gt;= 0.5 &amp;&amp; value &lt; 0.7: errorLowLog(value); break case value &gt;= 0.7 &amp;&amp; value &lt; 0.9: errorNormalLog(value); break case value &gt;= 0.9: errorHighLog(value); break default: normalLog(value) &#125;&#125;, 1000) 运行上面的代码，每一秒生成一个随机数，根据随机数的值模拟不同级别的日志输出： &lt; 0.5：正常日志。 0.5~0.7：低级别的错误日志。 0.7~0.9：一般级别的错误日志。 &gt;&#x3D; 0.9：严重级别的错误日志。 运行： 1$ DEBUG=* node app.js 打印如下： 可以看出，debug 模块打印的日志与 console.log 相比，有以下几个特点： 不同的日志类型分配了不同的颜色加以区分，更直观。 添加了日志类型的前缀。 添加了自上一次该类型日志打印到这次日志打印经历了多长时间的后缀。 debug 模块支持以下用法： DEBUG&#x3D;*：打印所有类型的日志。 DEBUG&#x3D;log：只打印 log 类型的日志。 DEBUG&#x3D;error:*：打印所有以 error: 开头的日志。 DEBUG&#x3D;error:*,-error:low：打印所有以 error: 开头的并且过滤掉 error:low 类型的日志。 下面演示一下第 4 种的用法，运行： 1$ DEBUG=error:*,-error:low node app.js 打印如下： 4.4.2 repl2我们在写代码时，有时可能记不清某个模块的某个方法的具体用法，比如：用 moment 格式化年份是用 moment().format(&#39;YYYY&#39;) 还是用 moment().format(&#39;yyyy&#39;) 还是两种写法都可以？lodash 的 _.pick 方法能否能接收数组作为参数？这个时候相对于翻阅官方文档，在 REPL 里试一下可能会更快，通常步骤是： 1234567$ npm i moment$ node&gt; const moment = require(&#x27;moment&#x27;)&gt; moment().format(&#x27;YYYY&#x27;)&#x27;2017&#x27;&gt; moment().format(&#x27;yyyy&#x27;)&#x27;yyyy&#x27; 一次还好，次数多了也略微烦琐。repl2 模块便是为了解决这个问题而生的。 repl2 顾名思义是 REPL 的增强版，repl2 会根据一个用户配置（~&#x2F;.noderc），预先加载模块到 REPL 中，省下了我们手动在 REPL 中 require 模块的过程。 全局安装 repl2： 1$ npm i repl2 -g 使用方式很简单: 将常用的模块全局安装，例如： 1$ npm i lodash validator moment -g 添加配置到 ~&#x2F;.noderc： 12345&#123; &quot;lodash&quot;: &quot;__&quot;, &quot;moment&quot;: &quot;moment&quot;, &quot;validator&quot;: &quot;validator&quot;&#125; 运行 noder： 12345678910$ noder__ = lodash@4.17.4 -&gt; localmoment = moment@2.18.1 -&gt; globalvalidator = validator@7.0.0 -&gt; global&gt; moment().format(&#x27;YYYY&#x27;)&#x27;2017&#x27;&gt; __.random(0, 5)3&gt; validator.isEmail(&#x27;foo@bar.com&#x27;)true 需要讲解以下几点： ~&#x2F;.noderc 是一个 JSON 文件，key 是模块的名字，value 是 require 这个模块后加载到 REPL 中的变量名。这里给 lodash 命名的变量名是 __ 而不是 _，是因为 REPL 中 _ 有特殊含义，表示上一个表达式的结果。 repl2 会优先加载当前目录下的模块，没有找到然后再去加载全局安装的模块。上面结果显示 lodash 是从本地目录加载的，因为 test 目录下已经安装了 lodash，其余的模块没有从本地目录找到则尝试从全局 npm 目录加载。如果都没有找到，则不会加载。 4.4.3 power-assert我们常用的断言库有： should.js expect.js chai 但这类断言库都有一些通病： 过分追求语义化，API 复杂。 错误信息不足。 先看一段代码： test.js 123456789101112131415161718const assert = require(&#x27;assert&#x27;)const should = require(&#x27;should&#x27;)const expect = require(&#x27;expect.js&#x27;)const tom = &#123; id: 1, age: 18 &#125;const bob = &#123; id: 2, age: 20 &#125;describe(&#x27;app.js&#x27;, () =&gt; &#123; it(&#x27;assert&#x27;, () =&gt; &#123; assert(tom.age &gt; bob.age) &#125;) it(&#x27;should.js&#x27;, () =&gt; &#123; tom.age.should.be.above(bob.age) &#125;) it(&#x27;expect.js&#x27;, () =&gt; &#123; expect(tom.age).be.above(bob.age) &#125;)&#125;) 运行： 1$ mocha 结果如下： 12345678910111213141516171819202122232425262728293031323334app.js 1) assert 2) should.js 3) expect.js0 passing (13ms)3 failing1) app.js assert: AssertionError [ERR_ASSERTION]: false == true + expected - actual -false +true at Context.it (test.js:10:5)2) app.js should.js: AssertionError: expected 18 to be above 20 at Assertion.fail (node_modules/should/cjs/should.js:275:17) at Assertion.value (node_modules/should/cjs/should.js:356:19) at Context.it (test.js:13:23)3) app.js expect.js: Error: expected 18 to be above 20 at Assertion.assert (node_modules/expect.js/index.js:96:13) at Assertion.greaterThan.Assertion.above (node_modules/expect.js/index.js:297:10) at Function.above (node_modules/expect.js/index.js:499:17) at Context.it (test.js:16:24) 可以看出，基本没有有用的信息。这时，power-assert 粉墨登场。 power-assert 使用起来很简单，理论上只用一个 assert 就可以了，而且可以无缝迁移。 注意：在使用 intelli-espower-loader 时，要求必须将测试文件放到 test&#x2F; 目录下，所以我们在 test 目录下创建 test&#x2F;app.js，将原来的 test.js 代码粘贴过去。 安装 power-assert 和 intelli-espower-loader，然后运行测试： 12$ npm i power-assert intelli-espower-loader --save-dev$ mocha -r intelli-espower-loader 结果如下： 1234567891011121314151617181920212223242526app.js 1) assert 2) should.js 3) expect.js0 passing (42ms)3 failing1) app.js assert: AssertionError [ERR_ASSERTION]: # test/app.js:10assert(tom.age &gt; bob.age) | | | | | | | | | 20 | | | Object&#123;id:2,age:20&#125; | 18 false Object&#123;id:1,age:18&#125; + expected - actual -false +true ... 错误信息非常直观，有以下两点需要说明： mocha 需要引入 intelli-espower-loader，主要是转译代码，转译之后 require(&#39;assert&#39;) 都不需要改。 intelli-espower-loader 可选择地在 package.json 中添加 directories.test 配置，例如： 123&quot;directories&quot;: &#123; &quot;test&quot;: &quot;mytest/&quot;&#125; 如果没有 directories.test 配置，则默认是 test/。 4.4.4 参考链接 https://zhuanlan.zhihu.com/p/25956323 https://www.npmjs.com/package/intelli-espower-loader","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 4.3 VS Code Debugging","slug":"4.3.1 基本调试","date":"2019-07-26T06:00:00.000Z","updated":"2022-05-25T04:23:06.702Z","comments":true,"path":"2019/07/26/4.3.1 基本调试/","link":"","permalink":"https://marvinliu1.github.io/2019/07/26/4.3.1%20%E5%9F%BA%E6%9C%AC%E8%B0%83%E8%AF%95/","excerpt":"","text":"Node in Debugging Visual Studio Code（简称 VS Code）是一款微软开源的现代化、跨平台、轻量级的代码编辑器。VS Code 很好很强大，本节将介绍如何使用 VS Code 来调试 Node.js 代码。 4.3.1 基本调试示例代码如下： app.js 12345678const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.use(ctx =&gt; &#123; ctx.body = &#x27;hello world!&#x27;&#125;)app.listen(3000) 用 VS Code 加载 test 文件夹，打开 app.js，然后进行如下操作： 单击左侧第 4 个 tab，切换到调试模式。 单击代码第 5 行 ctx.body=&#39;hello world!&#39; 左侧空白处添加断点。 单击左上角 ”调试“ 的绿色三角按钮启动调试。 单击左上角的终端图标打开调试控制台。 最终如下所示： 从 “调试控制台“ 切换到 ”终端“，运行： 1$ curl localhost:3000 如下所示： 可以看出，VS Code 基本覆盖了 Chrome DevTools 的所有功能，并且有两个额外的优点： 集成了终端，不用再打开新的终端输入命令了。 调试动作里添加了 ”重启“ 和 ”停止“ 按钮，不用每次修改完代码后切回终端去重启了。 但 VS Code 的强大远不止如此，通过 launch.json 可以配置详细的调试功能。 4.3.2 launch.json上图可以看出，”调试“ 按钮右边有一个下拉菜单，默认是 ”没有配置“。单击右侧的齿轮状图标，会在项目根目录下创建 .vscode 文件夹及 launch.json 文件。launch.json 的内容如下： 这个默认配置的意思是执行： 1$ node $&#123;workspaceFolder&#125;/app.js launch.json 其实就是存储了一些调试相关的配置，VS Code 在启动调试时，会读取 launch.json 决定以何种方式调试。launch.json 有以下常用选项： 必需字段如下： type：调试器类型。这里是 node（内置的调试器），如果安装了 Go 和 PHP 的扩展后，则对应的 type 分别为 go 和 php。 request：请求的类型，支持 launch 和 attach。launch 就是以 debug 模式启动调试，attach 就是附加到已经启动的进程开启 debug 模式并调试，跟在上一小节中提到的用 node -e &quot;process._debugProcess(PID)&quot; 作用一样。 name：下拉菜单显示的名字。 可选字段（括号里表示适用的类型）如下： program：可执行文件或者调试器要运行的文件 (launch)。 args：要传递给调试程序的参数 (launch)。 env：环境变量 (launch)。 cwd：当前执行目录 (launch)。 address：IP 地址 (launch &amp; attach)。 port：端口号 (launch &amp; attach)。 skipFiles：想要忽略的文件，数组类型 (launch &amp; attach)。 processId：进程 PID (attach)。 … 变量替换： ${workspaceFolder}：当前打开工程的路径。 ${file}：当前打开文件的路径。 ${fileBasename}：当前打开文件的名字，包含后缀名。 ${fileDirname}：当前打开文件所在的文件夹的路径。 ${fileExtname}：当前打开文件的后缀名。 ${cwd}：当前执行目录。 … 如果当前打开的文件是 app.js，则以下配置与默认配置是等效的： 1234567891011&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;启动程序&quot;, &quot;program&quot;: &quot;$&#123;file&#125;&quot; &#125; ]&#125; 若想了解更多的 launch.json 选项，则请查阅： Debugging in Visual Studio Code。 Debug Node.js Apps using VS Code。 下面以 5 个实用的技巧讲解部分 launch.json 配置的作用。 4.3.3 技巧 1——条件断点VS Code 可以添加条件断点，即执行到该行代码满足特定条件后程序才会中断。在断点小红点上右键选择 ”编辑断点“，可以选择以下两种条件： 表达式：当表达式计算结果为 true 时中断，例如设置：ctx.query.name === &#39;nswbmw&#39;，表示当访问 localhost:3000?name=nswbmw 时断点才会生效，其余请求断点无效。 命中次数：同样当表达式计算结果为 true 时中断，支持运算符 &lt;、&lt;&#x3D;、&#x3D;&#x3D;、&gt;、&gt;&#x3D;、%。例如： &gt;10：执行 10 次以后，断点才会生效。 &lt;3：只有前 2 次断点会生效。 10：等价于 &gt;&#x3D;10。 %2：隔一次中断一次。 注意：可以组合表达式和命中次数条件一起使用。在切换条件类型时，需要将原来的条件清空，否则会添加两种条件。将鼠标悬浮在断点上，可以查看设置了哪些条件。 4.3.4 技巧 2——skipFiles从上面图中可以看到，在 VS Code 左侧有一个 ”调用堆栈“ 面板，显示了当前断点的调用堆栈，但无法直观地看出哪些是我们项目的代码，哪些是 node_modules 里模块的代码，而且在单步调试时会进入到 node_modules 里。总之，我们不关心 node_modules 里的代码，我们只关心项目本身的代码。这时，skipFiles 就派上用场了。 skipFiles 顾名思义就是忽略我们不关心的文件。修改 launch.json 如下： 123456789101112131415&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;启动程序&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/app.js&quot;, &quot;skipFiles&quot;: [ &quot;$&#123;workspaceFolder&#125;/node_modules/**/*.js&quot;, &quot;&lt;node_internals&gt;/**/*.js&quot; ] &#125; ]&#125; 有以下几点需要解释： 支持 ${xxx} 这种变量替换。 支持 glob 模式匹配。 用来忽略 Node.js 核心模块。 重启调试后，如下所示： 可以看出：在左侧 ”调用堆栈“ 中，我们不关心的调用栈都变灰了，而且单步调试也不会进入到 skipFiles 所匹配的文件里。 4.3.5 技巧 3——自动重启在每次修改代码保存后都要手动重启，否则修改后的代码和断点都不会生效。VS Code 开发者们想到了这一点，通过添加配置可以实现修改代码保存后会自动重启调试，需要结合 nodemon 一起使用。 首先，全局安装 nodemon： 1$ npm i nodemon -g 然后，修改 launch.json： 123456789101112131415161718&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;启动程序&quot;, &quot;runtimeExecutable&quot;: &quot;nodemon&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/app.js&quot;, &quot;restart&quot;: true, &quot;console&quot;: &quot;integratedTerminal&quot;, &quot;skipFiles&quot;: [ &quot;$&#123;workspaceFolder&#125;/node_modules/**/*.js&quot;, &quot;&lt;node_internals&gt;/**/*.js&quot; ] &#125; ]&#125; 当前的 launch.json 相比较上一个版本的 launch.json，多了以下几个字段： runtimeExecutable：用什么命令执行 app.js，这里设置为 nodemon。 restart：设置为 true，修改代码并保存后会自动重启调试。 console：当单击停止按钮或者修改代码并保存后自动重启调试，而 nodemon 是仍然在运行的，通过设置为 console 为 integratedTerminal 可以解决这个问题。此时 VS Code 终端将会打印 nodemon 的 log，可以在终端右侧的下拉菜单中选择返回第 1 个终端，然后运行 curl localhost:3000 进行调试。 对于已经使用 nodemon 运行的程序，例如： 1$ nodemon --inspect app.js 可使用 attach 模式启动调试，launch.json 如下： 123456789101112&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Attach to node&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;restart&quot;: true, &quot;processId&quot;: &quot;$&#123;command:PickProcess&#125;&quot; &#125; ]&#125; 运行 Attach to node 配置进行调试时，VS Code 会列出正在执行的 node 进程及对应的 PID 以供选择。也可以通过 address 和 port 参数设置 attach 到具体的进程开启调试。 4.3.6 技巧 4——特定操作系统设置针对不同的操作系统，可能会用到不同的调试配置。可选的参数为： windows linux osx 示例如下： 123456789101112131415&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;启动调试&quot;, &quot;program&quot;: &quot;./node_modules/gulp/bin/gulpfile.js&quot;, &quot;args&quot;: [&quot;/path/to/app.js&quot;], &quot;windows&quot;: &#123; &quot;args&quot;: [&quot;\\\\path\\\\to\\\\app.js&quot;] &#125; &#125; ]&#125; 4.3.7 技巧 5——多配置configurations 是个数组而不是个对象，这样设计就是为了可以添加多个调试配置。打开 launch.json，单击右下角的 ”添加配置…“，会弹出配置模板，如下所示： configurations 可以用来配置不同的调试规则，比如最终将 launch.json 修改如下： 12345678910111213141516171819202122232425&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;name&quot;: &quot;Attach to node&quot;, &quot;restart&quot;: true, &quot;processId&quot;: &quot;$&#123;command:PickProcess&#125;&quot; &#125;, &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;启动程序&quot;, &quot;runtimeExecutable&quot;: &quot;nodemon&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/app.js&quot;, &quot;restart&quot;: true, &quot;console&quot;: &quot;integratedTerminal&quot;, &quot;skipFiles&quot;: [ &quot;$&#123;workspaceFolder&#125;/node_modules/**/*.js&quot;, &quot;&lt;node_internals&gt;/**/*.js&quot; ] &#125; ]&#125; 4.3.8 总结VS Code 的调试功能十分强大，本节只讲解了一些常用的调试功能，对于其余的调试功能，还请读者自行尝试。 4.3.9 参考链接 https://code.visualstudio.com/docs/editor/debugging https://code.visualstudio.com/docs/nodejs/nodejs-debugging","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 4.2 Chrome Devtools","slug":"4.2.1 使用 Chrome DevTools","date":"2019-07-22T06:00:00.000Z","updated":"2022-05-25T04:23:06.702Z","comments":true,"path":"2019/07/22/4.2.1 使用 Chrome DevTools/","link":"","permalink":"https://marvinliu1.github.io/2019/07/22/4.2.1%20%E4%BD%BF%E7%94%A8%20Chrome%20DevTools/","excerpt":"","text":"Node in Debugging 调试是每个程序员必备的技能，因此选择合适的调试工具能极大地方便我们调试代码。Node.js 的调试方式也有很多，常见的有： 万能的 console.log debugger node-inspector 以上本节都不会讲解，因为： console.log 就不用说了。 debugger 不推荐使用，因为： 使用繁琐，需手动打点。 若忘记删除 debugger，还会引起性能问题。 node-inspector 已经退出历史舞台。&#x6e;&#x6f;&#100;&#x65;&#64;&#54;&#46;&#51; 以后内置了一个调试器，可以结合 Chrome DevTools 使用，而且比 node-inspector 更强大。 下面就讲讲 Chrome DevTools 的用法。 4.2.1 使用 Chrome DevTools创建示例代码： app.js 12345678const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.use(ctx =&gt; &#123; ctx.body = &#x27;hello world!&#x27;&#125;)app.listen(3000) 运行： 1$ node --inspect app.js 注意：如果想让代码在第 1 行就暂停执行，需要使用 –inspect-brk 参数启动，即 node --inspect-brk app.js。 打开 Chrome 浏览器，访问 chrome:&#x2F;&#x2F;inspect，如下所示： 单击 Remote Target 下的 inspect，选择 Sources，如下所示： 使用方式与 node-inspector 类似，可以添加断点，然后在 Console 里面直接输入变量名来打印该变量的值。如下所示，在第 6 行添加断点，然后通过 curl localhost:3000?name=nswbmw，代码执行到第 6 行暂停执行，在 Console 里打印 ctx.query 的值： 小提示：将鼠标悬浮在某个变量上，也会显示它的值，例如：ctx。 展开右侧的 debugger 有更多的功能，例如单步执行、单步进入、单步退出等等，这里不再详细讲解。 4.2.2 NIM每次调试 Node.js 都要打开隐藏那么深的入口是不是很烦？还好我们有 NIM。NIM（Node Inspector Manager）是一个 Chrome 插件，可以帮助我们快捷地打开 DevTools，也可以设置自动发现并打开 DevTools。 4.2.3 inspect-process如果你觉得 NIM 用起来也麻烦，那你可能需要 inspect-process。 全局安装： 1$ npm i inspect-process -g 使用： 1$ inspect app.js inspect-process 会自动调起 Chrome DevTools，然后定位到 app.js，其余用法与 Chrome DevTools 一致。 4.2.4 process._debugProcess如果一个 Node.js 进程已经启动，没有添加 –inspect 参数，我们不想重启（会丢失现场）又想调试怎么办？这时可以用 process._debugProcess。使用方法如下： 通过 ps 命令或者 pgrep -n node 查看当前启动的 Node.js 进程的 pid，例如：53911。 打开新的终端，运行：node -e &quot;process._debugProcess(53911)&quot;，原来的 Node.js 进程会打印出：Debugger listening on ws:&#x2F;&#x2F;127.0.0.1:9229&#x2F;2331fa07-32af-45eb-a1a8-bead7a0ab905。 调出 Chrome DevTools 进行调试。 4.2.5 参考链接 https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Nohup stop running unexpected - solved","slug":"Nohup-exit","date":"2019-07-21T06:00:00.000Z","updated":"2022-05-25T05:05:54.636Z","comments":true,"path":"2019/07/21/Nohup-exit/","link":"","permalink":"https://marvinliu1.github.io/2019/07/21/Nohup-exit/","excerpt":"","text":"Today I have encounterd a weird issue with Nohup, my sh command is used as: 1nohup npm start 2&gt;/dev/null 1&gt;/dev/null&amp; But after I have closed the connection of my Putty, the npm thread was terminated. Finally, I have found the problem is with the session, to disconnect the Putty, I have to tpye in command exit, instead of closing the window directly, the exit command will leave the session running in background.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/categories/Hexo/"},{"name":"Linux","slug":"Hexo/Linux","permalink":"https://marvinliu1.github.io/categories/Hexo/Linux/"}],"tags":[{"name":"Nohup","slug":"Nohup","permalink":"https://marvinliu1.github.io/tags/Nohup/"},{"name":"Linux","slug":"Linux","permalink":"https://marvinliu1.github.io/tags/Linux/"}]},{"title":"Node in Debugging, 4.1 Source Map","slug":"4.1.1 什么是 Source Map？","date":"2019-07-18T06:00:00.000Z","updated":"2022-05-25T04:23:06.703Z","comments":true,"path":"2019/07/18/4.1.1 什么是 Source Map？/","link":"","permalink":"https://marvinliu1.github.io/2019/07/18/4.1.1%20%E4%BB%80%E4%B9%88%E6%98%AF%20Source%20Map%EF%BC%9F/","excerpt":"","text":"Node in Debugging 4.1.1 什么是 Source Map？对于 Source Map，想必大家并不陌生，在前端开发中通常要压缩 JavaScript，CSS，以减小体积，加快网页显示。但带来的后果是如果出现错误，就会导致无法定位错误，这时 Source Map 应运而生。举个例子， jQuery 1.9 引入了 Source Map，打开 http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js，最后一行是这样的： 1//@ sourceMappingURL=jquery.min.map 这就是 Source Map。它是一个独立的 map（其实就是 JSON） 文件，通常与源码在同一个目录下。 Source Map 常用于以下几个场景： 压缩代码，减小体积。比如 jQuery 1.9 的源码，压缩前是 252KB，压缩后是 32KB。 多个文件合并，减少 HTTP 请求数，仅用于前端。 将其他语言编译成 JavaScript，例如：CoffeeScript、TypeScript 等。 本节只讲解如何使用 Source Map，关于 map 文件中字段的含义本节不会解释，有兴趣的读者可以查看参考链接中的文章。接下来我们在 Node.js 环境下以场景 1、3 为例，分别介绍如何将 uglify-es 和 TypeScript 结合 Source Map 使用。 4.1.2 uglify-esuglify-js 是最常用的 JavaScript 代码压缩工具，但只支持到 ES5，uglify-es 支持 ES6+ 并且兼容 uglify-js，所以本节使用 uglify-es。 source-map-support 是一个在 Node.js 环境下支持 Source Map 的模块。 安装 uglify-es 和 source-map-support： 12$ npm i uglify-es -g$ npm i source-map-support 创建测试代码： app.js 12345678require(&#x27;source-map-support&#x27;).install()function sayHello (name) &#123; throw new Error(&#x27;error!!!&#x27;) console.log(`Hello, $&#123;name&#125;`)&#125;sayHello(&#x27;World&#x27;) 使用 uglify-es 压缩代码文件并生成 map 文件： 1$ uglifyjs app.js -o app.min.js --source-map &quot;url=app.min.js.map&quot; 生成 app.min.js 和 app.min.js.map 文件，内容分别如下： app.min.js 12require(&quot;source-map-support&quot;).install();function sayHello(name)&#123;throw new Error(&quot;error!!!&quot;);console.log(`Hello, $&#123;name&#125;`)&#125;sayHello(&quot;World&quot;);//# sourceMappingURL=app.min.js.map app.min.js.map 1&#123;&quot;version&quot;:3,&quot;sources&quot;:[&quot;app.js&quot;],&quot;names&quot;:[&quot;require&quot;,&quot;install&quot;,&quot;sayHello&quot;,&quot;name&quot;,&quot;Error&quot;,&quot;console&quot;,&quot;log&quot;],&quot;mappings&quot;:&quot;AAAAA,QAAQ,sBAAsBC,UAE9B,SAASC,SAAUC,MACjB,MAAM,IAAIC,MAAM,YAChBC,QAAQC,cAAcH,QAGxBD,SAAS&quot;&#125; 此时运行 app.min.js 可以显示正确的错误栈： 1234567$ node app.min.js/Users/nswbmw/Desktop/test/app.js:4 throw new Error(&#x27;error!!!&#x27;) ^Error: error!!! at sayHello (/Users/nswbmw/Desktop/test/app.js:4:9) 如果删除 app.min.js 最后那行注释，重新运行则无法显示正确的错误栈： 1234567$ node app.min.js/Users/nswbmw/Desktop/test/app.min.js:1require(&quot;source-map-support&quot;).install();function sayHello(name)&#123;throw new Error(&quot;error!!!&quot;);console.log(`Hello, $&#123;name&#125;`)&#125;sayHello(&quot;World&quot;); ^Error: error!!! at sayHello (/Users/nswbmw/Desktop/test/app.min.js:1:71) source-map-support 是通过 Error.prepareStackTrace 实现的，前面讲解过它的用法，这里不再赘述。 4.1.3 TypeScript全局安装 TypeScript： 1$ npm i typescript -g 创建测试代码： app_ts.ts 12345678declare function require(name: string)require(&#x27;source-map-support&#x27;).install()function sayHello (name: string): any &#123; throw new Error(&#x27;error!!!&#x27;)&#125;sayHello(&#x27;World&#x27;) 运行： 1$ tsc --sourceMap app_ts.ts 生成 app_ts.js 和 app_ts.js.map，运行 app_ts.js 如下： 1234567$ node app_ts.js/Users/nswbmw/Desktop/test/app_ts.ts:5 throw new Error(&#x27;error!!!&#x27;) ^Error: error!!! at sayHello (/Users/nswbmw/Desktop/test/app_ts.ts:5:9) 4.1.4 source-map-support 高级用法我们可以在调用 install 方法时传入一个 retrieveSourceMap 参数，用来自定义处理 Source Map： 1234567891011require(&#x27;source-map-support&#x27;).install(&#123; retrieveSourceMap: function(source) &#123; if (source === &#x27;compiled.js&#x27;) &#123; return &#123; url: &#x27;original.js&#x27;, map: fs.readFileSync(&#x27;compiled.js.map&#x27;, &#x27;utf8&#x27;) &#125; &#125; return null &#125;&#125;) 比如将所有 map 文件缓存到内存中，而不是磁盘上。 4.1.5 参考链接 http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html https://yq.aliyun.com/articles/73529 https://github.com/v8/v8/wiki/Stack-Trace-API https://github.com/evanw/node-source-map-support","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Adding Tag-Cloud","slug":"Adding-tag-cloud","date":"2019-06-21T06:26:30.000Z","updated":"2022-05-25T04:33:16.035Z","comments":true,"path":"2019/06/21/Adding-tag-cloud/","link":"","permalink":"https://marvinliu1.github.io/2019/06/21/Adding-tag-cloud/","excerpt":"","text":"Step 1: Install the plugin hexo-tag-cloud1npm install hexo-tag-cloud@^2.0.* --save Step 2: ConfigurationFor the SwigLocate the file bash theme/next/layout/_macro/sidebar.swig 123456789101112&#123;% if site.tags.length &gt; 1 %&#125;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;&lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;标签云&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &#123;&#123; list_tags() &#125;&#125; &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; For the ejsLocated the file bash hexo/themes/landscape/layout/_widget/tagcloud.ejs 12345678910111213&lt;% if (site.tags.length) &#123; %&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt; &lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &lt;%- tagcloud() %&gt; &lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt; For the jadeLocate the file bash apollo/layout/archive.jade 123456789101112block container include mixins/post .archive h2(class=&#x27;archive-year&#x27;)= &#x27;Tag Cloud&#x27; script(type=&#x27;text/javascript&#x27;, charset=&#x27;utf-8&#x27;, src=&#x27;/oj-code/js/tagcloud.js&#x27;) script(type=&#x27;text/javascript&#x27;, charset=&#x27;utf-8&#x27;, src=&#x27;/oj-code/js/tagcanvas.js&#x27;) #myCanvasContainer.widget.tagcloud(align=&#x27;center&#x27;) canvas#resCanvas(width=&#x27;500&#x27;, height=&#x27;500&#x27;, style=&#x27;width=100%&#x27;) !=tagcloud() !=tagcloud() +postList() Step 3: Config the themeLocate the config file in your theme folder bash _config.yml Adding new lines below in the end of the config file 1234567# hexo-tag-cloudtag_cloud: textFont: Trebuchet MS, Helvetica textColor: &#x27;#333&#x27; textHeight: 25 outlineColor: &#x27;#E2E1D1&#x27; maxSpeed: 0.1","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/tags/Hexo/"},{"name":"NeXt","slug":"NeXt","permalink":"https://marvinliu1.github.io/tags/NeXt/"}]},{"title":"Node in Debugging, 3.7 UncaughtException","slug":"3.7.1 uncaughtException","date":"2019-06-20T06:00:00.000Z","updated":"2022-05-25T04:23:06.703Z","comments":true,"path":"2019/06/20/3.7.1 uncaughtException/","link":"","permalink":"https://marvinliu1.github.io/2019/06/20/3.7.1%20uncaughtException/","excerpt":"","text":"Node in Debugging 相信所有 Node.js 开发者都对 TypeError: Cannot read property &#39;xxx&#39; of undefined/null 这种错误并不陌生，这是因为期望从一个对象上获取 xxx 属性，结果这个对象的值是 undefined 或者 null。 3.7.1 uncaughtException看一段代码： 1234const article = &#123; title: &#x27;Node.js&#x27;, content: &#x27;Hello, Node.js&#x27; &#125;setImmediate(() =&gt; &#123; console.log(article.author.name)&#125;) 运行以上代码打印出： 12345678/Users/nswbmw/Desktop/test/app.js:3 console.log(article.author.name) ^TypeError: Cannot read property &#x27;name&#x27; of undefined at Timeout.setInterval [as _onTimeout] (/Users/nswbmw/Desktop/test/app.js:3:30) at ontimeout (timers.js:475:11) at tryOnTimeout (timers.js:310:5) at Timer.listOnTimeout (timers.js:270:5) article 是一个文章对象有 title 和 content 属性，没有 author 属性，所以 article.author 是 undefined，调用 article.author.name 会报错。而且这个运行时错误是在一个异步函数（setImmediate）内抛出的，所以这个错误是一个 “uncaught exception”，如果没有 process.on(‘uncaughtException’, () &#x3D;&gt; {}) 事件监听器的话程序会 crash。 调试这种错误没有比较好的方法，通常只能添加 console.log 打印出 article 的值。但是我们前面介绍过 llnode 的用法，是否可以使用 llnode 调试这类问题呢？答案是肯定的。 3.7.2 llnode我们添加 –abort-on-uncaught-exception 参数重新运行程序，当程序 crash 的时候，会自动 Core Dump。 12345678910$ ulimit -c unlimited$ node --abort-on-uncaught-exception app.jsUncaught TypeError: Cannot read property &#x27;name&#x27; of undefinedFROMImmediate.setImmediate (/home/nswbmw/test/app.js:1:1)runCallback (timers.js:1:1)tryOnImmediate (timers.js:1:1)processImmediate [as _immediateCallback] (timers.js:1:1)Illegal instruction (core dumped) 此时生成一个 core 文件，我们使用 llnode 加载并诊断这个 core 文件。 1234$ lldb-4.0 -c ./core(lldb) target create --core &quot;./core&quot;Core file &#x27;/home/nswbmw/test/./core&#x27; (x86_64) was loaded.(lldb) 使用 v8 bt 查看最近的 backtrace。 12345678910(lldb) v8 bt * thread #1: tid = 4750, 0x00007ffd905d5b39 node`v8::base::OS::Abort() + 9, name = &#x27;node&#x27;, stop reason = signal SIGILL * frame #0: 0x00007ffd905d5b39 node`v8::base::OS::Abort() + 9 frame #1: 0x00007ffd900a4d19 node`v8::internal::Isolate::Throw(v8::internal::Object*, v8::internal::MessageLocation*) + 489 frame #2: 0x00007ffd9005e7f9 node`v8::internal::LoadIC::Load(v8::internal::Handle&lt;v8::internal::Object&gt;, v8::internal::Handle&lt;v8::internal::Name&gt;) + 569 frame #3: 0x00007ffd9005f759 node`v8::internal::Runtime_LoadIC_Miss(int, v8::internal::Object**, v8::internal::Isolate*) + 633 frame #4: 0x000018e6e710463d &lt;exit&gt; frame #5: 0x000018e6e71ecce4 &lt;stub&gt; frame #6: 0x000018e6e71bf9ce setImmediate(this=0x0000154a3ae09429:&lt;Object: Immediate&gt;) at /home/nswbmw/test/app.js:2:14 fn=0x0000154a3ae09281 ... 可以看出：在 frame #4 处程序触发 exit，往上追溯到 frame #6 有一个 setImmediate 抛出了错误，在 app.js 第 2 行，符合打印出的错误信息。setImmediate 的回调函数的地址为 0x0000154a3ae09281，我们使用 v8 i 检索这个函数。 12345678910(lldb) v8 i 0x0000154a3ae092810x0000154a3ae09281:&lt;function: setImmediate at /home/nswbmw/test/app.js:2:14 context=0x0000154a3ae09199&#123; (previous)=0x000017849b703d89 (closure)=0x0000154a3ae08d81 &#123;&lt;function: (anonymous) at /home/nswbmw/test/app.js:1:10&gt;&#125;, article=0x0000154a3ae091d1:&lt;Object: Object&gt;&#125;&gt;(lldb) v8 i 0x0000154a3ae091d10x0000154a3ae091d1:&lt;Object: Object properties &#123; .title=0x000014117e04c9e9:&lt;String: &quot;Node.js&quot;&gt;, .content=0x000014117e04ca09:&lt;String: &quot;Hello, Node.js&quot;&gt;&#125;&gt; setImmediate 函数内有一个 article 对象，然后我们继续通过 v8 i 检索得知 article 的值为 { title: “Node.js”, content: “Hello, Node.js” }，并没有 author 属性，真相大白。 3.7.3 ReDoSDoS（Denial of Service）全称是拒绝服务攻击，ReDoS（RegExp Denial of Service）即是正则表达式拒绝服务攻击。ReDoS 是由于正则表达式写得有缺陷，所以使用正则匹配时，会出现大量占用 CPU 的情况，导致服务不可用，而导致正则表达式匹配 “卡住” 的原因正是正则表达式的 “回溯” 特性。 看一个简单的例子： 1/a.*b/g.test(&#x27;aaaf&#x27;) 匹配过程如下： 可以看出：因为 * 是贪婪匹配，所以第 3 步 .* 匹配了字符串末尾，由于剩下一个 b 无法匹配所以 “吐” 出一个字符再尝试匹配（第 4 步），仍然不匹配（第 5 步），继续 “吐” 出一个字符…这个 “吐” 一个字符的过程就是回溯（backtrack）。 再看个例子： 1234567const reg = /(a*)+b/console.time(&#x27;reg&#x27;)reg.test(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaf&#x27;) // reg: 2572.022ms// reg.test(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaf&#x27;) // reg: 5048.735ms// reg.test(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaf&#x27;) // reg: 10710.070msconsole.timeEnd(&#x27;reg&#x27;) 运行以上代码，每添加一个字母 a，程序的运行时间就翻倍，这正是由于正则表达式的回溯导致的，这个正则表达式的时间复杂度为 O(2^n)。 平时写出具有回溯的正则表达式是比较常见的，这个时候程序会 “卡住”，使用 llnode 也可以调试这类问题。 运行以下代码： 123$ echo &quot;/(a*)+b/.test(&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaf&#x27;)&quot; &gt; app.js$ node --abort-on-uncaught-exception app.js &amp;$ kill -BUS `pgrep -n node` 生成 core 文件，使用 llnode 调试。 123456789101112$ lldb-4.0 -c ./core(lldb) target create --core &quot;./core&quot;Core file &#x27;/home/nswbmw/test/./core&#x27; (x86_64) was loaded.(lldb) v8 bt * thread #1: tid = 5381, 0x000036a6db804f6b, name = &#x27;node&#x27;, stop reason = signal SIGBUS * frame #0: 0x000036a6db804f6b &lt;builtin&gt; ... frame #6: 0x000036a6db68463d &lt;exit&gt; frame #7: 0x000036a6db7135f4 test(this=0x0000038344709119:&lt;JSRegExp source=/(a*)+b/&gt;, 0x0000098ccdb4c9e9:&lt;String: &quot;aaaaaaaaaaaaaaaa...&quot;&gt;) at (no script) fn=0x0000183ca0c134a1 ...(lldb) v8 i -F 0x0000098ccdb4c9e90x0000098ccdb4c9e9:&lt;String: &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaf&quot;&gt; 可以看出：在程序退出前，程序在执行一个正则表达式（/(a*)+b/）的 test 方法，参数是字符串(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaf)。 减少正则表达式回溯的简单方法就是合并不必要的量词，如将上面的正则表达式 /(a*)+b/ 修改为 /a*b/。 3.7.4 参考链接 https://www.rawidn.com/posts/ddos-and-ddos-in-regular-expression.html","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 3.6 What is event loop?","slug":"3.6.1 什么是 Event Loop？","date":"2019-05-28T06:00:00.000Z","updated":"2022-05-25T04:23:06.983Z","comments":true,"path":"2019/05/28/3.6.1 什么是 Event Loop？/","link":"","permalink":"https://marvinliu1.github.io/2019/05/28/3.6.1%20%E4%BB%80%E4%B9%88%E6%98%AF%20Event%20Loop%EF%BC%9F/","excerpt":"","text":"Node in Debugging 事件循环（Event Loop）是 Node.js 最核心的概念，所以理解 Event Loop 如何运作对于写出正确的代码和调试是非常重要的。比如考虑以下代码： 1234setTimeout(() =&gt; &#123; console.log(&#x27;hi&#x27;)&#125;, 1000)... 我们期望程序运行 1s 后打印出 hi，但是实际情况可能是远大于 1s 后才打印出 hi。这个时候如果理解 Event Loop 就可以轻易发现问题，否则任凭怎么调试都是发现不了问题的。 3.6.1 什么是 Event Loop？Event Loop 可以简单理解为： 所有任务都在主线程上执行，形成一个执行栈（Execution Context Stack）。 主线程之外，还存在一个 “任务队列”（Task Queue）。系统把异步任务放到 “任务队列” 之中，然后主线程继续执行后续的任务。 一旦 “执行栈” 中的所有任务执行完毕，系统就会读取 “任务队列”。如果这个时候，异步任务已经结束了等待状态，就会从 “任务队列” 进入执行栈，恢复执行。 主线程不断重复上面的第三步。 小提示：我们常说 Node.js 是单线程的，但为何能达到高并发呢？原因就在于底层的 Libuv 维护一个 I&#x2F;O 线程池（即上述的 “任务队列”），结合 Node.js 异步 I&#x2F;O 的特性，单线程也能达到高并发啦。 上面提到了 “读取任务队列”，这样讲有点笼统，其实 Event Loop 的 “读取任务队列” 有 6 个阶段，如下所示： 123456789101112131415161718 ┌───────────────────────┐┌─&gt;│ timers ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ I/O callbacks ││ └──────────┬────────────┘│ ┌──────────┴────────────┐│ │ idle, prepare ││ └──────────┬────────────┘ ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └──────────┬────────────┘ │ data, etc. ││ ┌──────────┴────────────┐ └───────────────┘│ │ check ││ └──────────┬────────────┘│ ┌──────────┴────────────┐└──┤ close callbacks │ └───────────────────────┘ 每个阶段都有一个 FIFO 的回调队列（queue），当 Event Loop 执行到这个阶段时，会从当前阶段的队列里拿出一个任务放到栈中执行，当队列任务清空，或者执行的回调数量达到上限后，Event Loop 会进入下个阶段。 每个阶段（phase）的作用： timers：执行 setTimeout() 和 setInterval() 中到期的 callback。 I&#x2F;O callbacks：上一轮循环中有少数的 I&#x2F;O callback 会被延迟到这一轮的这一阶段执行。 idle, prepare：仅内部使用。 poll：最重要的阶段，执行 I&#x2F;O callback，在适当的条件下 node 会阻塞在这个阶段。 check：执行 setImmediate() 的 callback。 close callbacks：执行 close 事件的 callback，例如 socket.on(‘close’,func)。 3.6.2 poll 阶段poll 阶段主要有两个功能： 当 timers 的定时器到期后，执行定时器（setTimeout 和 setInterval）的 callback。 执行 poll 队列里面的 I&#x2F;O callback。 如果 Event Loop 进入了 poll 阶段，且代码未设定 timer，可能发生以下情况： 如果 poll queue 不为空，Event Loop 将同步的执行 queue 里的 callback，直至 queue 为空，或者执行的 callback 到达系统上限。 如果 poll queue 为空，可能发生以下情况： 如果代码使用 setImmediate() 设定了 callback，Event Loop 将结束 poll 阶段进入 check 阶段，并执行 check 阶段的 queue。 如果代码没有使用 setImmediate()，Event Loop 将阻塞在该阶段等待 callbacks 加入 poll queue，如果有 callback 进来则立即执行。 一旦 poll queue 为空，Event Loop 将检查 timers，如果有 timer 的时间到期，Event Loop 将回到 timers 阶段，然后执行 timer queue。 3.6.3 process.nextTick()上面的 6 个阶段并没有出现 process.nextTick()，process.nextTick() 不在 Event Loop 的任何阶段执行，而是在各个阶段切换的中间执行，即从一个阶段切换到下个阶段前执行。这里还需要提一下 macrotask 和 microtask 的概念，macrotask（宏任务）指 Event Loop 每个阶段执行的任务，microtask（微任务）指每个阶段之间执行的任务。即上述 6 个阶段都属于 macrotask，process.nextTick() 属于 microtask。 小提示：process.nextTick() 的实现和 v8 的 microtask 并无关系，是 Node.js 层面的东西，应该说 process.nextTick() 的行为接近为 microtask。Promise.then 也属于 microtask 的一种。 最后，放出一张关于 Event Loop 非常直观的图： 绿色小块表示 Event Loop 的各个阶段，执行的是 macrotask，macrotask 中间的粉红箭头表示执行的是 microtask。 3.6.4 六道题下面我们以六道题巩固一下前面讲到的 Event Loop 的知识。 题目一1234567setTimeout(() =&gt; &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate&#x27;)&#125;) 运行结果： 12setImmediatesetTimeout 或者： 12setTimeoutsetImmediate 为什么结果不确定呢？ 解释：setTimeout&#x2F;setInterval 的第 2 个参数取值范围是：[1, 2^31 - 1]，如果超过这个范围则会初始化为 1，即 setTimeout(fn, 0) &#x3D;&#x3D;&#x3D; setTimeout(fn, 1)。我们知道 setTimeout 的回调函数在 timer 阶段执行，setImmediate 的回调函数在 check 阶段执行，event loop 的开始会先检查 timer 阶段，但是在开始之前到 timer 阶段会消耗一定时间，所以就会出现两种情况： timer 前的准备时间超过 1ms，满足 loop-&gt;time &gt;&#x3D; 1，则执行 timer 阶段（setTimeout）的回调函数。 timer 前的准备时间小于 1ms，则先执行 check 阶段（setImmediate）的回调函数，下一次 event loop 执行 timer 阶段（setTimeout）的回调函数。 再看个例子： 12345678910setTimeout(() =&gt; &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate&#x27;)&#125;)const start = Date.now()while (Date.now() - start &lt; 10); 运行结果一定是： 12setTimeoutsetImmediate 题目二1234567891011const fs = require(&#x27;fs&#x27;)fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;setTimeout&#x27;) &#125;, 0) setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate&#x27;) &#125;)&#125;) 运行结果： 12setImmediatesetTimeout 解释：fs.readFile 的回调函数执行完后： 注册 setTimeout 的回调函数到 timer 阶段。 注册 setImmediate 的回调函数到 check 阶段。 event loop 从 pool 阶段出来继续往下一个阶段执行，恰好是 check 阶段，所以 setImmediate 的回调函数先执行。 本次 event loop 结束后，进入下一次 event loop，执行 setTimeout 的回调函数。 所以，在 I&#x2F;O Callbacks 中注册的 setTimeout 和 setImmediate，永远都是 setImmediate 先执行。 题目三1234567setInterval(() =&gt; &#123; console.log(&#x27;setInterval&#x27;)&#125;, 100)process.nextTick(function tick () &#123; process.nextTick(tick)&#125;) 运行结果：setInterval 永远不会打印出来。 解释：process.nextTick 会无限循环，将 event loop 阻塞在 microtask 阶段，导致 event loop 上其他 macrotask 阶段的回调函数没有机会执行。 解决方法通常是用 setImmediate 替代 process.nextTick，如下： 1234567setInterval(() =&gt; &#123; console.log(&#x27;setInterval&#x27;)&#125;, 100)setImmediate(function immediate () &#123; setImmediate(immediate)&#125;) 运行结果：每 100ms 打印一次 setInterval。 解释：process.nextTick 内执行 process.nextTick 仍然将 tick 函数注册到当前 microtask 的尾部，所以导致 microtask 永远执行不完； setImmediate 内执行 setImmediate 会将 immediate 函数注册到下一次 event loop 的 check 阶段，而不是当前正在执行的 check 阶段，所以给了 event loop 上其他 macrotask 执行的机会。 再看个例子： 12345678910111213setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate1&#x27;) setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate2&#x27;) &#125;) process.nextTick(() =&gt; &#123; console.log(&#x27;nextTick&#x27;) &#125;)&#125;)setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate3&#x27;)&#125;) 运行结果： 1234setImmediate1setImmediate3nextTicksetImmediate2 注意：并不是说 setImmediate 可以完全代替 process.nextTick，process.nextTick 在特定场景下还是无法被代替的，比如我们就想将一些操作放到最近的 microtask 里执行。 题目四12345const promise = Promise.resolve() .then(() =&gt; &#123; return promise &#125;)promise.catch(console.error) 运行结果： 123456TypeError: Chaining cycle detected for promise #&lt;Promise&gt; at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:188:7) at Function.Module.runMain (module.js:667:11) at startup (bootstrap_node.js:187:16) at bootstrap_node.js:607:3 解释：Promise A+ 的规范里规定 promise 不能返回自己。仔细想想，即使规范里不规定，promise.then 类似于 process.nextTick，都会将回调函数注册到 microtask 阶段。上面代码也会导致死循环，类似前面提到的： 123process.nextTick(function tick () &#123; process.nextTick(tick)&#125;) 再看个例子： 123456789const promise = Promise.resolve()promise.then(() =&gt; &#123; console.log(&#x27;promise&#x27;)&#125;)process.nextTick(() =&gt; &#123; console.log(&#x27;nextTick&#x27;)&#125;) 运行结果： 12nextTickpromise 解释：promise.then 虽然和 process.nextTick 一样，都将回调函数注册到 microtask，但优先级不一样。process.nextTick 的 microtask queue 总是优先于 promise 的 microtask queue 执行。 题目五12345678910111213setTimeout(() =&gt; &#123; console.log(1)&#125;, 0)new Promise((resolve, reject) =&gt; &#123; console.log(2) for (let i = 0; i &lt; 10000; i++) &#123; i === 9999 &amp;&amp; resolve() &#125; console.log(3)&#125;).then(() =&gt; &#123; console.log(4)&#125;)console.log(5) 运行结果： 1234523541 解释：Promise 构造函数是同步执行的，所以先打印 2、3，然后打印 5，接下来 event loop 进入执行 microtask 阶段，执行 promise.then 的回调函数打印出 4，然后执行下一个 macrotask，恰好是 timer 阶段的 setTimeout 的回调函数，打印出 1。 题目六12345678910111213141516171819202122232425setImmediate(() =&gt; &#123; console.log(1) setTimeout(() =&gt; &#123; console.log(2) &#125;, 100) setImmediate(() =&gt; &#123; console.log(3) &#125;) process.nextTick(() =&gt; &#123; console.log(4) &#125;)&#125;)process.nextTick(() =&gt; &#123; console.log(5) setTimeout(() =&gt; &#123; console.log(6) &#125;, 100) setImmediate(() =&gt; &#123; console.log(7) &#125;) process.nextTick(() =&gt; &#123; console.log(8) &#125;)&#125;)console.log(9) 运行结果： 123456789958174362 process.nextTick、setTimeout 和 setImmediate 的组合，请读者自行推理吧。 3.6.5 参考链接 https://cnodejs.org/topic/57d68794cb6f605d360105bf https://cnodejs.org/topic/5a9108d78d6e16e56bb80882 https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/ https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Nuxt.js Tutorial","slug":"Nuxtjs 基础入门教程","date":"2019-05-21T06:12:31.000Z","updated":"2022-05-25T04:06:27.954Z","comments":true,"path":"2019/05/21/Nuxtjs 基础入门教程/","link":"","permalink":"https://marvinliu1.github.io/2019/05/21/Nuxtjs%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"原文链接 Vue 开发一个单页面应用，相信很多前端工程师都已经学会了，但是单页面应用有一个致命的缺点，就是 SEO 极不友好。除非，vue 能在服务端渲染（ssr）并直接返回已经渲染好的页面，而并非只是一个单纯的 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;。 Nuxt.js 就是一个极简的 vue 版的 ssr 框架。基于它，我们可以快速开发一个基于 vue 的 ssr 单页面应用。 安装Nuxt.js 官方提供了一个模板，可以使用 vue-cli 直接安装。 1$ vue init nuxt-community/starter-template &lt;project-name&gt; 目录结构1234567891011121314.├── README.md├── assets├── components├── layouts├── middleware├── node_modules├── nuxt.config.js├── package.json├── pages├── plugins├── static├── store└── yarn.lock 其中： assets: 资源文件。放置需要经过 webpack 打包处理的资源文件，如 scss，图片，字体等。 components: 组件。这里存放在页面中，可以复用的组件。 layouts: 布局。页面都需要有一个布局，默认为 default。它规定了一个页面如何布局页面。所有页面都会加载在布局页面中的 &lt;nuxt /&gt; 标签中。如果需要在普通页面中使用下级路由，则需要在页面中添加 &lt;nuxt-child /&gt;。该目录名为Nuxt.js保留的，不可更改。 middleware: 中间件。存放中间件。可以在页面中调用： middleware: &#39;middlewareName&#39; 。 pages: 页面。一个 vue 文件即为一个页面。index.vue 为根页面。 若需要二级页面，则添加文件夹即可。 如果页面的名称类似于 _id.vue （以 _ 开头），则为动态路由页面，_ 后为匹配的变量（params）。 若变量是必须的，则在文件夹下建立空文件 index.vue。更多的配置请移步至 官网 。 plugin: 插件。用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。需要注意的是，在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个钩子方法会在 *客户端和服务端均被调用*。其他钩子方法仅在客户端被调用。 static: 静态文件。放置不需要经过 webpack 打包的静态资源。如一些 js, css 库。 store: 状态管理。具体使用请移步至 官网。 nuxt.config.js: nuxt.config.js 文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。具体配置请移步至 官网。 Nuxt 特有函数首先，了解一下在 nuxt 的页面中独有的函数&#x2F;变量： asyncData(context)asyncData方法使得你能够在渲染组件之前异步获取数据。该方法在服务端中执行的，所以，请求数据时，不存在跨域问题。返回的数据将与 data() 返回的数据进行合并。由于asyncData方法是在组件 *初始化* 前被调用的，所以在方法内是没有办法通过 this 来引用组件的实例对象。 context 变量的可用属性一览： 属性字段 类型 可用 描述 isClient Boolean 客户端 &amp; 服务端 是否来自客户端渲染 isServer Boolean 客户端 &amp; 服务端 是否来自服务端渲染 isDev Boolean 客户端 &amp; 服务端 是否是开发(dev) 模式，在生产环境的数据缓存中用到 route vue-router 路由 客户端 &amp; 服务端 vue-router 路由实例。 store vuex 数据流 客户端 &amp; 服务端 Vuex.Store 实例。只有vuex 数据流存在相关配置时可用。 env Object 客户端 &amp; 服务端 nuxt.config.js 中配置的环境变量, 见 环境变量 api params Object 客户端 &amp; 服务端 route.params 的别名 query Object 客户端 &amp; 服务端 route.query 的别名 req http.Request 服务端 Node.js API 的 Request 对象。如果 nuxt 以中间件形式使用的话，这个对象就根据你所使用的框架而定。nuxt generate 不可用。 res http.Response 服务端 Node.js API 的 Response 对象。如果 nuxt 以中间件形式使用的话，这个对象就根据你所使用的框架而定。nuxt generate 不可用。 redirect Function 客户端 &amp; 服务端 用这个方法重定向用户请求到另一个路由。状态码在服务端被使用，默认 302。redirect([status,] path [, query]) error Function 客户端 &amp; 服务端 用这个方法展示错误页：error(params)。params 参数应该包含 statusCode 和 message 字段。 fetch(context)fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据。为了让获取过程可以异步，你需要返回一个 Promise，Nuxt.js 会等这个 promise 完成后再渲染组件。 fetch 会在组件每次加载前被调用（在服务端或切换至目标路由之前）。 headNuxt.js 使用了 vue-meta 更新应用的 头部标签(Head) 和 html 属性。 用于更新 头部信息。如 title，descripe 等。在 head 方法里可通过 this 关键字来获取组件的数据。 layout指定该页面使用哪个布局文件。默认值为 default。 middleware需要执行的中间件，如鉴权的 auth等。 transition指定页面切换时的动画效果。支持传入 String, Object, Function。具体配置请移步至 官网 。 validateNuxt.js 可以让你在动态路由对应的页面组件中配置一个校验方法用于校验动态路由参数的有效性。 返回 true 说明路由有效，则进入路由页面。返回不是 true 则显示 404 页面。 Begin Coding前置工作API在这里，我们使用 CNode API 进行开发 Demo. axios请求数据，我们使用 Nuxt 官方提供的 @nuxtjs&#x2F;axios 安装后，在 nuxt.config.js 中加上： 1234567891011export default &#123; ... modules: [ &#x27;@nuxtjs/axios&#x27; ], axios: &#123; baseURL: &#x27;https://cnodejs.org/api/v1&#x27;, // or other axios configs. &#125; ...&#125; 就可以在页面中通过 this.$axios.$get 来获取数据，不需要在每个页面都单独引入 axios. scss需要先安装 sass-loader 和 node-sass 1$ yarn add sass-loader node-sass --dev 如果需要在项目中全局使用某个 scss 文件（如 mixins, vars 等），需要借助 sass-resources-loader : yarn add sass-resources-loader —dev， 还需要在 nuxt.config.js 的 build 配置中调整导出的 loader 配置： 123456789101112131415161718192021222324252627export default &#123; ... build: &#123; extend(config, &#123; isDev, isClient &#125;) &#123; const sassResourcesLoader = &#123; loader: &#x27;sass-resources-loader&#x27;, options: &#123; resources: [ // 填写需要全局注入 scss 的文件。引入后，所有页面均有效。 &#x27;assets/styles/mixins.scss&#x27; ] &#125; &#125; // 修改 scss sass 引用的 loader。 config.module.rules.forEach((rule) =&gt; &#123; if (rule.test.toString() === &#x27;/\\\\.vue$/&#x27;) &#123; rule.options.loaders.sass.push(sassResourcesLoader) rule.options.loaders.scss.push(sassResourcesLoader) &#125; if ([&#x27;/\\\\.sass$/&#x27;, &#x27;/\\\\.scss$/&#x27;].indexOf(rule.test.toString()) !== -1) &#123; rule.use.push(sassResourcesLoader) &#125; &#125;) &#125; &#125; ...&#125; 首页首页一般只需要简单的获取首页数据并渲染即可。 主要 代码： 123456789asyncData(&#123;app, query&#125;) &#123; console.log(query) // 根据不用的标签获取不同的数据，最后返回话题列表。 return app.$axios.$get(`topics?tab=$&#123;query.tab || &#x27;&#x27;&#125;`).then(res =&gt; &#123; // console.log(res) // console.log(JSON.parse(res)) return &#123;list: res.data&#125; &#125;)&#125; 当进入首页时，该函数会被执行， nuxt 会等到获取数据后再和组件的 data 合并，进而渲染数据。在模板中，可以直接使用 list 变量获取数据。 123456789101112131415&lt;div class=&quot;card fluid topic&quot; v-for=&quot;topic in list&quot; :key=&quot;topic.id&quot; &gt; &lt;div class=&quot;section&quot;&gt; &lt;h3&gt;&lt;nuxt-link :to=&quot;&#123;name: &#x27;topic-id&#x27;, params: &#123;id: topic.id&#125;&#125;&quot; class=&quot;topic-title&quot;&gt;&#123;&#123;topic.title&#125;&#125;&lt;/nuxt-link&gt;&lt;/h3&gt; &lt;p class=&quot;topic-info&quot;&gt; &lt;mark v-if=&quot;topic.top&quot; class=&quot;tertiary&quot;&gt;精华&lt;/mark&gt; &lt;mark v-else&gt;&#123;&#123;tabsObj[topic.tab]&#125;&#125;&lt;/mark&gt; &lt;span class=&quot;avatar&quot;&gt; &lt;img :src=&quot;topic.author.avatar_url&quot; alt=&quot;&quot;&gt; &lt;/span&gt; &lt;span class=&quot;username&quot;&gt; &#123;&#123;topic.author.loginname&#125;&#125; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 在这里提及一下， &lt;nuxt-link /&gt; 和 &lt;a /&gt; 的区别是： nuxt-link 走的是 vue-router 的路由，即网页已为单页面，并且浏览器不会重定向。而 a 标签走的是 window.location.href，每一次点击 a 标签后的页面，都会进行一次服务端渲染，和普通的 PHP 混合开发没有太大的区别。 在这里使用了 nuxt-link 是因为 CNode 的 API 不存在跨域问题，因此可以作为一个单页面应用，体验更好。 因为列表页数据类型有多种，该页面可能会被复用，所以当路由对象发生变化时，需要重新获取数据，这时可以监听路由的变化以做出响应： 123456watch: &#123; &#x27;$route&#x27;: function() &#123; console.log(&#x27;$route has changed.&#x27;) this.getData() &#125;&#125; 配置 seo 优化（这里只是单纯的复制罢了，demo 使用，侵删）： 12345678910head() &#123; return &#123; title: &#x27;首页&#x27; + (this.$route.query.tab ? `- $&#123;this.tabsObj[this.$route.query.tab]&#125;` : &#x27;&#x27;), meta: [&#123; hid: &#x27;description&#x27;, name: &#x27;description&#x27;, content: &#x27;CNode：Node.js专业中文社区&#x27; &#125;] &#125;&#125; 话题详情同样的，使用 asyncData 函数进行获取数据，再渲染页面。 12345678910111213141516asyncData(&#123;app, params&#125;) &#123; console.log(params) return app.$axios.$get(&#x27;topic/&#x27; + params.id).then(res =&gt; &#123; // let data = res.data instanceof String ? JSON.parse(res.data) : res.data let data = res.data // console.log(res) // let div = document.createElement(&#x27;div&#x27;) // div.innerHTML = res.data.data.content // res.data.summary = div.innerText.substr(0, 120) data.summary = data.content.replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;).substr(0, 120).replace(/\\s+/g, &#x27;&#x27;) return &#123;detail: data&#125; &#125;).catch(err =&gt; &#123; console.log(&#x27;axios.get failed.&#x27;) console.error(err) &#125;)&#125; 在这里，踩过坑。想使用 div 的 innerText 来过滤掉正文中的 HTML 标签，但是，如果用户是直接进入这个页面的时候，执行 asyncData 时，document 对象是不存在的，从而会报错。也就是说，当 asyncData 在服务端执行时，是没有 document 和 window 对象的，请大家注意一下。 作为一个社区，seo 尤为重要，倘若每个页面都需要写一大堆的 head 对象，就会显得尤其的繁琐。所以可以借助 nuxt 的 plugin 机制，将其封装成一个函数，并注入到每一个页面当中： 123456789101112131415161718// plugins/global.jsimport Vue from &#x27;vue&#x27;Vue.mixin(&#123; methods: &#123; // 必传 标题，描述。其他的 meta 标签通过 payload 注入，其中，每个 meta 的 hid 需要是唯一的。 $seo(title, content, payload = []) &#123; return &#123; title, meta: [&#123; hid: &#x27;description&#x27;, name: &#x27;description&#x27;, content &#125;].concat(payload) &#125; &#125; &#125;&#125;) 在 nuxt.config.js 中加上： 12345export default &#123; plugins: [ &#x27;~plugins/global.js&#x27; ]&#125; 这样，只需要在页面的 head 的函数中，返回该函数即可： 123head() &#123; return this.$seo(this.detail.title, this.detail.summary)&#125; 可见，详情页已经成功的设置了部分 seo 的标签。 以上是 Nuxt 的一些基础配置及应用。 我再去研究一下， fetch 和 store 的结合，将该 demo 继续完善。 Demo 线上地址GitHub 地址","categories":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://marvinliu1.github.io/categories/Nuxt/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://marvinliu1.github.io/tags/Vue/"},{"name":"Nuxt","slug":"Nuxt","permalink":"https://marvinliu1.github.io/tags/Nuxt/"},{"name":"Javascript","slug":"Javascript","permalink":"https://marvinliu1.github.io/tags/Javascript/"}]},{"title":"Node in Debugging, 3.5 Evironment","slug":"3.5.1 环境","date":"2019-05-16T06:00:00.000Z","updated":"2022-05-25T04:23:07.031Z","comments":true,"path":"2019/05/16/3.5.1 环境/","link":"","permalink":"https://marvinliu1.github.io/2019/05/16/3.5.1%20%E7%8E%AF%E5%A2%83/","excerpt":"","text":"Node in Debugging 我们知道，Node.js 不适合 CPU 密集型计算的场景，通常的解决方法是用 C&#x2F;C++ 编写 Node.js 的扩展（Addons）。以前只能用 C&#x2F;C++，现在我们有了新的选择——Rust。 3.5.1 环境 &#x6e;&#x6f;&#100;&#101;&#x40;&#56;&#46;&#57;&#x2e;&#x34; rust@1.26.0-nightly 3.5.2 RustRust 是 Mozilla 开发的注重安全、性能和并发的现代编程语言。相比较于其他常见的编程语言，它有 3 个独特的概念： 所有权 借用 生命周期 正是这 3 个特性保证了 Rust 是内存安全的，这里不会展开讲解，有兴趣的读者可以去了解一下。 接下来，我们通过三种方式使用 Rust 编写 Node.js 的扩展。 3.5.3 FFIFFI 的全称是 Foreign Function Interface，即可以用 Node.js 调用动态链接库。 运行以下命令： 1234$ cargo new ffi-demo &amp;&amp; cd ffi-demo$ npm init -y$ npm i ffi --save$ touch index.js 部分文件修改如下： src&#x2F;lib.rs 1234567#[no_mangle]pub extern fn fib(n: i64) -&gt; i64 &#123; return match n &#123; 1 | 2 =&gt; 1, n =&gt; fib(n - 1) + fib(n - 2) &#125;&#125; Cargo.toml 1234567[package]name = &quot;ffi-demo&quot;version = &quot;0.1.0&quot;[lib]name = &quot;ffi&quot;crate-type = [&quot;dylib&quot;] Cargo.toml 是 Rust 项目的配置文件，相当于 Node.js 中的 package.json。这里指定编译生成的类型是 dylib（动态链接库），名字在 *inux 下是 libffi，Windows 下是 ffi。 使用 cargo 编译代码： 123$ cargo build #开发环境用或者$ cargo build --release #生产环境用，编译器做了更多优化，但编译慢 cargo 是 Rust 的构建工具和包管理工具，负责构建代码、下载依赖库并编译它们。此时会生成一个 target 的目录，该目录下会有 debug（不加 –release）或者 release（加 –release）目录，存放了生成的动态链接库。 index.js 1234567891011121314151617181920212223const ffi = require(&#x27;ffi&#x27;)const isWin = /^win/.test(process.platform)const rust = ffi.Library(&#x27;target/debug/&#x27; + (!isWin ? &#x27;lib&#x27; : &#x27;&#x27;) + &#x27;ffi&#x27;, &#123; fib: [&#x27;int&#x27;, [&#x27;int&#x27;]]&#125;)function fib(n) &#123; if (n === 1 || n === 2) &#123; return 1 &#125; return fib(n - 1) + fib(n - 2)&#125;// jsconsole.time(&#x27;node&#x27;)console.log(fib(40))console.timeEnd(&#x27;node&#x27;)// rustconsole.time(&#x27;rust&#x27;)console.log(rust.fib(40))console.timeEnd(&#x27;rust&#x27;) 运行 index.js： 12345$ node index.js102334155node: 1053.743ms102334155rust: 1092.570ms 将 index.js 中 debug 改为 release，运行： 123456$ cargo build --release$ node index.js102334155node: 1050.467ms102334155rust: 273.508ms 可以看出：添加了 –release 编译后的代码，执行效率提升十分明显。 3.5.4 Neon官方介绍： Rust bindings for writing safe and fast native Node.js modules. 使用方法如下： 12345678910111213141516171819$ npm i neon-cli -g$ neon new neon-demo$ cd neon-demo$ tree ..├── README.md├── lib│ └── index.js├── native│ ├── Cargo.toml│ ├── build.rs│ └── src│ └── lib.rs└── package.json3 directories, 6 files$ npm i #触发 neon build$ node lib/index.jshello node 接下来我们看看关键的代码文件。 lib&#x2F;index.js 12var addon = require(&#x27;../native&#x27;);console.log(addon.hello()); native&#x2F;src&#x2F;lib.rs 1234567891011121314#[macro_use]extern crate neon;use neon::vm::&#123;Call, JsResult&#125;;use neon::js::JsString;fn hello(call: Call) -&gt; JsResult&lt;JsString&gt; &#123; let scope = call.scope; Ok(JsString::new(scope, &quot;hello node&quot;).unwrap())&#125;register_module!(m, &#123; m.export(&quot;hello&quot;, hello)&#125;); native&#x2F;build.rs 1234567extern crate neon_build;fn main() &#123; neon_build::setup(); // must be called in build.rs // add project-specific build logic here...&#125; native&#x2F;Cargo.toml 12345678910111213141516[package]name = &quot;neon-demo&quot;version = &quot;0.1.0&quot;authors = [&quot;nswbmw&quot;]license = &quot;MIT&quot;build = &quot;build.rs&quot;[lib]name = &quot;neon_demo&quot;crate-type = [&quot;dylib&quot;][build-dependencies]neon-build = &quot;0.1.22&quot;[dependencies]neon = &quot;0.1.22&quot; 在运行 neon build 时，会根据 native&#x2F;Cargo.toml 中 build 字段指定的文件（这里是 build.rs）编译，并且生成的类型是 dylib（动态链接库）。native&#x2F;src&#x2F;lib.rs 存放了扩展的代码逻辑，通过 register_module 注册了一个 hello 方法，返回 hello node 字符串。 接下来测试原生 Node.js 和 Neon 编写的扩展运行斐波那契数列的执行效率。 修改对应文件如下： native&#x2F;src&#x2F;lib.rs 12345678910111213141516171819202122232425#[macro_use]extern crate neon;use neon::vm::&#123;Call, JsResult&#125;;use neon::mem::Handle;use neon::js::JsInteger;fn fib(call: Call) -&gt; JsResult&lt;JsInteger&gt; &#123; let scope = call.scope; let index: Handle&lt;JsInteger&gt; = try!(try!(call.arguments.require(scope, 0)).check::&lt;JsInteger&gt;()); let index: i32 = index.value() as i32; let result: i32 = fibonacci(index); Ok(JsInteger::new(scope, result))&#125;fn fibonacci(n: i32) -&gt; i32 &#123; match n &#123; 1 | 2 =&gt; 1, _ =&gt; fibonacci(n - 1) + fibonacci(n - 2) &#125;&#125;register_module!(m, &#123; m.export(&quot;fib&quot;, fib)&#125;); lib&#x2F;index.js 123456789101112131415161718const rust = require(&#x27;../native&#x27;)function fib (n) &#123; if (n === 1 || n === 2) &#123; return 1 &#125; return fib(n - 1) + fib(n - 2)&#125;// jsconsole.time(&#x27;node&#x27;)console.log(fib(40))console.timeEnd(&#x27;node&#x27;)// rustconsole.time(&#x27;rust&#x27;)console.log(rust.fib(40))console.timeEnd(&#x27;rust&#x27;) 运行： 123456$ neon build$ node lib/index.js102334155node: 1030.681ms102334155rust: 270.417ms 接下来看一个复杂点的例子，用 Neon 编写一个 User 类，可传入一个含有 first_name 和 last_name 的对象，暴露出一个 get_full_name 方法。 修改对应文件如下： native&#x2F;src&#x2F;lib.rs 123456789101112131415161718192021222324252627282930313233343536373839404142#[macro_use]extern crate neon;use neon::js::&#123;JsFunction, JsString, Object, JsObject&#125;;use neon::js::class::&#123;Class, JsClass&#125;;use neon::mem::Handle;use neon::vm::Lock;pub struct User &#123; first_name: String, last_name: String,&#125;declare_types! &#123; pub class JsUser for User &#123; init(call) &#123; let scope = call.scope; let user = try!(try!(call.arguments.require(scope, 0)).check::&lt;JsObject&gt;()); let first_name: Handle&lt;JsString&gt; = try!(try!(user.get(scope, &quot;first_name&quot;)).check::&lt;JsString&gt;()); let last_name: Handle&lt;JsString&gt; = try!(try!(user.get(scope, &quot;last_name&quot;)).check::&lt;JsString&gt;()); Ok(User &#123; first_name: first_name.value(), last_name: last_name.value(), &#125;) &#125; method get_full_name(call) &#123; let scope = call.scope; let first_name = call.arguments.this(scope).grab(|user| &#123; user.first_name.clone() &#125;); let last_name = call.arguments.this(scope).grab(|user| &#123; user.last_name.clone() &#125;); Ok(try!(JsString::new_or_throw(scope, &amp;(first_name + &amp;last_name))).upcast()) &#125; &#125;&#125;register_module!(m, &#123; let class: Handle&lt;JsClass&lt;JsUser&gt;&gt; = try!(JsUser::class(m.scope)); let constructor: Handle&lt;JsFunction&lt;JsUser&gt;&gt; = try!(class.constructor(m.scope)); try!(m.exports.set(&quot;User&quot;, constructor)); Ok(())&#125;); lib&#x2F;index.js 123456789const rust = require(&#x27;../native&#x27;)const User = rust.Userconst user = new User(&#123; first_name: &#x27;zhang&#x27;, last_name: &#x27;san&#x27;&#125;)console.log(user.get_full_name()) 运行： 123$ neon build$ node lib/index.jszhangsan 3.5.5 NAPI不少 Node.js 开发者可能都遇到过升级 Node.js 版本导致程序运行不起来的情况，需要重新安装依赖解决，比如：node-sass 模块。因为之前编写 Node.js 扩展严重依赖于 V8 暴露的 API，而不同版本的 Node.js 依赖的 V8 版本可能不同，一旦升级 Node.js 版本，原先运行正常的 Node.js 的扩展就可能失效了。 NAPI 是 node@8 新添加的用于原生模块开发的接口，相较于以前的开发方式，NAPI 提供了稳定的 ABI 接口，消除了 Node.js 版本差异、引擎差异等编译后不兼容的问题，解决了编写 Node.js 插件最头疼的问题。 目前 NAPI 还处于试验阶段，所以相关资料并不多，笔者写了一个 demo 放到了 GitHub 上，这里直接 clone 下来运行： 1$ git clone https://github.com/nswbmw/rust-napi-demo 主要文件代码如下： src&#x2F;lib.rs 12345678910111213141516171819202122232425#[macro_use]extern crate napi;#[macro_use]extern crate napi_derive;use napi::&#123;NapiEnv, NapiNumber, NapiResult&#125;;#[derive(NapiArgs)]struct Args&lt;&#x27;a&gt; &#123; n: NapiNumber&lt;&#x27;a&gt;&#125;fn fibonacci&lt;&#x27;a&gt;(env: &amp;&#x27;a NapiEnv, args: &amp;Args&lt;&#x27;a&gt;) -&gt; NapiResult&lt;NapiNumber&lt;&#x27;a&gt;&gt; &#123; let number = args.n.to_i32()?; NapiNumber::from_i32(env, _fibonacci(number))&#125;napi_callback!(export_fibonacci, fibonacci);fn _fibonacci(n: i32) -&gt; i32 &#123; match n &#123; 1 | 2 =&gt; 1, _ =&gt; _fibonacci(n - 1) + _fibonacci(n - 2) &#125;&#125; index.js 123456789101112131415161718const rust = require(&#x27;./build/Release/example.node&#x27;)function fib (n) &#123; if (n === 1 || n === 2) &#123; return 1 &#125; return fib(n - 1) + fib(n - 2)&#125;// jsconsole.time(&#x27;node&#x27;)console.log(fib(40))console.timeEnd(&#x27;node&#x27;)// rustconsole.time(&#x27;rust&#x27;)console.log(rust.fibonacci(40))console.timeEnd(&#x27;rust&#x27;) 运行结果： 123456$ npm start102334155node: 1087.650ms102334155rust: 268.395ms(node:33302) Warning: N-API is an experimental feature and could change at any time. 3.5.6 参考链接 https://github.com/neon-bindings/neon https://github.com/napi-rs/napi https://zhuanlan.zhihu.com/p/27650526","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 3.4 Ignition + Turbofan","slug":"3.4.1 Ignition + Turbofan","date":"2019-05-10T06:00:00.000Z","updated":"2022-05-25T04:23:07.031Z","comments":true,"path":"2019/05/10/3.4.1 Ignition + Turbofan/","link":"","permalink":"https://marvinliu1.github.io/2019/05/10/3.4.1%20Ignition%20+%20Turbofan/","excerpt":"","text":"Node in Debugging 如果你想以最简单的方式提升 Node.js 程序的性能，那就升级到 node@8+ 吧。这不是一个玩笑，多少 JavaScript 前辈们以血的教训总结出了一长列 “Optimization killers”，典型的有： 在 try 里面不要写过多代码，V8 无法优化，最好将这些代码放到一个函数里，然后 try 这个函数。 少用 delete。 少用 arguments。 … 然而，随着 V8 彻底换上了新的 JIT 编译器—— Turbofan，大多数 “Optimization killers” 都已经成了过去时。所以在本节中我们来看看哪些过去常见的 “Optimization killers” 已经可以被 V8 优化。 3.4.1 Ignition + Turbofan之前 V8 使用的是名为 Crankshaft 的编译器，这个编译器后来逐渐暴露出一些缺点： Doesn’t scale to full, modern JavaScript (try-catch, for-of, generators, async&#x2F;await, …) Defaults to deoptimization (performance cliffs, deoptimization loops) Graph construction, inlining and optimization all mixed up Tight coupling to fullcodegen &#x2F; brittle environment tracking Limited optimization potential &#x2F; limited static analysis (i.e. type propagation) High porting overhead Mixed low-level and high-level semantics of instructions 而引入 Turbofan 的好处是： Full ESnext language support (try-catch&#x2F;-finally, class literals, eval, generators, async functions, modules, destructuring, etc.) Utilize and propagate (static) type information Separate graph building from optimization &#x2F; inlining No deoptimization loops &#x2F; deoptimization only when really beneficial Sane environment tracking (also for lazy deoptimization) Predictable peak performance Ignition 是 V8 新引入的解释器，用来将代码编译成简洁的字节码，而不是之前的机器码，这大大减少了结果代码，减少了系统的内存使用。由于字节码较小，所以可以编译全部源代码，而不用避免编译未使用的代码。也就是说，脚本只需要解析一次，而不是像之前的编译过程那样解析多次。 Ignition 与 TurboFan 的关系为：Ignition 解释器使用低级的、体系结构无关的 TurboFan 宏汇编指令为每个操作码生成字节码处理程序，TurboFan 将这些指令编译成目标平台的代码，并在这个过程中执行低级的指令选择和机器寄存器分配。 补充一点，之前的 V8 将代码编译成机器码执行，而新的 V8 将代码编译成字节码解释执行，动机是什么呢？可能是： 减少机器码占用的内存空间，即牺牲时间换空间（主要动机）。 加快代码的启动速度。 对 V8 的代码进行重构，降低 V8 的代码复杂度。 3.4.2 版本对应关系1234node@6 -&gt; V8@5.1 -&gt; Crankshaftnode@8.0-8.2 -&gt; V8@5.8 -&gt; Crankshaft + Turbofan V8@5.9 -&gt; Turbofannode@8.3-8.4 -&gt; V8@6.0 -&gt; Turbofan 3.4.3 try&#x2F;catch最著名的去优化之一是使用 try&#x2F;catch 代码块。下面通过 4 种场景比较在不同的 V8 版本下执行的效率： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var benchmark = require(&#x27;benchmark&#x27;)var suite = new benchmark.Suite()function sum (base, max) &#123; var total = 0 for (var i = base; i &lt; max; i++) &#123; total += i &#125;&#125;suite.add(&#x27;sum with try catch&#x27;, function sumTryCatch () &#123; try &#123; var base = 0 var max = 65535 var total = 0 for (var i = base; i &lt; max; i++) &#123; total += i &#125; &#125; catch (err) &#123; console.log(err.message) &#125;&#125;)suite.add(&#x27;sum without try catch&#x27;, function noTryCatch () &#123; var base = 0 var max = 65535 var total = 0 for (var i = base; i &lt; max; i++) &#123; total += i &#125;&#125;)suite.add(&#x27;sum wrapped&#x27;, function wrapped () &#123; var base = 0 var max = 65535 try &#123; sum(base, max) &#125; catch (err) &#123; console.log(err.message) &#125;&#125;)suite.add(&#x27;sum function&#x27;, function func () &#123; var base = 0 var max = 65535 sum(base, max)&#125;)suite.on(&#x27;complete&#x27;, require(&#x27;./print&#x27;))suite.run() 运行结果如下： 结论：在 &#110;&#111;&#x64;&#101;&#64;&#56;&#x2e;&#x33; 及以上版本中，在 try 块内写代码的性能损耗可以忽略不计。 3.4.4 delete多年以来，delete 对于任何希望编写高性能 JavaScript 的人来说都是受限制的，我们通常用赋值 undefined 替代。delete 的问题归结为 V8 处理 JavaScript 对象的动态特性和原型链方式，使得属性查找在实现上变得复杂。下面通过 3 种场景比较在不同的 V8 版本下执行的效率： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var benchmark = require(&#x27;benchmark&#x27;)var suite = new benchmark.Suite()function MyClass (x, y) &#123; this.x = x this.y = y&#125;function MyClassLast (x, y) &#123; this.y = y this.x = x&#125;suite.add(&#x27;setting to undefined&#x27;, function undefProp () &#123; var obj = new MyClass(2, 3) obj.x = undefined JSON.stringify(obj)&#125;)suite.add(&#x27;delete&#x27;, function deleteProp () &#123; var obj = new MyClass(2, 3) delete obj.x JSON.stringify(obj)&#125;)suite.add(&#x27;delete last property&#x27;, function deleteProp () &#123; var obj = new MyClassLast(2, 3) delete obj.x JSON.stringify(obj)&#125;)suite.add(&#x27;setting to undefined literal&#x27;, function undefPropLit () &#123; var obj = &#123; x: 2, y: 3 &#125; obj.x = undefined JSON.stringify(obj)&#125;)suite.add(&#x27;delete property literal&#x27;, function deletePropLit () &#123; var obj = &#123; x: 2, y: 3 &#125; delete obj.x JSON.stringify(obj)&#125;)suite.add(&#x27;delete last property literal&#x27;, function deletePropLit () &#123; var obj = &#123; y: 3, x: 2 &#125; delete obj.x JSON.stringify(obj)&#125;)suite.on(&#x27;complete&#x27;, require(&#x27;./print&#x27;))suite.run() 运行结果如下： 结论：在 node@8 及以上版本中，delete 一个对象上的属性比 node@6 快了一倍。在 &#110;&#111;&#x64;&#101;&#x40;&#x38;&#x2e;&#51; 及以上版本中，delete 一个对象上最后一个属性几乎与赋值 undefined 同样快了。 3.4.5 arguments我们知道 arguments 是个类数组，所以通常我们要使用 Array.prototype.slice.call(arguments) 将它转化成数组再使用，这样会有一定的性能损耗。下面通过 4 种场景比较在不同的 V8 版本下执行的效率： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var benchmark = require(&#x27;benchmark&#x27;)var suite = new benchmark.Suite()function leakyArguments () &#123; return other(arguments)&#125;function copyArgs () &#123; var array = new Array(arguments.length) for (var i = 0; i &lt; array.length; i++) &#123; array[i] = arguments[i] &#125; return other(array)&#125;function sliceArguments () &#123; var array = Array.prototype.slice.apply(arguments) return other(array)&#125;function spreadOp(...args) &#123; return other(args)&#125;function other (toSum) &#123; var total = 0 for (var i = 0; i &lt; toSum.length; i++) &#123; total += toSum[i] &#125; return total&#125;suite.add(&#x27;leaky arguments&#x27;, () =&gt; &#123; leakyArguments(1, 2, 3)&#125;)suite.add(&#x27;Array.prototype.slice arguments&#x27;, () =&gt; &#123; sliceArguments(1, 2, 3)&#125;)suite.add(&#x27;for-loop copy arguments&#x27;, () =&gt; &#123; copyArgs(1, 2, 3)&#125;)suite.add(&#x27;spread operator&#x27;, () =&gt; &#123; spreadOp(1, 2, 3)&#125;)suite.on(&#x27;complete&#x27;, require(&#x27;./print&#x27;))suite.run() 运行结果如下： 结论：在 &#x6e;&#x6f;&#x64;&#x65;&#x40;&#56;&#x2e;&#51; 及以上版本中，使用对象展开运算符是除直接使用 arguments 外最快的方案，对于 &#x6e;&#111;&#100;&#x65;&#x40;&#56;&#x2e;&#50; 及以下的版本，我们应该使用一个 for 循环将 key 从 arguments 复制到一个新的（预先分配的）数组中。总之，是时候抛弃 Array.prototype.slice.call 了。 3.4.6 async 性能提升在 &#86;&#x38;&#x40;&#x35;&#46;&#x37; 发布后，原生的 async 函数与 Promise 一样快了，同时，Promise 的性能也比 &#86;&#x38;&#x40;&#x35;&#46;&#54; 快了一倍。如图所示： 3.4.7 不会优化的特性并不是说上了 Turbofan 就能优化所有的 JavaScript 语法，有些语法 V8 是不会去优化的（也没有必要），例如： debugger eval with 我们以 debugger 为例，比较使用和不使用 debugger 时的性能： 12345678910111213141516171819202122232425262728var benchmark = require(&#x27;benchmark&#x27;)var suite = new benchmark.Suite()suite.add(&#x27;with debugger&#x27;, function withDebugger () &#123; var base = 0 var max = 65535 var total = 0 for (var i = base; i &lt; max; i++) &#123; debugger total += i &#125;&#125;)suite.add(&#x27;without debugger&#x27;, function withoutDebugger () &#123; var base = 0 var max = 65535 var total = 0 for (var i = base; i &lt; max; i++) &#123; total += i &#125;&#125;)suite.on(&#x27;complete&#x27;, require(&#x27;./print&#x27;))suite.run() 运行结果如下： 结论：在所有测试的 V8 版本中，debugger 一直都很慢，所以记得在打断点测试完后一定要删掉 debugger。 3.4.8 总结 使用最新 LTS 版本的 Node.js。 关注 V8 团队的博客——https://v8project.blogspot.com，了解第一手资讯。 清晰的代码远比使用一些奇技淫巧提升的一点性能重要得多。 3.4.9 参考链接 https://github.com/davidmarkclements/v8-perf http://www.infoq.com/cn/news/2016/08/v8-ignition-javascript-inteprete https://docs.google.com/presentation/d/1H1lLsbclvzyOF3IUR05ZUaZcqDxo7_-8f4yJoxdMooU/edit#slide=id.g18ceb14729_0_59 https://www.nearform.com/blog/node-js-is-getting-a-new-v8-with-turbofan https://zhuanlan.zhihu.com/p/26669846","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 3.3 Stack Trace","slug":"3.3.1 Stack Trace","date":"2019-05-02T06:00:00.000Z","updated":"2022-05-25T04:23:07.031Z","comments":true,"path":"2019/05/02/3.3.1 Stack Trace/","link":"","permalink":"https://marvinliu1.github.io/2019/05/02/3.3.1%20Stack%20Trace/","excerpt":"","text":"Node in Debugging 对于 JavaScript 中的 Error，想必大家已经很熟悉了，毕竟天天与它打交道。 Node.js 内置的 Error 类型有： Error：通用的错误类型，例如：new Error(&#39;error!!!&#39;)。 SyntaxError：语法错误，例如：require(&#39;vm&#39;).runInThisContext(&#39;binary ! isNotOk&#39;)。 ReferenceError：引用错误，如引用一个未定义的变量，例如：doesNotExist。 TypeError：类型错误，例如：require(&#39;url&#39;).parse(() =&gt; &#123;&#125;)。 URIError：全局的 URI 处理函数抛出的错误，例如：encodeURI(&#39;\\uD800&#39;)。 AssertError：使用 assert 模块时抛出的错误，例如：assert(false)。 每个 Error 对象通常有 name、message、stack、constructor 等属性。当程序抛出异常时，我们需要根据错误栈（error.stack）定位到出错代码。希望本节能够帮助读者理解并玩转错误栈，写出错误栈清晰的代码，方便调试。 3.3.1 Stack Trace错误栈本质上就是调用栈（或者叫：堆栈追踪）。所以我们先复习一下 JavaScript 中调用栈的概念。 调用栈：每当有一个函数调用，就会将其压入栈顶，在调用结束的时候再将其从栈顶移出。 来看一段代码： 12345678910111213141516function c () &#123; console.log(&#x27;c&#x27;) console.trace()&#125;function b () &#123; console.log(&#x27;b&#x27;) c()&#125;function a () &#123; console.log(&#x27;a&#x27;) b()&#125;a() 执行后打印出： 123456789abcTrace at c (/Users/nswbmw/Desktop/test/app.js:3:11) at b (/Users/nswbmw/Desktop/test/app.js:8:3) at a (/Users/nswbmw/Desktop/test/app.js:13:3) at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:16:1) at ... 可以看出：c 函数中 console.trace() 打印出的堆栈追踪依次为 c、b、a，即 a 调用了 b，b 调用了 c。 稍微修改下上面的例子： 12345678910111213141516function c () &#123; console.log(&#x27;c&#x27;)&#125;function b () &#123; console.log(&#x27;b&#x27;) c() console.trace()&#125;function a () &#123; console.log(&#x27;a&#x27;) b()&#125;a() 执行后打印出： 12345678abcTrace at b (/Users/nswbmw/Desktop/test/app.js:8:11) at a (/Users/nswbmw/Desktop/test/app.js:13:3) at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:16:1) at ... 可以看出：c() 在 console.trace() 之前执行完毕，从栈中移除，所以栈中从上往下为 b、a。 上面示例的代码过于简单，在实际情况下错误栈并没有这么直观。以常用的 mongoose 为例，mongoose 的错误栈并不友好： 123456789101112const mongoose = require(&#x27;mongoose&#x27;)const Schema = mongoose.Schemamongoose.connect(&#x27;mongodb://localhost/test&#x27;)const UserSchema = new Schema(&#123; id: mongoose.Schema.Types.ObjectId&#125;)const User = mongoose.model(&#x27;User&#x27;, UserSchema)User .create(&#123; id: &#x27;xxx&#x27; &#125;) .then(console.log) .catch(console.error) 运行后打印出： 123456789101112131415161718&#123; ValidationError: User validation failed: id: Cast to ObjectID failed for value &quot;xxx&quot; at path &quot;id&quot; at ValidationError.inspect (/Users/nswbmw/Desktop/test/node_modules/mongoose/lib/error/validation.js:56:24) at ... errors: &#123; id: &#123; CastError: Cast to ObjectID failed for value &quot;xxx&quot; at path &quot;id&quot; at new CastError (/Users/nswbmw/Desktop/test/node_modules/mongoose/lib/error/cast.js:27:11) at model.$set (/Users/nswbmw/Desktop/test/node_modules/mongoose/lib/document.js:792:7) at ... message: &#x27;Cast to ObjectID failed for value &quot;xxx&quot; at path &quot;id&quot;&#x27;, name: &#x27;CastError&#x27;, stringValue: &#x27;&quot;xxx&quot;&#x27;, kind: &#x27;ObjectID&#x27;, value: &#x27;xxx&#x27;, path: &#x27;id&#x27;, reason: [Object] &#125; &#125;, _message: &#x27;User validation failed&#x27;, name: &#x27;ValidationError&#x27; &#125; 从 mongoose 给出的 error.stack 中看不到任何有用的信息，error.message 告诉我们 “xxx” 不匹配 User 这个 Model 的 id（ObjectID）的类型，其他的字段基本上也是这个结论的补充，却没有给出我们最关心的问题：我写的代码中，到底哪一行出了问题？ 如何解决这个问题呢？我们先看看 Error.captureStackTrace 的用法。 3.3.2 Error.captureStackTraceError.captureStackTrace 是 V8 提供的一个 API，可以传入两个参数： 1Error.captureStackTrace(targetObject[, constructorOpt]) Error.captureStackTrace 会在 targetObject 中添加一个 stack 属性，对该属性进行访问时，将以字符串的形式返回 Error.captureStackTrace() 语句被调用时的代码位置信息（即：调用栈历史）。 举个简单的例子： 1234567const myObject = &#123;&#125;Error.captureStackTrace(myObject)console.log(myObject.stack)// 输出Error at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:2:7) at ... 除了 targetObject，captureStackTrace 还接收一个类型为 function 的可选参数 constructorOpt，当传递该参数时，调用栈中所有 constructorOpt 函数之上的信息(包括 constructorOpt 函数自身)，都会在访问 targetObject.stack 时被忽略。当需要对终端用户隐藏内部的实现细节时，constructorOpt 参数会很有用。传入第 2 个参数通常用于自定义错误，例如： 1234567891011121314function MyError() &#123; Error.captureStackTrace(this, MyError) this.name = this.constructor.name this.message = &#x27;you got MyError&#x27;&#125;const myError = new MyError()console.log(myError)console.log(myError.stack)// 输出MyError &#123; name: &#x27;MyError&#x27;, message: &#x27;you got MyError&#x27; &#125;Error at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:7:17) at ... 如果去掉 captureStackTrace 的第 2 个参数： 123456789101112131415function MyError() &#123; Error.captureStackTrace(this) this.name = this.constructor.name this.message = &#x27;you got MyError&#x27;&#125;const myError = new MyError()console.log(myError)console.log(myError.stack)// 输出MyError &#123; name: &#x27;MyError&#x27;, message: &#x27;you got MyError&#x27; &#125;Error at new MyError (/Users/nswbmw/Desktop/test/app.js:2:9) at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:7:17) at ... 可以看出：出现了 MyError 相关的调用栈，但我们并不关心 MyError 及其内部是如何实现的。 captureStackTrace 的第 2 个参数可以传入调用链上的其他函数，不一定是当前函数，例如： 123456789101112131415161718192021const myObj = &#123;&#125;function c () &#123; Error.captureStackTrace(myObj, b)&#125;function b () &#123; c()&#125;function a () &#123; b()&#125;a()console.log(myObj.stack)// 输出Error at a (/Users/nswbmw/Desktop/test/app.js:12:3) at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:15:1) at ... 可以看出：captureStackTrace 的第 2 个参数传入了函数 b，调用栈中隐藏了 b 函数及其以上所有的堆栈帧。 讲到这里，相信读者都明白了 captureStackTrace 的用法。但这具体有什么用呢？其实上面提到了：隐藏内部的实现细节，优化错误栈。 下面以笔者写的一个模块 Mongolass 为例，讲解如何应用 captureStackTrace。 Mongolass 是一个轻量且优雅的连接 MongoDB 的模块。 3.3.3 captureStackTrace 在 Mongolass 中的应用这里先大体讲讲 Mongolass 的用法。Mongolass 与 Mongoose 类似，有 Model 的概念，Model 上挂载的方法对应对 MongoDB 的 collections 的操作，例如：User.insert。User 是一个 Model 实例，User.insert 方法返回的是一个 Query 实例。Query 的代码如下： 123456class Query &#123; constructor(op, args) &#123; Error.captureStackTrace(this, this.constructor); ... &#125;&#125; 这里用 Error.captureStackTrace 隐藏了 Query 内部的错误栈细节，但这样带来一个问题：丢失了原来的 error.stack，在 Mongolass 中可以自定义插件，而插件函数的执行是在 Query 内部，假如在插件中抛错，则会丢失相关错误栈信息。 如何弥补呢？Mongolass 的做法是：当 Query 内部抛出错误（error）时，截取有用的 error.stack，然后拼接到 Query 实例通过 Error.captureStackTrace 生成的 stack 上。 来看一段 Mongolass 的代码： 123456789101112131415const Mongolass = require(&#x27;mongolass&#x27;)const Schema = Mongolass.Schemaconst mongolass = new Mongolass(&#x27;mongodb://localhost:27017/test&#x27;)const UserSchema = new Schema(&#x27;UserSchema&#x27;, &#123; name: &#123; type: &#x27;string&#x27; &#125;, age: &#123; type: &#x27;number&#x27; &#125;&#125;)const User = mongolass.model(&#x27;User&#x27;, UserSchema)User .insertOne(&#123; name: &#x27;nswbmw&#x27;, age: &#x27;wrong age&#x27; &#125;) .exec() .then(console.log) .catch(console.error) 运行后打印的错误信息如下： 123456789101112131415&#123; TypeError: ($.age: &quot;wrong age&quot;) ✖ (type: number) at Model.insertOne (/Users/nswbmw/Desktop/test/node_modules/mongolass/lib/query.js:104:16) at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:12:4) at ... validator: &#x27;type&#x27;, actual: &#x27;wrong age&#x27;, expected: &#123; type: &#x27;number&#x27; &#125;, path: &#x27;$.age&#x27;, schema: &#x27;UserSchema&#x27;, model: &#x27;User&#x27;, op: &#x27;insertOne&#x27;, args: [ &#123; name: &#x27;nswbmw&#x27;, age: &#x27;wrong age&#x27; &#125; ], pluginName: &#x27;MongolassSchema&#x27;, pluginOp: &#x27;beforeInsertOne&#x27;, pluginArgs: [] &#125; 可以看出：app.js 第 12 行的 insertOne 报错，报错原因是 age 字段是字符串 “wrong age”，而我们期望的是 number 类型的值。 3.3.4 Error.prepareStackTraceV8 暴露了另外一个接口——Error.prepareStackTrace。简单来讲，它的作用就是：定制 stack。用法如下： 1Error.prepareStackTrace(error, structuredStackTrace) 第 1 个参数是个 Error 对象，第 2 个参数是一个数组，每一项都是一个 CallSite 对象，包含错误的函数名、行数等信息。对比以下两种代码： 正常的 throw error： 123456789101112131415161718192021222324function c () &#123; throw new Error(&#x27;error!!!&#x27;)&#125;function b () &#123; c()&#125;function a () &#123; b()&#125;try &#123; a()&#125; catch (e) &#123; console.log(e.stack)&#125;// 输出Error: error!!! at c (/Users/nswbmw/Desktop/test/app.js:2:9) at b (/Users/nswbmw/Desktop/test/app.js:6:3) at a (/Users/nswbmw/Desktop/test/app.js:10:3) at Object.&lt;anonymous&gt; (/Users/nswbmw/Desktop/test/app.js:14:3) at ... 使用 Error.prepareStackTrace 格式化 stack： 123456789101112131415161718192021222324252627282930313233Error.prepareStackTrace = function (error, callSites) &#123; return error.toString() + &#x27;\\n&#x27; + callSites.map(callSite =&gt; &#123; return &#x27; -&gt; &#x27; + callSite.getFunctionName() + &#x27; (&#x27; + callSite.getFileName() + &#x27;:&#x27; + callSite.getLineNumber() + &#x27;:&#x27; + callSite.getColumnNumber() + &#x27;)&#x27; &#125;).join(&#x27;\\n&#x27;)&#125;function c () &#123; throw new Error(&#x27;error!!!&#x27;)&#125;function b () &#123; c()&#125;function a () &#123; b()&#125;try &#123; a()&#125; catch (e) &#123; console.log(e.stack)&#125;// 输出Error: error!!! -&gt; c (/Users/nswbmw/Desktop/test/app.js:11:9) -&gt; b (/Users/nswbmw/Desktop/test/app.js:15:3) -&gt; a (/Users/nswbmw/Desktop/test/app.js:19:3) -&gt; null (/Users/nswbmw/Desktop/test/app.js:23:3) -&gt; ... 可以看出：我们自定义了一个 Error.prepareStackTrace 格式化了 stack 并打印出来。 CallSite 对象还有许多 API，例如：getThis、getTypeName、getFunction、getFunctionName、getMethodName、getFileName、getLineNumber、getColumnNumber、getEvalOrigin、isToplevel、isEval、isNative 和 isConstructor，这里不一一介绍了，有兴趣的读者可查看参考链接。 在使用 Error.prepareStackTrace 时需要注意两点： 这个方法是 V8 暴露出来的，所以只能在基于 V8 的 Node.js 或者 Chrome 里才能使用。 这个方法会修改全局 Error 的行为。 3.3.5 Error.prepareStackTrace 的其他用法Error.prepareStackTrace 除了格式化错误栈外还有什么作用呢？sindresorhus 大神还写了一个 callsites 的模块，可以用来获取函数调用相关的信息，例如获取执行该函数所在的文件名： 12345678const callsites = require(&#x27;callsites&#x27;)function getFileName() &#123; console.log(callsites()[0].getFileName()) //=&gt; &#x27;/Users/nswbmw/Desktop/test/app.js&#x27;&#125;getFileName() 我们来看一下源代码： 1234567module.exports = () =&gt; &#123; const _ = Error.prepareStackTrace Error.prepareStackTrace = (_, stack) =&gt; stack const stack = new Error().stack.slice(1) Error.prepareStackTrace = _ return stack&#125; 注意以下几点： 因为修改 Error.prepareStackTrace 会全局生效，所以将原来的 Error.prepareStackTrace 存到一个变量中，函数执行完后再重置回去，避免影响全局的 Error。 Error.prepareStackTrace 函数直接返回 CallSite 对象数组，而不是格式化后的 stack 字符串。 new 一个 Error，stack 是返回的 CallSite 对象数组，因为第 1 项是 callsites，它总是这个模块的 CallSite，所以通过 slice(1) 去掉。 假如我们想获取当前函数的父函数名，则可以这样用： 1234567891011const callsites = require(&#x27;callsites&#x27;)function b () &#123; console.log(callsites()[1].getFunctionName()) // =&gt; &#x27;a&#x27;&#125;function a () &#123; b()&#125;a() 3.3.6 Error.stackTraceLimitNode.js 还暴露了一个 Error.stackTraceLimit 的设置，可以通过设置这个值来改变输出的 stack 的行数，默认值是 10。 3.3.7 Long Stack Tracestack trace 也有短板，问题出在异步操作上。若在异步回调中抛错，就会丢失绑定回调前的调用栈信息，来看个例子： 1234567891011121314151617const foo = function () &#123; throw new Error(&#x27;error!!!&#x27;)&#125;const bar = function () &#123; setTimeout(foo)&#125;bar()// 输出/Users/nswbmw/Desktop/test/app.js:2 throw new Error(&#x27;error!!!&#x27;) ^Error: error!!! at Timeout.foo [as _onTimeout] (/Users/nswbmw/Desktop/test/app.js:2:9) at ontimeout (timers.js:469:11) at tryOnTimeout (timers.js:304:5) at Timer.listOnTimeout (timers.js:264:5) 可以看出：丢失了 bar 的调用栈。 在实际开发过程中，异步回调的例子数不胜数，如果不能知道异步回调之前的触发位置，则会给 debug 带来很大的难度。这时，出现了一个叫 long Stack Trace 的概念。 long Stack Trace 并不是 JavaScript 原生就支持的功能，所以要拥有这样的功能，就需要我们做一些 hack，幸好在 V8 环境下，所有 hack 所需的 API，V8 都已经提供了。 对于异步回调，目前能做的就是在所有会产生异步操作的 API 上做一些手脚，这些 API 包括： setTimeout, setInterval, setImmediate。 nextTick, nextDomainTick。 EventEmitter.addEventListener。 EventEmitter.on。 Ajax XHR。 Long Stack Trace 相关的库可以参考： AndreasMadsen&#x2F;trace mattinsler&#x2F;longjohn tlrobinson&#x2F;long-stack-traces node@8+ 提供了强大的 async_hooks 模块，在本书的后面章节会介绍如何使用。 3.3.8 参考链接 https://zhuanlan.zhihu.com/p/25338849 https://segmentfault.com/a/1190000007076507 https://github.com/v8/v8/wiki/Stack-Trace-API https://www.jianshu.com/p/1d5120ad62bb","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 3.2 Async and Await","slug":"3.2.1 async + await","date":"2019-04-28T06:00:00.000Z","updated":"2022-05-25T04:23:07.031Z","comments":true,"path":"2019/04/28/3.2.1 async + await/","link":"","permalink":"https://marvinliu1.github.io/2019/04/28/3.2.1%20async%20+%20await/","excerpt":"","text":"Node in Debugging 笔者在很长一段时间内都在使用 koa@1 +（generator|bluebird）+ sequelize 这个组合，这个组合并没有什么问题，也很常见，但是到了滥用的地步，导致后来维护和调试起来都很痛苦。若排除 sequelize 这个我们不得不用的模块，从调试 cpuprofile 的角度讲讲为什么笔者认为应该用 async&#x2F;await + Promise 替代 co + generator|bluebird。 笔者的观点是：使用原生模块具有更清晰的调用栈。 下面用 4 个例子进行对比，看看实现相同逻辑的不同代码生成的 cpuprofile 中调用栈的信息。 3.2.1 async + awaitasync.js 12345678910111213141516171819202122232425const fs = require(&#x27;fs&#x27;)const profiler = require(&#x27;v8-profiler&#x27;)async function A () &#123; return await Promise.resolve(&#x27;A&#x27;)&#125;async function B () &#123; return await A()&#125;(async function asyncWrap () &#123; const start = Date.now() profiler.startProfiling() while (Date.now() - start &lt; 10000) &#123; await B() &#125; const profile = profiler.stopProfiling() profile.export() .pipe(fs.createWriteStream(&#x27;async.cpuprofile&#x27;)) .on(&#x27;finish&#x27;, () =&gt; &#123; profile.delete() console.error(&#x27;async.cpuprofile export success&#x27;) &#125;)&#125;)() 加载运行后生成的 async.cpuprofile，如下所示： 可以看出：asyncWrap 中调用了 B 函数，B 函数调用了 A 函数，A 函数中 resolve 了一个值。在 asyncWrap 中还调用了 stopProfiling 函数。 3.2.2 co + yieldco.js 1234567891011121314151617181920212223242526const fs = require(&#x27;fs&#x27;)const co = require(&#x27;co&#x27;)const profiler = require(&#x27;v8-profiler&#x27;)function * A () &#123; return yield Promise.resolve(&#x27;A&#x27;)&#125;function * B () &#123; return yield A()&#125;co(function * coWrap () &#123; const start = Date.now() profiler.startProfiling() while (Date.now() - start &lt; 10000) &#123; yield B() &#125; const profile = profiler.stopProfiling() profile.export() .pipe(fs.createWriteStream(&#x27;co.cpuprofile&#x27;)) .on(&#x27;finish&#x27;, () =&gt; &#123; profile.delete() console.error(&#x27;co.cpuprofile export success&#x27;) &#125;)&#125;) 加载运行后生成的 co.cpuprofile，如下所示： 可以看出：调用栈非常深，有太多没有用的 co 相关的调用栈。如果 n 个 generator 层层嵌套，就会出现 n 倍的 (anonymous)-&gt;onFullfiled-&gt;next-&gt;toPromise-&gt;co-&gt;Promise-&gt;(anonymous) 调用栈。如果你读过 co 的源码，就可能知道，这是 co 将 generator 解包的过程。其实这个可以通过将 yield generator 替换成 yield* generator 来优化。 3.2.3 co + yield*co_better.js 1234567891011121314151617181920212223242526const fs = require(&#x27;fs&#x27;)const co = require(&#x27;co&#x27;)const profiler = require(&#x27;v8-profiler&#x27;)function * A () &#123; return yield Promise.resolve(&#x27;A&#x27;)&#125;function * B () &#123; return yield * A()&#125;co(function * coWrap () &#123; const start = Date.now() profiler.startProfiling() while (Date.now() - start &lt; 10000) &#123; yield * B() &#125; const profile = profiler.stopProfiling() profile.export() .pipe(fs.createWriteStream(&#x27;co_better.cpuprofile&#x27;)) .on(&#x27;finish&#x27;, () =&gt; &#123; profile.delete() console.error(&#x27;co_better.cpuprofile export success&#x27;) &#125;)&#125;) 加载运行后生成的 co_better.cpuprofile，如下所示： 可以看出：与 co.js 相比，调用栈清晰了很多，不过与使用 async&#x2F;await 相比，还是多了些 onFulfilled、next。 3.2.4 co + bluebirdco_bluebird.js 123456789101112131415161718192021222324252627const fs = require(&#x27;fs&#x27;)const co = require(&#x27;co&#x27;)const Promise = require(&#x27;bluebird&#x27;)const profiler = require(&#x27;v8-profiler&#x27;)function * A () &#123; return yield Promise.resolve(&#x27;A&#x27;)&#125;function * B () &#123; return yield * A()&#125;co(function * coBluebirdWrap () &#123; const start = Date.now() profiler.startProfiling() while (Date.now() - start &lt; 10000) &#123; yield * B() &#125; const profile = profiler.stopProfiling() profile.export() .pipe(fs.createWriteStream(&#x27;co_bluebird.cpuprofile&#x27;)) .on(&#x27;finish&#x27;, () =&gt; &#123; profile.delete() console.error(&#x27;co_bluebird.cpuprofile export success&#x27;) &#125;)&#125;) 加载运行后生成的 co_bluebird.cpuprofile，如下所示： 可以看出：与 co_better.js 相比，调用栈中多了许多 bluebird 模块的无用信息。而且这只是非常简单的示例代码，要是在复杂的业务逻辑中大量使用 bluebird 代码生成的 cpuprofile，就几乎没法看了。 结论：使用 async&#x2F;await + Promise + 命名函数，具有更清晰的调用栈，让分析 cpuprofile 时不再痛苦。 聪明的你可能会问： 为什么不建议用 bluebird？因为： 随着 V8 不断优化，原生 Promise 性能逐渐提高，bluebird 的性能优势不明显。 原生 Promise 的 API 足够用，至少能覆盖大部分使用场景，而且还在不断完善，未来还会添加新的 API，例如：Promise.prototype.finally。 具有更清晰的调用栈。 由于历史遗留原因，现在代码中大量使用了 yield + generator 怎么办？可以： 将所有 yield generator 替换成 yield * generator。 升级到 node@8+，逐步用 async&#x2F;await 替换，毕竟 async 函数调用后返回的也是一个 promise，也是 yieldable 的。 性能比较呢？ node@8+ 下 async&#x2F;await 完胜 co。 3.2.5 yield -&gt; yield* 遇到的坑上面讲到，可以将 yield generator 改成 yield * generator，这里面有一个坑，是由于不明白 co 的原理而滥用 co 导致的。代码如下： 12345678910const co = require(&#x27;co&#x27;)function * genFunc () &#123; return Promise.resolve(&#x27;genFunc&#x27;)&#125;co(function * () &#123; console.log(yield genFunc()) // =&gt; genFunc console.log(yield * genFunc()) // =&gt; Promise &#123; &#x27;genFunc&#x27; &#125;&#125;) 可以看出：genFunc 这个 generatorFunction 在执行后会返回一个 promise，当使用 yield genFunc() 的时候，co 判断返回了一个 promise 会继续帮我们调用它的 then 从而得到真正的字符串。如果使用 yield * genFunc()，就用了语言原生的特性而不经过 co，直接返回一个 promise。 解决方法（任选其一）： function * genFunc -&gt; function genFunc，用 yield genFunc()。 return Promise.resolve(&#39;genFunc&#39;) -&gt; return yield Promise.resolve(&#39;genFunc&#39;)，用 yield* genFunc()。 不过，建议最终转换到 async&#x2F;await + Promise 上来，毕竟 co + generator 只是一个过渡产物。 3.2.6 async + bluebird如果是使用 async&#x2F;await + bluebird 的情况呢？代码如下： async_bluebird.js 1234567891011121314151617181920212223242526const fs = require(&#x27;fs&#x27;)const profiler = require(&#x27;v8-profiler&#x27;)const Promise = require(&#x27;bluebird&#x27;)async function A () &#123; return await Promise.resolve(&#x27;A&#x27;)&#125;async function B () &#123; return await A()&#125;(async function asyncBluebirdWrap () &#123; const start = Date.now() profiler.startProfiling() while (Date.now() - start &lt; 10000) &#123; await B() &#125; const profile = profiler.stopProfiling() profile.export() .pipe(fs.createWriteStream(&#x27;async_bluebird.cpuprofile&#x27;)) .on(&#x27;finish&#x27;, () =&gt; &#123; profile.delete() console.error(&#x27;async_bluebird.cpuprofile export success&#x27;) &#125;)&#125;)() 结论：调用栈比 co_blueblird.js 的还乱。 3.2.7 参考链接 https://medium.com/@markherhold/generators-vs-async-await-performance-806d8375a01a","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 3.1 PromiseA standard","slug":"3.1.1 PromiseA+ 规范","date":"2019-04-21T06:00:00.000Z","updated":"2022-05-25T04:23:07.031Z","comments":true,"path":"2019/04/21/3.1.1 PromiseA+ 规范/","link":"","permalink":"https://marvinliu1.github.io/2019/04/21/3.1.1%20PromiseA+%20%E8%A7%84%E8%8C%83/","excerpt":"","text":"Node in Debugging 如何写出清晰优雅的代码也是调试重要的一部分，而在过去很长一段时间内，JavaScript 最令人吐槽的就是回调地狱（callback hell）了。先看一段代码： 12345678910111213141516171819step1(function (err, value1) &#123; if (err) &#123; ... return &#125; step2(value1, function (err, value2) &#123; if (err) &#123; ... return &#125; step3(value2, function (err, value3) &#123; if (err) &#123; ... return &#125; // Do something with value3 &#125;) &#125;)&#125;) 上面代码依次执行 step1、step2、step3，且后一个函数用到了前一个函数执行的结果。这只是一个简单的例子，真实环境下可能会写出嵌套更深的回调函数，代码形成一个倒金字塔。如果使用 Promise，代码就优雅很多了，如下所示： 123456step1() .then(step2) .then(step3) .catch((e) =&gt; &#123; // Do something with error &#125;) Promise 的出现就是为了解决回调地狱的问题，它最早是由社区提出和实现的，衍生的规范也有很多，最终 ES6 采用了 Promise&#x2F;A+ 规范，并将其写进了语言标准，统一了用法。 3.1.1 Promise&#x2F;A+ 规范Promise 规范有很多，如 Promise&#x2F;A，Promise&#x2F;B，Promise&#x2F;D 以及 Promise&#x2F;A 的升级版 Promise&#x2F;A+，细节各有不同，最终 ES6 中采用了 Promise&#x2F;A+ 规范。在讲解 Promise 实现之前，当然要先了解 Promise&#x2F;A+ 规范，Promise&#x2F;A+ 规范参考： 英文版：https://promisesaplus.com/ 中文版：http://www.ituring.com.cn/article/66566 规范虽然不长，但细节也比较多，笔者挑出几个要点简单说明一下： Promise 本质是一个状态机。每个 promise 只能是 3 种状态中的一种：pending、fulfilled 或 rejected。状态转变只能是 pending -&gt; fulfilled 或者 pending -&gt; rejected。状态转变不可逆。 then 方法可以被同一个 promise 调用多次。 then 方法必须返回一个 promise，从而可以实现链式调用。 值穿透。下面会讲。 Promise 的 API 并不多，但是 Promise 并不简单，如何彻底理解并玩转 Promise 呢？当然是从头实现一遍 Promise 啦。我们假设读者已经熟悉了 Promise 的基本用法，本节内容分为两部分：第一部分讲解如何从零开始实现一个 Promise，第二部分通过十道题巩固读者对 Promise 的理解。 3.1.2 从零开始实现 Promise我们知道 Promise 是本质是一个构造函数，需要用 new 调用，并有以下几个 api： 123456789function Promise (resolver) &#123;&#125;Promise.prototype.then = function () &#123;&#125;Promise.prototype.catch = function () &#123;&#125;Promise.resolve = function () &#123;&#125;Promise.reject = function () &#123;&#125;Promise.all = function () &#123;&#125;Promise.race = function () &#123;&#125; 创建以下初始代码，然后开始一步一步构建完整的 Promise 实现。如下所示： 12345678910111213141516171819202122232425262728function INTERNAL () &#123;&#125;function isFunction (func) &#123; return typeof func === &#x27;function&#x27;&#125;function isObject (obj) &#123; return typeof obj === &#x27;object&#x27;&#125;function isArray (arr) &#123; return Array.isArray(arr)&#125;const PENDING = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;module.exports = Promisefunction Promise (resolver) &#123; if (!isFunction(resolver)) &#123; throw new TypeError(&#x27;resolver must be a function&#x27;) &#125; this.state = PENDING this.value = void 0 this.queue = [] if (resolver !== INTERNAL) &#123; safelyResolveThen(this, resolver) &#125;&#125; 注意：以下 promise 均指代 Promise 实例。 INTERNAL 就是一个空函数，后面会用来传入 Promise 构造函数生成一个 promise 实例。定义了 3 个辅助函数：isFunction、isObject 和 isArray。定义了 3 种状态：PENDING、FULFILLED 和 REJECTED。safelyResolveThen 后面会讲。promise 内部有三个变量： state：当前 promise 的状态，初始值为 PENDING。状态改变只能是 PENDING -&gt; FULFILLED 或 PENDING -&gt; REJECTED。 value：初始值是 void 0（即 undefined），当 state 是 FULFILLED 时存储返回值，当 state 是 REJECTED 时存储错误。 queue：promise 内部的回调队列，后面会讲它的作用。 3.1.3 Promise 实现原理笔者发布了一个 Promise&#x2F;A+ 规范实现的模块——appoint，我们拿这个模块研究一下它是如何实现 Promise 的。看一段代码： 1234567891011const Promise = require(&#x27;appoint&#x27;)const promise = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;haha&#x27;) &#125;, 1000)&#125;)const a = promise.then(function onSuccess () &#123;&#125;)const b = promise.catch(function onError () &#123;&#125;)console.dir(promise, &#123; depth: 10 &#125;)console.log(promise.queue[0].promise === a)console.log(promise.queue[1].promise === b) 运行后打印出： 1234567891011121314Promise &#123; state: &#x27;pending&#x27;, value: undefined, queue: [ QueueItem &#123; promise: Promise &#123; state: &#x27;pending&#x27;, value: undefined, queue: [] &#125;, callFulfilled: [Function], callRejected: [Function] &#125;, QueueItem &#123; promise: Promise &#123; state: &#x27;pending&#x27;, value: undefined, queue: [] &#125;, callFulfilled: [Function], callRejected: [Function] &#125; ] &#125;truetrue 注意：原生 Promise 是没有 queue 属性的，appoint 的实现中添加了这个属性。 可以看出，queue 数组中有两个对象。因为规范中规定：then 方法可以被同一个 promise 调用多次。上例中在调用 .then 和 .catch 时 promise 并没有被 resolve，所以将 .then 和 .catch 生成的新 promise（a 和 b） 和正确时的回调（onSuccess 包装成 callFulfilled）和错误时的回调（onError 包装成 callRejected）生成一个 QueueItem 实例并 push 到 queue 数组里，所以两个 console.log 都打印 true。当 promise 状态改变时遍历内部 queue 数组，统一执行成功（callFulfilled）或失败（callRejected）的回调（传入 promise 的 value 值），生成的结果分别设置 a 和 b 的 state 和 value，这就是 Promise 实现的基本原理。 再来看另一个例子： 1234567891011const Promise = require(&#x27;appoint&#x27;)const promise = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;haha&#x27;) &#125;, 1000)&#125;)promise .then(() =&gt; &#123;&#125;) .then(() =&gt; &#123;&#125;) .then(() =&gt; &#123;&#125;)console.dir(promise, &#123; depth: 10 &#125;) 打印出： 123456789101112131415161718192021222324Promise &#123; state: &#x27;pending&#x27;, value: undefined, queue: [ QueueItem &#123; promise: Promise &#123; state: &#x27;pending&#x27;, value: undefined, queue: [ QueueItem &#123; promise: Promise &#123; state: &#x27;pending&#x27;, value: undefined, queue: [ QueueItem &#123; promise: Promise &#123; state: &#x27;pending&#x27;, value: undefined, queue: [] &#125;, callFulfilled: [Function], callRejected: [Function] &#125; ] &#125;, callFulfilled: [Function], callRejected: [Function] &#125; ] &#125;, callFulfilled: [Function], callRejected: [Function] &#125; ] &#125; 链式调用了 3 次 .then，每次调用 .then 将它生成的 promise 放到了调用它的 promise 队列里，形成了 3 层调用关系。当最外层的 promise 状态改变时，遍历它的 queue 数组调用对应的回调，设置子 promise 的 state 和 value 并遍历它的 queue 数组调用对应的回调……以此类推。 注意：这里 queue 是嵌套的，而不是像上个例子中 queue 是平铺的。 3.1.4 safelyResolveThen接下来完成 safelyResolveThen 的逻辑，代码如下： 123456789101112131415161718192021222324function safelyResolveThen (self, then) &#123; let called = false try &#123; then(function (value) &#123; if (called) &#123; return &#125; called = true doResolve(self, value) &#125;, function (error) &#123; if (called) &#123; return &#125; called = true doReject(self, error) &#125;) &#125; catch (error) &#123; if (called) &#123; return &#125; called = true doReject(self, error) &#125;&#125; safelyResolveThen 顾名思义用来 “安全的执行 then 函数”，这里的 then 函数指 “第一个参数是 resolve 函数第二个参数是 reject 函数的函数”，适用于以下两种情况： 构造函数的参数，即这里的 resolver： 12345new Promise(function resolver (resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve(&#x27;haha&#x27;) &#125;, 1000)&#125;) promise 的 then： 1promise.then(resolve, reject) safelyResolveThen 有 3 个作用： try…catch 用来捕获函数内抛出的异常，如构造函数内抛出异常： 123new Promise(function resolver (resolve, reject) &#123; throw new Error(&#x27;Oops&#x27;)&#125;) called 控制 resolve 或 reject 只执行一次，多次调用没有任何作用。即： 123456789const Promise = require(&#x27;appoint&#x27;)const promise = new Promise(function resolver (resolve, reject) &#123; setTimeout(() =&gt; &#123; resolve(&#x27;haha&#x27;) &#125;, 1000) reject(&#x27;error&#x27;)&#125;)promise.then(console.log)promise.catch(console.error) 打印 error，不会再打印 haha。 没有错误则执行 doResolve，有错误则执行 doReject。 3.1.5 doResolve 和 doRejectdoResolve 和 doReject 相关代码如下： 1234567891011121314151617181920212223242526function doResolve (self, value) &#123; try &#123; const then = getThen(value) if (then) &#123; safelyResolveThen(self, then) &#125; else &#123; self.state = FULFILLED self.value = value self.queue.forEach(function (queueItem) &#123; queueItem.callFulfilled(value) &#125;) &#125; return self &#125; catch (error) &#123; return doReject(self, error) &#125;&#125;function doReject (self, error) &#123; self.state = REJECTED self.value = error self.queue.forEach(function (queueItem) &#123; queueItem.callRejected(error) &#125;) return self&#125; doReject 用来设置 promise 的 state 为 REJECTED，value 为 error，然后遍历 queue，设置所有子 promise 的状态为 REJECTED 和值为 error。doResolve 结合 safelyResolveThen 使用不断地解包 promise，直至返回值是非 promise 对象后，设置 promise 的状态和值，然后设置子 promise 的状态和值。 这里有个辅助函数 getThen： 12345678function getThen (promise) &#123; const then = promise &amp;&amp; promise.then if (promise &amp;&amp; (isObject(promise) || isFunction(promise)) &amp;&amp; isFunction(then)) &#123; return function applyThen () &#123; then.apply(promise, arguments) &#125; &#125;&#125; getThen 实现了规范中规定的：如果 then 是函数，将 x（即被调用的 promise） 作为函数的 this 调用。 3.1.6 Promise.prototype.then 和 Promise.prototype.catch接下来实现 Promise.prototype.then 和 Promise.prototype.catch，代码如下： 123456789101112131415161718Promise.prototype.then = function (onFulfilled, onRejected) &#123; if ((!isFunction(onFulfilled) &amp;&amp; this.state === FULFILLED) || (!isFunction(onRejected) &amp;&amp; this.state === REJECTED)) &#123; return this &#125; const promise = new this.constructor(INTERNAL) if (this.state !== PENDING) &#123; const resolver = this.state === FULFILLED ? onFulfilled : onRejected unwrap(promise, resolver, this.value) &#125; else &#123; this.queue.push(new QueueItem(promise, onFulfilled, onRejected)) &#125; return promise&#125;Promise.prototype.catch = function (onRejected) &#123; return this.then(null, onRejected)&#125; 上述代码中的 return this 实现了值穿透，后面会细讲。可以看出，then 方法中生成了一个新的 promise 然后返回。如果 promise 的状态改变了，则调用 unwrap，否则将生成的 promise 加入到当前 promise 的回调队列 queue 里，之前已经讲解了如何消费 queue。有 3 点需要讲解： Promise 构造函数传入了一个 INTERNAL 空函数，因为这个新产生的 promise 可以认为是内部的 promise，需要根据外部的 promise 的状态和值产生自身的状态和值，不需要传入回调函数，而外部 Promise 需要传入回调函数决定它的状态和值，所以之前 Promise 的构造函数里做了判断区分外部调用还是内部调用： 123if (resolver !== INTERNAL) &#123; safelyResolveThen(this, resolver)&#125; QueueItem 代码如下： 12345678910111213141516171819function QueueItem (promise, onFulfilled, onRejected) &#123; this.promise = promise this.callFulfilled = function (value) &#123; doResolve(this.promise, value) &#125; this.callRejected = function (error) &#123; doReject(this.promise, error) &#125; if (isFunction(onFulfilled)) &#123; this.callFulfilled = function (value) &#123; unwrap(this.promise, onFulfilled, value) &#125; &#125; if (isFunction(onRejected)) &#123; this.callRejected = function (error) &#123; unwrap(this.promise, onRejected, error) &#125; &#125;&#125; promise 为 then 生成的新 promise，onFulfilled 和 onRejected 即是 then 参数中的 onFulfilled 和 onRejected。从上面代码可以看出：当 promise 状态变为 FULFILLED 时，之前注册的 then 函数通过 callFulfilled 调用 unwrap 进行解包最终得出 promise 的状态和值；之前注册的 catch 函数，用 callRejected 直接调用 doReject，设置队列里 promise 的状态和值。当 promise 状态变为 REJECTED 类似。 unwrap 代码如下： 123456789101112131415function unwrap (promise, func, value) &#123; process.nextTick(function () &#123; let returnValue try &#123; returnValue = func(value) &#125; catch (error) &#123; return doReject(promise, error) &#125; if (returnValue === promise) &#123; doReject(promise, new TypeError(&#x27;Cannot resolve promise with itself&#x27;)) &#125; else &#123; doResolve(promise, returnValue) &#125; &#125;)&#125; unwrap 函数从名字也可以看出是用来解包的，即拿到父 promise 的结果设置当前 promise 的状态和值。第一个参数是 promise，第二个参数是父 promise 的 then 的回调（onFulfilled&#x2F;onRejected），第三个参数是父 promise 的值（正常值&#x2F;错误）。有 3 点需要说明： 使用 process.nextTick 将代码异步执行，这也是规范里明确规定的。看一段代码： 123456789101112const Promise = require(&#x27;appoint&#x27;)const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;haha&#x27;) &#125;, 1000)&#125;)promise.then(() =&gt; &#123; promise.then(() =&gt; &#123; console.log(&#x27;1&#x27;) &#125;) console.log(&#x27;2&#x27;)&#125;) 打印 2 1，去掉 process.nextTick 则打印 1 2。 try…catch 用来捕获 then&#x2F;catch 函数内抛出的异常，并调用 doReject，如： 123456promise.then(() =&gt; &#123; throw new Error(&#x27;haha&#x27;)&#125;)promise.catch(() =&gt; &#123; throw new Error(&#x27;haha&#x27;)&#125;) 返回的值不能是 promise 本身，否则会造成死循环，如下代码： 12345678910const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;haha&#x27;) &#125;, 1000)&#125;)const a = promise.then(() =&gt; &#123; return a&#125;)a.catch(console.log)// [TypeError: Chaining cycle detected for promise #&lt;Promise&gt;] 注意：promise.catch(onRejected) 就是 promise.then(null, onRejected) 的语法糖。 至此，Promise 的核心部分就实现完了。 3.1.7 值穿透上面提到过好几次值穿透，什么是值穿透呢？上面的 Promise.prototype.then 的实现中有这么一段代码： 1234567Promise.prototype.then = function (onFulfilled, onRejected) &#123; if ((!isFunction(onFulfilled) &amp;&amp; this.state === FULFILLED) || (!isFunction(onRejected) &amp;&amp; this.state === REJECTED)) &#123; return this &#125; ...&#125;; 值穿透即传入 then&#x2F;catch 的参数如果不为函数，则忽略该值，返回上一个 promise 的结果。看一段代码： 12345678const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;haha&#x27;) &#125;, 1000)&#125;)promise .then(&#x27;hehe&#x27;) .then(console.log) 最终打印 haha 而不是 hehe。 通过 return this 只实现了值穿透的一种情况，其实值穿透有两种情况： promise 已经是 FULFILLED&#x2F;REJECTED 时，通过 return this 实现的值穿透： 12345678910111213141516const Promise = require(&#x27;appoint&#x27;)const promise = new Promise(function (resolve) &#123; setTimeout(() =&gt; &#123; resolve(&#x27;haha&#x27;) &#125;, 1000)&#125;)promise.then(() =&gt; &#123; promise.then().then((res) =&gt; &#123;// (1) console.log(res)// haha &#125;) promise.catch().then((res) =&gt; &#123;// (2) console.log(res)// haha &#125;) console.log(promise.then() === promise.catch())// true console.log(promise.then(1) === promise.catch(&#123; name: &#x27;nswbmw&#x27; &#125;))// true&#125;) 上述代码 (1)、(2) 处 promise 已经是 FULFILLED 了符合条件所以执行了 return this。 promise 是 PENDING 时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 状态改变时调用 callFulfilled-&gt;doResolve 或 callRejected-&gt;doReject（因为 then&#x2F;catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态和值。看一段代码： 123456789101112131415const Promise = require(&#x27;appoint&#x27;)const promise = new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;haha&#x27;) &#125;, 1000)&#125;)const a = promise.then()a.then((res) =&gt; &#123; console.log(res)// haha&#125;)const b = promise.catch()b.then((res) =&gt; &#123; console.log(res)// haha&#125;)console.log(a === b)// false 3.1.8 Promise.resolve 和 Promise.rejectPromise.resolve 和 Promise.reject 是 Promise 的两个静态方法，用来快捷的生成一个状态为 fulfilled 或者 rejected 的 promise 实例。代码如下： 123456789101112Promise.resolve = resolvefunction resolve (value) &#123; if (value instanceof this) &#123; return value &#125; return doResolve(new this(INTERNAL), value)&#125;Promise.reject = rejectfunction reject (reason) &#123; return doReject(new this(INTERNAL), reason)&#125; 当 Promise.resolve 参数是一个 promise 时，直接返回该值。 3.1.9 Promise.allPromise.all 接收一个数组，用来并行执行一组 promise。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738Promise.all = allfunction all (iterable) &#123; const self = this if (!isArray(iterable)) &#123; return this.reject(new TypeError(&#x27;must be an array&#x27;)) &#125; const len = iterable.length let called = false if (!len) &#123; return this.resolve([]) &#125; const values = new Array(len) let resolved = 0 let i = -1 const promise = new this(INTERNAL) while (++i &lt; len) &#123; allResolver(iterable[i], i) &#125; return promise function allResolver (value, i) &#123; self.resolve(value).then(resolveFromAll, function (error) &#123; if (!called) &#123; called = true doReject(promise, error) &#125; &#125;) function resolveFromAll (outValue) &#123; values[i] = outValue if (++resolved === len &amp;&amp; !called) &#123; called = true doResolve(promise, values) &#125; &#125; &#125;&#125; Promise.all 用来并行执行多个 promise&#x2F;值，当所有 promise&#x2F;值执行完毕或有一个 promise 状态变为 rejected 时返回。以上代码可以看出： Promise.all 内部生成了一个新的 promise 返回。 called 用来控制即使有多个 promise rejected 也只有第一个生效。 values 用来存储执行结果。 当最后一个 promise 状态改变后，使用 doResolve(promise, values) 设置 promise 的 state 为 FULFILLED，value 为结果数组 values。 3.1.10 Promise.racePromise.race 接收一个数组，当数组中有一个 promise 状态发生改变（ pending -&gt; fulfilled&#x2F;rejected）时返回。 12345678910111213141516171819202122232425262728293031323334Promise.race = racefunction race (iterable) &#123; const self = this if (!isArray(iterable)) &#123; return this.reject(new TypeError(&#x27;must be an array&#x27;)) &#125; const len = iterable.length let called = false if (!len) &#123; return this.resolve([]) &#125; let i = -1 const promise = new this(INTERNAL) while (++i &lt; len) &#123; resolver(iterable[i]) &#125; return promise function resolver (value) &#123; self.resolve(value).then(function (response) &#123; if (!called) &#123; called = true doResolve(promise, response) &#125; &#125;, function (error) &#123; if (!called) &#123; called = true doReject(promise, error) &#125; &#125;) &#125;&#125; Promise.race 与 Promise.all 代码相近，只不过这里用 called 控制只要有任何一个 promise 状态改变则立即去设置返回的 promise 的状态和值。 至此，Promise 的实现全部讲解完毕。 3.1.11 十道题现在，我们以十道题巩固一下前面所学到的 Promise 的知识点。 题目一123456789const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) resolve() console.log(2)&#125;)promise.then(() =&gt; &#123; console.log(3)&#125;)console.log(4) 运行结果： 12341243 解释：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。 题目二12345678910111213141516const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;success&#x27;) &#125;, 1000)&#125;)const promise2 = promise1.then(() =&gt; &#123; throw new Error(&#x27;error!!!&#x27;)&#125;)console.log(&#x27;promise1&#x27;, promise1)console.log(&#x27;promise2&#x27;, promise2)setTimeout(() =&gt; &#123; console.log(&#x27;promise1&#x27;, promise1) console.log(&#x27;promise2&#x27;, promise2)&#125;, 2000) 运行结果： 123456789promise1 Promise &#123; &lt;pending&gt; &#125;promise2 Promise &#123; &lt;pending&gt; &#125;(node:50928) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: error!!!(node:50928) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.promise1 Promise &#123; &#x27;success&#x27; &#125;promise2 Promise &#123; &lt;rejected&gt; Error: error!!! at promise.then (...) at &lt;anonymous&gt; &#125; 解释：promise 有 3 种状态：pending、fulfilled 或 rejected。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。上面的 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。 题目三12345678910111213const promise = new Promise((resolve, reject) =&gt; &#123; resolve(&#x27;success1&#x27;) reject(&#x27;error&#x27;) resolve(&#x27;success2&#x27;)&#125;)promise .then((res) =&gt; &#123; console.log(&#x27;then: &#x27;, res) &#125;) .catch((err) =&gt; &#123; console.log(&#x27;catch: &#x27;, err) &#125;) 运行结果： 1then: success1 解释：构造函数中的 resolve 或 reject 只有在第 1 次执行时有效，多次调用没有任何作用，再次印证代码二的结论：promise 状态一旦改变则不能再变。 再看两个例子： 1234567891011const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) return Promise.reject(new Error(&#x27;haha&#x27;))&#125;)promise.then((res) =&gt; &#123; console.log(2, res)&#125;).catch((err) =&gt; &#123; console.error(3, err)&#125;)console.log(4)console.log(promise) 运行结果： 1234567891011121314151614Promise &#123; &lt;pending&gt; &#125;(node:22493) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: haha(node:22493) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.const promise = new Promise((resolve, reject) =&gt; &#123; console.log(1) throw new Error(&#x27;haha&#x27;)&#125;)promise.then((res) =&gt; &#123; console.log(2, res)&#125;).catch((err) =&gt; &#123; console.error(3, err)&#125;)console.log(4)console.log(promise) 运行结果： 12345678914Promise &#123; &lt;rejected&gt; Error: haha at Promise (/Users/nswbmw/Desktop/test/app.js:6:9) ...3 Error: haha at Promise (/Users/nswbmw/Desktop/test/app.js:6:9) ... 解释：构造函数内只能通过调用 resolve(pending-&gt;fullfiled) 或者 reject(pending-&gt;rejected) 或者 throw 一个 error(pending-&gt;rejected) 改变状态。所以第一个例子的 promise 状态是 pending，也就不会调用 .then&#x2F;.catch。 题目四1234567891011Promise.resolve(1) .then((res) =&gt; &#123; console.log(res) return 2 &#125;) .catch((err) =&gt; &#123; return 3 &#125;) .then((res) =&gt; &#123; console.log(res) &#125;) 运行结果： 1212 解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 在每次调用 .then 或者 .catch 时都会返回一个新的 promise，从而可以实现链式调用。 题目五1234567891011121314const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;once&#x27;) resolve(&#x27;success&#x27;) &#125;, 1000)&#125;)const start = Date.now()promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;)promise.then((res) =&gt; &#123; console.log(res, Date.now() - start)&#125;) 运行结果： 123oncesuccess 1005success 1007 解释：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说，promise 内部状态一经改变，并且有了一个值，则后续在每次调用 .then 或者 .catch 时都会直接拿到该值。 题目六12345678910Promise.resolve() .then(() =&gt; &#123; return new Error(&#x27;error!!!&#x27;) &#125;) .then((res) =&gt; &#123; console.log(&#x27;then: &#x27;, res) &#125;) .catch((err) =&gt; &#123; console.log(&#x27;catch: &#x27;, err) &#125;) 运行结果： 123then: Error: error!!! at Promise.resolve.then (...) at ... 解释：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成如下其中一种： return Promise.reject(new Error(‘error!!!’)) throw new Error(‘error!!!’) 因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(&#39;error!!!&#39;) 等价于 return Promise.resolve(new Error(&#39;error!!!&#39;))。 题目七12345const promise = Promise.resolve() .then(() =&gt; &#123; return promise &#125;)promise.catch(console.error) 运行结果： 123456TypeError: Chaining cycle detected for promise #&lt;Promise&gt; at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:188:7) at Function.Module.runMain (module.js:667:11) at startup (bootstrap_node.js:187:16) at bootstrap_node.js:607:3 解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于： 1234process.nextTick(function tick () &#123; console.log(&#x27;tick&#x27;) process.nextTick(tick)&#125;) 题目八1234Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 运行结果： 11 解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。 题目九123456789Promise.resolve() .then(function success (res) &#123; throw new Error(&#x27;error&#x27;) &#125;, function fail1 (e) &#123; console.error(&#x27;fail1: &#x27;, e) &#125;) .catch(function fail2 (e) &#123; console.error(&#x27;fail2: &#x27;, e) &#125;) 运行结果： 123fail2: Error: error at success (...) at ... 解释：.then 可以接收两个参数，第 1 个是处理成功的函数，第 2 个是处理错误的函数。.catch 是 .then 第 2 个参数的简便写法，但是在用法上有一点需要注意：.then 的第 2 个处理错误的函数（fail1）捕获不了第 1 个处理成功的函数（success）抛出的错误，而后续的 .catch 方法（fail2）可以捕获之前的错误。当然，以下代码也可以： 12345678910Promise.resolve() .then(function success1 (res) &#123; throw new Error(&#x27;error&#x27;) &#125;, function fail1 (e) &#123; console.error(&#x27;fail1: &#x27;, e) &#125;) .then(function success2 (res) &#123; &#125;, function fail2 (e) &#123; console.error(&#x27;fail2: &#x27;, e) &#125;) 题目十1234567891011Promise.resolve() .then(() =&gt; &#123; console.log(&#x27;then&#x27;) &#125;)process.nextTick(() =&gt; &#123; console.log(&#x27;nextTick&#x27;)&#125;)setImmediate(() =&gt; &#123; console.log(&#x27;setImmediate&#x27;)&#125;)console.log(&#x27;end&#x27;) 运行结果： 1234endnextTickthensetImmediate 解释：process.nextTick 和 promise.then 都属于 microtask（但 process.nextTick 的优先级大于 promise.then），而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，以上代码本身（macrotask）在执行完后会执行一次 microtask。 3.1.12 参考链接 http://es6.ruanyifeng.com/#docs/promise https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise https://promisesaplus.com/","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 2.4 Cpu-memory monitor","slug":"2.4.1 使用 cpu-memory-monitor","date":"2019-04-18T06:00:00.000Z","updated":"2022-05-25T04:23:07.031Z","comments":true,"path":"2019/04/18/2.4.1 使用 cpu-memory-monitor/","link":"","permalink":"https://marvinliu1.github.io/2019/04/18/2.4.1%20%E4%BD%BF%E7%94%A8%20cpu-memory-monitor/","excerpt":"","text":"Node in Debugging 前面介绍了 heapdump 和 memwatch-next 的用法，但在实际使用时并不那么方便，我们总不能一直盯着服务器的状况，在发现内存持续增长并超过心里的阈值时，再手动去触发 Core Dump 吧？在大多数情况下发现问题时，就已经错过了现场。所以，我们可能需要 cpu-memory-monitor。顾名思义，这个模块可以用来监控 CPU 和 Memory 的使用情况，并可以根据配置策略自动 dump CPU 的使用情况（cpuprofile）和内存快照（heapsnapshot）。 2.4.1 使用 cpu-memory-monitor我们先来看看如何使用 cpu-memory-monitor，其实很简单，只需在进程启动的入口文件中引入以下代码： 12345678910require(&#x27;cpu-memory-monitor&#x27;)(&#123; cpu: &#123; interval: 1000, duration: 30000, threshold: 60, profileDir: &#x27;/tmp&#x27;, counter: 3, limiter: [5, &#x27;hour&#x27;] &#125;&#125;) 上述代码的作用是：每 1000ms(interval)检查一次 CPU 的使用情况，如果发现连续 3(counter)次 CPU 使用率大于 60%(threshold)，则 dump 30000ms(duration) CPU 的使用情况，生成 cpu-$&#123;process.pid&#125;-$&#123;Date.now()&#125;.cpuprofile 到 &#x2F;tmp(profileDir) 目录下，1(limiter[1]) 小时最多 dump 5(limiter[0]) 次。 以上是自动 dump CPU 使用情况的策略。dump Memory 使用情况的策略同理： 123456789require(&#x27;cpu-memory-monitor&#x27;)(&#123; memory: &#123; interval: 1000, threshold: &#x27;1.2gb&#x27;, profileDir: &#x27;/tmp&#x27;, counter: 3, limiter: [3, &#x27;hour&#x27;] &#125;&#125;) 上述代码的作用是：每 1000ms(interval) 检查一次 Memory 的使用情况，如果发现连续 3(counter) 次 Memory 大于 1.2gb(threshold)，则 dump 一次 Memory，生成 memory-$&#123;process.pid&#125;-$&#123;Date.now()&#125;.heapsnapshot 到 &#x2F;tmp(profileDir) 目录下，1(limiter[1]) 小时最多 dump 3(limiter[0]) 次。 注意：memory 的配置没有 duration 参数，因为 Memroy 的 dump 只是某一时刻的，而不是一段时间的。 聪明的你肯定会问了：能不能将 cpu 和 memory 配置一块使用？比如： 12345678910111213require(&#x27;cpu-memory-monitor&#x27;)(&#123; cpu: &#123; interval: 1000, duration: 30000, threshold: 60, ... &#125;, memory: &#123; interval: 10000, threshold: &#x27;1.2gb&#x27;, ... &#125;&#125;) 答案是：可以，但不要这么做。因为这样做可能会出现这种情况：内存高了且达到设定的阈值 -&gt; 触发 Memory Dump&#x2F;GC -&gt; 导致 CPU 使用率高且达到设定的阈值 -&gt; 触发 CPU Dump -&gt; 导致堆积的请求越来越多（比如内存中堆积了很多 SQL 查询）-&gt; 触发 Memory Dump -&gt; 导致雪崩。 通常情况下，只使用其中一种就可以了。 2.4.2 源码解读cpu-memory-monitor 的源代码不过百余行，大体逻辑如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253...const processing = &#123; cpu: false, memory: false&#125;const counter = &#123; cpu: 0, memory: 0&#125;function dumpCpu(cpuProfileDir, cpuDuration) &#123; ... &#125;function dumpMemory(memProfileDir) &#123; ... &#125;module.exports = function cpuMemoryMonitor(options = &#123;&#125;) &#123; ... if (options.cpu) &#123; const cpuTimer = setInterval(() =&gt; &#123; if (processing.cpu) &#123; return &#125; pusage.stat(process.pid, (err, stat) =&gt; &#123; if (err) &#123; clearInterval(cpuTimer) return &#125; if (stat.cpu &gt; cpuThreshold) &#123; counter.cpu += 1 if (counter.cpu &gt;= cpuCounter) &#123; memLimiter.removeTokens(1, (limiterErr, remaining) =&gt; &#123; if (limiterErr) &#123; return &#125; if (remaining &gt; -1) &#123; dumpCpu(cpuProfileDir, cpuDuration) counter.cpu = 0 &#125; &#125;) &#125; else &#123; counter.cpu = 0 &#125; &#125; &#125;) &#125;, cpuInterval) &#125; if (options.memory) &#123; ... memwatch.on(&#x27;leak&#x27;, () =&gt; &#123; dumpMemory(...) &#125;) &#125;&#125; 可以看出：cpu-memory-monitor 没有用到什么新鲜的东西，还是之前讲解过的 v8-profiler、heapdump、memwatch-next 的组合使用而已。 有以下几点需要注意： 只有传入了 cpu 或者 memory 的配置，才会去监听相应的 CPU 或者 Memory。 在传入 memory 配置时，因为用 memwatch-next 额外监听了 leak 事件，也会 dump Memory，格式是 leak-memory-$&#123;process.pid&#125;-$&#123;Date.now()&#125;.heapsnapshot。 顶部引入了 heapdump，所以即使没有 memory 配置，也可以通过 kill -USR2 &lt;PID&gt; 手动触发 Memory Dump。 2.4.3 参考链接 https://github.com/node-inspector/v8-profiler https://github.com/bnoordhuis/node-heapdump https://github.com/marcominetti/node-memwatch","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 2.3 How to use memwatch-next","slug":"2.3.1 使用 memwatch-next","date":"2019-04-13T06:00:00.000Z","updated":"2022-05-25T04:23:07.031Z","comments":true,"path":"2019/04/13/2.3.1 使用 memwatch-next/","link":"","permalink":"https://marvinliu1.github.io/2019/04/13/2.3.1%20%E4%BD%BF%E7%94%A8%20memwatch-next/","excerpt":"","text":"Node in Debugging memwatch-next（以下简称 memwatch）是一个用来监测 Node.js 的内存泄漏和堆信息比较的模块。下面我们以一段事件监听器导致内存泄漏的代码为例，讲解如何使用 memwatch。 2.3.1 使用 memwatch-next测试代码如下： app.js 12345678910111213141516171819let count = 1const memwatch = require(&#x27;memwatch-next&#x27;)memwatch.on(&#x27;stats&#x27;, (stats) =&gt; &#123; console.log(count++, stats)&#125;)memwatch.on(&#x27;leak&#x27;, (info) =&gt; &#123; console.log(&#x27;---&#x27;) console.log(info) console.log(&#x27;---&#x27;)&#125;)const http = require(&#x27;http&#x27;)const server = http.createServer((req, res) =&gt; &#123; for (let i = 0; i &lt; 10000; i++) &#123; server.on(&#x27;request&#x27;, function leakEventCallback() &#123;&#125;) &#125; res.end(&#x27;Hello World&#x27;) global.gc()&#125;).listen(3000) 在每个请求到来时，在 server 上注册 10000 个 request 事件的监听函数（大量的事件监听函数存储到内存中，从而造成了内存泄漏），然后手动触发一次 GC。 运行该程序： 1$ node --expose-gc app.js 注意：这里添加 –expose-gc 参数启动程序，这样我们才可以在程序中手动触发 GC。 memwatch 监听以下两个事件： stats：GC 事件，每执行一次 GC，都会触发该函数，打印 heap 相关的信息。如下： 12345678910&#123; num_full_gc: 1,// 完整的垃圾回收次数 num_inc_gc: 1,// 增长的垃圾回收次数 heap_compactions: 1,// 内存压缩次数 usage_trend: 0,// 使用趋势 estimated_base: 5350136,// 预期基数 current_base: 5350136,// 当前基数 min: 0,// 最小值 max: 0// 最大值&#125; leak：可疑的内存泄露事件，触发该事件的条件是：内存在连续 5 次 GC 后都是增长的。打印如下： 1234&#123; growth: 4051464, reason: &#x27;heap growth over 5 consecutive GCs (2s) - -2147483648 bytes/hr&#x27;&#125; 运行： 1$ ab -c 1 -n 5 http://localhost:3000/ 输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445(node:20989) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 request listeners added. Use emitter.setMaxListeners() to increase limit1 &#123; num_full_gc: 1, num_inc_gc: 1, heap_compactions: 1, usage_trend: 0, estimated_base: 5720064, current_base: 5720064, min: 0, max: 0 &#125;2 &#123; num_full_gc: 2, num_inc_gc: 1, heap_compactions: 2, usage_trend: 0, estimated_base: 7073824, current_base: 7073824, min: 0, max: 0 &#125;3 &#123; num_full_gc: 3, num_inc_gc: 1, heap_compactions: 3, usage_trend: 0, estimated_base: 7826368, current_base: 7826368, min: 7826368, max: 7826368 &#125;4 &#123; num_full_gc: 4, num_inc_gc: 1, heap_compactions: 4, usage_trend: 0, estimated_base: 8964784, current_base: 8964784, min: 7826368, max: 8964784 &#125;---&#123; growth: 3820272, reason: &#x27;heap growth over 5 consecutive GCs (0s) - -2147483648 bytes/hr&#x27; &#125;---5 &#123; num_full_gc: 5, num_inc_gc: 1, heap_compactions: 5, usage_trend: 0, estimated_base: 9540336, current_base: 9540336, min: 7826368, max: 9540336 &#125; 可以看出：Node.js 已经警告我们事件监听器超过了 11 个，可能造成内存泄露。连续 5 次内存增长触发 leak 事件打印出增长了多少内存（bytes）和预估每小时增长多少 bytes。 2.3.2 Heap Diffingmemwatch 有一个 HeapDiff 函数，用来对比并计算出两次堆快照的差异。修改测试代码如下： 123456789101112131415const memwatch = require(&#x27;memwatch-next&#x27;)const http = require(&#x27;http&#x27;)const server = http.createServer((req, res) =&gt; &#123; for (let i = 0; i &lt; 10000; i++) &#123; server.on(&#x27;request&#x27;, function leakEventCallback() &#123;&#125;) &#125; res.end(&#x27;Hello World&#x27;) global.gc()&#125;).listen(3000)const hd = new memwatch.HeapDiff()memwatch.on(&#x27;leak&#x27;, (info) =&gt; &#123; const diff = hd.end() console.dir(diff, &#123; depth: 10 &#125;)&#125;) 运行这段代码并执行同样的 ab 命令，打印如下： 1234567891011121314151617181920212223&#123; before: &#123; nodes: 35727, size_bytes: 4725128, size: &#x27;4.51 mb&#x27; &#125;, after: &#123; nodes: 87329, size_bytes: 8929792, size: &#x27;8.52 mb&#x27; &#125;, change: &#123; size_bytes: 4204664, size: &#x27;4.01 mb&#x27;, freed_nodes: 862, allocated_nodes: 52464, details: [ ... &#123; what: &#x27;Array&#x27;, size_bytes: 530200, size: &#x27;517.77 kb&#x27;, &#x27;+&#x27;: 1023, &#x27;-&#x27;: 510 &#125;, &#123; what: &#x27;Closure&#x27;, size_bytes: 3599856, size: &#x27;3.43 mb&#x27;, &#x27;+&#x27;: 50001, &#x27;-&#x27;: 3 &#125;, ... ] &#125;&#125; 可以看出：内存由 4.51mb 涨到了 8.52mb，其中 Closure 和 Array 涨了绝大部分，而我们知道注册事件监听函数的本质就是将事件函数（Closure）push 到相应的数组（Array）里。 2.3.3 结合 heapdumpmemwatch 在结合 heapdump 使用时才能发挥更好的作用。通常用 memwatch 监测到内存泄漏，用 heapdump 导出多份堆快照，然后用 Chrome DevTools 分析和比较，定位内存泄漏的元凶。 修改代码如下： 123456789101112131415161718192021222324const memwatch = require(&#x27;memwatch-next&#x27;)const heapdump = require(&#x27;heapdump&#x27;)const http = require(&#x27;http&#x27;)const server = http.createServer((req, res) =&gt; &#123; for (let i = 0; i &lt; 10000; i++) &#123; server.on(&#x27;request&#x27;, function leakEventCallback() &#123;&#125;) &#125; res.end(&#x27;Hello World&#x27;) global.gc()&#125;).listen(3000)dump()memwatch.on(&#x27;leak&#x27;, () =&gt; &#123; dump()&#125;)function dump() &#123; const filename = `$&#123;__dirname&#125;/heapdump-$&#123;process.pid&#125;-$&#123;Date.now()&#125;.heapsnapshot` heapdump.writeSnapshot(filename, () =&gt; &#123; console.log(`$&#123;filename&#125; dump completed.`) &#125;)&#125; 以上程序在启动后先执行一次 heap dump，当触发 leak 事件时再执行一次 heap dump。运行这段代码并执行同样的 ab 命令，生成两个 heapsnapshot 文件： 12heapdump-21126-1519545957879.heapsnapshotheapdump-21126-1519545975702.heapsnapshot 用 Chrome DevTools 加载这两个 heapsnapshot 文件，选择 comparison 比较视图，如下所示： 可以看出：增加了 5 万个 leakEventCallback 函数，单击其中任意一个，可以从 Retainers 中看到更详细的信息，例如 GC path 和所在的文件等信息。 2.3.4 参考链接 https://github.com/marcominetti/node-memwatch","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 2.2 About heapdump","slug":"2.2.1 使用 heapdump","date":"2019-04-12T06:00:00.000Z","updated":"2022-05-25T04:23:07.031Z","comments":true,"path":"2019/04/12/2.2.1 使用 heapdump/","link":"","permalink":"https://marvinliu1.github.io/2019/04/12/2.2.1%20%E4%BD%BF%E7%94%A8%20heapdump/","excerpt":"","text":"Node in Debugging heapdump 是一个 dump V8 堆信息的工具。v8-profiler 也包含了这个功能，这两个工具的原理都是一致的，都是 v8::Isolate::GetCurrent()-&gt;GetHeapProfiler()-&gt;TakeHeapSnapshot(title, control)，但是 heapdump 的使用简单些。下面我们以 heapdump 为例讲解如何分析 Node.js 的内存泄漏。 2.2.1 使用 heapdump这里以一段经典的内存泄漏代码作为测试代码： app.js 12345678910111213141516171819const heapdump = require(&#x27;heapdump&#x27;)let leakObject = nulllet count = 0setInterval(function testMemoryLeak() &#123; const originLeakObject = leakObject const unused = function () &#123; if (originLeakObject) &#123; console.log(&#x27;originLeakObject&#x27;) &#125; &#125; leakObject = &#123; count: String(count++), leakStr: new Array(1e7).join(&#x27;*&#x27;), leakMethod: function () &#123; console.log(&#x27;leakMessage&#x27;) &#125; &#125;&#125;, 1000) 为什么这段程序会发生内存泄漏呢？首先我们要明白闭包的原理：同一个函数内部的闭包作用域只有一个，所有闭包共享。在执行函数的时候，如果遇到闭包，则会创建闭包作用域的内存空间，将该闭包所用到的局部变量添加进去，然后再遇到闭包时，会在之前创建好的作用域空间添加此闭包会用到而前闭包没用到的变量。函数结束时，会清除没有被闭包作用域引用的变量。 这段代码内存泄露原因是：在 testMemoryLeak 函数内有两个闭包：unused 和 leakMethod。unused 这个闭包引用了父作用域中的 originLeakObject 变量，如果没有后面的 leakMethod，则会在函数结束后被清除，闭包作用域也跟着被清除了。因为后面的 leakObject 是全局变量，即 leakMethod 是全局变量，它引用的闭包作用域（包含了 unused 所引用的 originLeakObject）不会释放。而随着 testMemoryLeak 不断的调用，originLeakObject 指向前一次的 leakObject，下次的 leakObject.leakMethod 又会引用之前的 originLeakObject，从而形成一个闭包引用链，而 leakStr 是一个大字符串，得不到释放，从而造成了内存泄漏。 解决方法：在 testMemoryLeak 函数内部的最后添加 originLeakObject = null 即可。 运行测试代码： 1$ node app 然后先后执行两次： 1$ kill -USR2 `pgrep -n node` 在当前目录下生成了两个 heapsnapshot 文件： 12heapdump-100427359.61348.heapsnapshotheapdump-100438986.797085.heapsnapshot 2.2.2 Chrome DevTools我们使用 Chrome DevTools 来分析前面生成的 heapsnapshot 文件。调出 Chrome DevTools -&gt; Memory -&gt; Load，按顺序依次加载前面生成的 heapsnapshot 文件。单击第 2 个堆快照，在左上角有个下拉菜单，有如下 4 个选项： Summary：以构造函数名分类显示。 Comparison：比较多个快照之间的差异。 Containment：查看整个 GC 路径。 Statistics：以饼状图显示内存占用信息。 通常我们只会用前两个选项；第 3 个选项一般用不到，因为在展开 Summary 和 Comparison 中的每一项时，都可以看到从 GC roots 到这个对象的路径；第 4 个选项只能看到内存占用比，如下图所示： 切换到 Summary 页，可以看到有如下 5 个属性： Contructor：构造函数名，例如 Object、Module、Socket，(array)、(string)、(regexp) 等加了括号的分别代表内置的 Array、String 和 Regexp。 Distance：到 GC roots （GC 根对象）的距离。GC 根对象在浏览器中一般是 window 对象，在 Node.js 中是 global 对象，距离越大，则说明引用越深。 Objects Count：对象个数。 Shallow Size：对象自身的大小，不包括它引用的对象。 Retained Size：对象自身的大小和它引用的对象的大小，即该对象被 GC 之后所能回收的内存大小。 小提示：一个对象的 Retained Size &#x3D; 该对象的 Shallow Size + 该对象支配树上其子节点的 Retained Size 之和。Shallow Size &#x3D;&#x3D; Retained Size 的有 (boolean)、(number)、(string)，它们无法引用其他值，并且始终是叶子节点。 单击 Retained Size 选择降序展示，可以看到 (closure) 这一项引用的内容达到 98%，继续展开如下： 可以看出：一个 leakStr 占了 8% 的内存，而 leakMethod 引用了 81% 的内存。对象保留树（Retainers，老版本 Chrome 中叫 Object’s retaining tree）展示了对象的 GC path，单击如上图中的 leakStr（Distance 是 13），Retainers 会自动展开，Distance 从 13 递减到 1。 继续展开 leakMethod，如下所示： 可以看出：有一个 count&#x3D;”10” 的 originLeakObject 的 leakMethod 函数的 context（即上下文） 引用了一个 count&#x3D;”9” 的 originLeakObject 对象，而这个 originLeakObject 对象的 leakMethod 函数的 context 又引用了 count&#x3D;”8” 的 originLeakObject 对象，以此类推。而每个 originLeakObject 对象上都有一个大字符串 leakStr（占用 8% 的内存），从而造成内存泄漏，符合我们之前的推断。 小提示：如果背景色是黄色的，则表示这个对象在 JavaScript 中还存在引用，所以可能没有被清除。如果背景色是红色的，则表示这个对象在 JavaScript 中不存在引用，但是依然存活在内存中，一般常见于 DOM 对象，它们存放的位置和 JavaScript 中的对象还是有不同的，在 Node.js 中很少遇见。 2.2.3 对比快照切换到 Comparison 视图下，可以看到 #New、#Deleted、#Delta 等属性，+ 和 - 表示相对于比较的堆快照而言。我们对比第 2 个快照和第 1 个快照，如下所示： 可以看出：(string) 增加了 10 个，每个 string 大小为 10000024 字节。 2.2.4 参考链接 https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156 https://www.zhihu.com/question/56806069 http://taobaofed.org/blog/2016/04/15/how-to-find-memory-leak/ https://developers.google.com/web/tools/chrome-devtools/memory-problems/memory-101","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 2.1 Core & Core Dump","slug":"2.1.1 Core & Core Dump","date":"2019-04-07T06:00:00.000Z","updated":"2022-05-25T04:23:07.031Z","comments":true,"path":"2019/04/07/2.1.1 Core & Core Dump/","link":"","permalink":"https://marvinliu1.github.io/2019/04/07/2.1.1%20Core%20&%20Core%20Dump/","excerpt":"","text":"Node in Debugging 2.1.1 Core &amp; Core Dump在开始之前，我们先了解下什么是 Core 和 Core Dump。 什么是 Core? 在使用半导体作为内存材料前，人类用线圈作为内存的材料，线圈就叫作 core ，用线圈做的内存就叫作 core memory。如今，半导体工业蓬勃发展，已经没有人用 core memory 了，不过在许多情况下，人们还是把记忆体叫作 core 。 什么是 Core Dump? 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫作 Core Dump（中文翻译成 “核心转储”)。我们可以认为 Core Dump 是 “内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。Core Dump 对于编程人员诊断和调试程序是非常有帮助的，因为有些程序中的错误是很难重现的，例如指针异常，而 Core Dump 文件可以再现程序出错时的情景。 测试环境 12$ uname -aLinux nswbmw-VirtualBox 4.13.0-36-generic #40~16.04.1-Ubuntu SMP Fri Feb 16 23:25:58 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 开启 Core Dump 在终端中输入： 1$ ulimit -c 查看允许 Core Dump 生成的文件的大小，如果是 0 则表示关闭了 Core Dump。使用以下命令开启 Core Dump，并且不限制 Core Dump 生成的文件大小： 1$ ulimit -c unlimited 以上命令只在当前终端环境下有效，如果想永久生效，就需要修改 &#x2F;etc&#x2F;security&#x2F;limits.conf 文件，如下： 2.1.2 gcore使用 gcore 可以不重启程序而 dump 出特定进程的 core 文件。gcore 使用方法如下： 1$ gcore [-o filename] pid 在 Core Dump 时，默认会在执行 gcore 命令的目录生成 core. 文件。 2.1.3 llnode什么是 llnode？ Node.js v4.x+ C++ plugin for LLDB - a next generation, high-performance debugger. 什么是 LLDB？ LLDB is a next generation, high-performance debugger. It is built as a set of reusable components which highly leverage existing libraries in the larger LLVM Project, such as the Clang expression parser and LLVM disassembler. 安装 llnode + lldb： 12345678910111213141516171819$ sudo apt-get update# Clone llnode$ git clone https://github.com/nodejs/llnode.git ~/llnode &amp;&amp; cd ~/llnode# Install lldb and headers$ sudo apt-get install lldb-4.0 liblldb-4.0-dev# Initialize GYP$ git clone https://github.com/bnoordhuis/gyp.git tools/gyp# Configure$ ./gyp_llnode -Dlldb_dir=/usr/lib/llvm-4.0/# Build$ make -C out/ -j9# Install$ sudo make install-linux 注意：如果 sudo apt-get update 遇到这种错误： 1W: GPG error: xxx stable Release: The following signatures couldn&#x27;t be verified because the public key is not available: NO_PUBKEY 6DA62DE462C7DA6D 可以用以下命令解决： 1$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 6DA62DE462C7DA6D –recv-keys 后面跟的是前面报错提示的 PUBKEY。 2.1.4 测试 Core Dump下面用一个典型的全局变量缓存导致的内存泄漏的例子来测试 llnode 的用法。代码如下： app.js 1234567891011121314const leaks = []function LeakingClass() &#123; this.name = Math.random().toString(36) this.age = Math.floor(Math.random() * 100)&#125;setInterval(() =&gt; &#123; for (let i = 0; i &lt; 100; i++) &#123; leaks.push(new LeakingClass) &#125; console.warn(&#x27;Leaks: %d&#x27;, leaks.length)&#125;, 1000) 运行该程序： 1$ node app.js 等待几秒，打开另一个终端运行 gcore： 12$ ulimit -c unlimited$ sudo gcore `pgrep -n node` 生成 core.2763 文件。 2.1.5 分析 Core 文件使用 lldb 加载刚才生成的 Core 文件： 1234$ lldb-4.0 -c ./core.2763 (lldb) target create --core &quot;./core.2763&quot;Core file &#x27;/home/nswbmw/test/./core.2763&#x27; (x86_64) was loaded.(lldb) 输入 v8 查看使用文档，有以下几条命令： bt findjsinstances findjsobjects findrefs inspect nodeinfo print source 运行 v8 findjsobjects 查看所有对象实例及总共占内存大小： 12345678(lldb) v8 findjsobjects Instances Total Size Name ---------- ---------- ---- ... 2100 84000 LeakingClass 8834 39792 (String) ---------- ---------- 12088 181320 可以看出：LeakingClass 有 2100 个实例，占内存 84000 byte。使用 v8 findjsinstances 查看所有 LeakingClass 实例： 12345(lldb) v8 findjsinstances LeakingClass0x000022aaa118ab19:&lt;Object: LeakingClass&gt;0x000022aaa118acf9:&lt;Object: LeakingClass&gt;0x000022aaa118ade1:&lt;Object: LeakingClass&gt;... 使用 v8 i 检索实例的具体内容： 123456789101112(lldb) v8 i 0x000022aaa118ab190x000022aaa118ab19:&lt;Object: LeakingClass properties &#123; .name=0x000022aaa118ab91:&lt;String: &quot;0.4tx00cipe8&quot;&gt;, .age=&lt;Smi: 71&gt;&#125;&gt;(lldb) v8 i 0x000022aaa118acf90x000022aaa118acf9:&lt;Object: LeakingClass properties &#123; .name=0x000022aaa118ad71:&lt;String: &quot;0.48563ixsblf&quot;&gt;, .age=&lt;Smi: 70&gt;&#125;&gt;(lldb) v8 i 0x000022aaa118ade10x000022aaa118ade1:&lt;Object: LeakingClass properties &#123; .name=0x000022aaa118ae59:&lt;String: &quot;0.w1nel407zj&quot;&gt;, .age=&lt;Smi: 80&gt;&#125;&gt; 可以看到每个 LeakingClass 实例的 name 和 age 字段的值。 使用 v8 findrefs 查看引用： 1234567891011121314151617181920(lldb) v8 findrefs 0x000022aaa118ab190x22aaa1189729: (Array)[0]=0x22aaa118ab19(lldb) v8 i 0x22aaa11897290x000022aaa1189729:&lt;Array: length=2100 &#123; [0]=0x000022aaa118ab19:&lt;Object: LeakingClass&gt;, [1]=0x000022aaa118acf9:&lt;Object: LeakingClass&gt;, [2]=0x000022aaa118ade1:&lt;Object: LeakingClass&gt;, [3]=0x000022aaa118aea1:&lt;Object: LeakingClass&gt;, [4]=0x000022aaa118af61:&lt;Object: LeakingClass&gt;, [5]=0x000022aaa118b021:&lt;Object: LeakingClass&gt;, [6]=0x000022aaa118b0e1:&lt;Object: LeakingClass&gt;, [7]=0x000022aaa118b1a1:&lt;Object: LeakingClass&gt;, [8]=0x000022aaa118b221:&lt;Object: LeakingClass&gt;, [9]=0x000022aaa118b2a1:&lt;Object: LeakingClass&gt;, [10]=0x000022aaa118b321:&lt;Object: LeakingClass&gt;, [11]=0x000022aaa118b3a1:&lt;Object: LeakingClass&gt;, [12]=0x000022aaa118b421:&lt;Object: LeakingClass&gt;, [13]=0x000022aaa118b4a1:&lt;Object: LeakingClass&gt;, [14]=0x000022aaa118b521:&lt;Object: LeakingClass&gt;, [15]=0x000022aaa118b5a1:&lt;Object: LeakingClass&gt;&#125;&gt; 可以看出：通过一个 LeakingClass 实例的内存地址，我们使用 v8 findrefs 找到了引用它的数组的内存地址，然后通过这个地址去检索数组，得到这个数组长度为 2100，每一项都是一个 LeakingClass 实例，这不就是我们代码中的 leaks 数组吗？ 小提示: v8 i 是 v8 inspect 的缩写，v8 p 是 v8 print 的缩写。 2.1.6 –abort-on-uncaught-exception在 Node.js 程序启动时添加 –abort-on-uncaught-exception 参数，当程序 crash 的时候，会自动 Core Dump，方便 “死后验尸”。 添加 –abort-on-uncaught-exception 参数，启动测试程序： 12$ ulimit -c unlimited$ node --abort-on-uncaught-exception app.js 启动另外一个终端运行： 1$ kill -BUS `pgrep -n node` 第 1 个终端会显示： 123456789Leaks: 100Leaks: 200Leaks: 300Leaks: 400Leaks: 500Leaks: 600Leaks: 700Leaks: 800Bus error (core dumped) 调试步骤与上面一致： 1234567891011$ lldb-4.0 -c ./core(lldb) target create --core &quot;./core&quot;Core file &#x27;/home/nswbmw/test/./core&#x27; (x86_64) was loaded.(lldb) v8 findjsobjects Instances Total Size Name ---------- ---------- ---- ... 800 32000 LeakingClass 7519 38512 (String) ---------- ---------- 9440 126368 2.1.7 总结我们的测试代码很简单，没有引用任何第三方模块，如果项目较大且引用的模块较多，则 v8 findjsobjects 的结果将难以甄别，这时可以多次使用 gcore 进行 Core Dump，对比发现增长的对象，再进行诊断。 2.1.8 参考链接 http://www.cnblogs.com/Anker/p/6079580.html http://www.brendangregg.com/blog/2016-07-13/llnode-nodejs-memory-leak-analysis.html","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 1.3 Tick Processor","slug":"1.3.1 Tick Processor","date":"2019-04-01T06:00:00.000Z","updated":"2022-05-25T04:23:07.031Z","comments":true,"path":"2019/04/01/1.3.1 Tick Processor/","link":"","permalink":"https://marvinliu1.github.io/2019/04/01/1.3.1%20Tick%20Processor/","excerpt":"","text":"Node in Debugging V8 内置了一个性能分析工具——Tick Processor，可以记录 JavaScript&#x2F;C&#x2F;C++ 代码的堆栈信息，该功能默认是关闭的，可以通过添加命令行参数 --prof 开启。 1.3.1 Tick Processor创建测试代码： app.js 12345678910111213const crypto = require(&#x27;crypto&#x27;)function hash (password) &#123; const salt = crypto.randomBytes(128).toString(&#x27;base64&#x27;) const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, &#x27;sha512&#x27;) return hash&#125;console.time(&#x27;pbkdf2Sync&#x27;)for (let i = 0; i &lt; 100; i++) &#123; hash(&#x27;random_password&#x27;)&#125;console.timeEnd(&#x27;pbkdf2Sync&#x27;) 运行： 12$ node --prof apppbkdf2Sync: 1375.582ms 可以看出，执行 100 次 hash 函数总共用了 1375.585ms，并且当前目录下多了一个 isolate-xxx-v8.log 文件，该文件记录了 V8 的性能日志，内容如下： 12345678v8-version,6,1,534,50,0shared-library,&quot;/usr/local/bin/node&quot;,0x100001800,0x100bbb69a,0...code-creation,Function,18,111912,0x37d07c7246a8,144,&quot;hash /Users/nswbmw/Desktop/test/app.js:3:15&quot;,0x37d07c7076d0,~code-creation,LazyCompile,18,111927,0x37d07c7246a8,144,&quot;hash /Users/nswbmw/Desktop/test/app.js:3:15&quot;,0x37d07c7076d0,~code-creation,Function,18,112058,0x37d07c725690,80,&quot;exports.pbkdf2Sync crypto.js:686:30&quot;,0x37d07c70cb58,~code-creation,LazyCompile,18,112074,0x37d07c725690,80,&quot;exports.pbkdf2Sync crypto.js:686:30&quot;,0x37d07c70cb58,~... 早期我们需要借助 node-tick-processor 这样的工具解析 v8.log，但 Node.js 在 v5.2.0 之后包含了 v8.log 处理器，添加命令行参数 --prof-process 开启。 运行： 1$ node --prof-process isolate-0x103000000-v8.log 结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344Statistical profiling result from isolate-0x103000000-v8.log, (1152 ticks, 44 unaccounted, 0 excluded). [Shared libraries]: ticks total nonlib name [JavaScript]: ticks total nonlib name 1 0.1% 0.1% Function: ~Uint8Array native typedarray.js:158:31 1 0.1% 0.1% Function: ~NativeModule.cache bootstrap_node.js:604:42 1 0.1% 0.1% Function: ~Buffer.toString buffer.js:609:37 [C++]: ticks total nonlib name 1023 88.8% 88.8% T node::crypto::PBKDF2(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) 27 2.3% 2.3% t node::(anonymous namespace)::ContextifyScript::New(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) ... [Summary]: ticks total nonlib name 3 0.3% 0.3% JavaScript 1105 95.9% 95.9% C++ 3 0.3% 0.3% GC 0 0.0% Shared libraries 44 3.8% Unaccounted [C++ entry points]: ticks cpp total name 1062 98.2% 92.2% T v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) 13 1.2% 1.1% T v8::internal::Runtime_CompileLazy(int, v8::internal::Object**, v8::internal::Isolate*) ... [Bottom up (heavy) profile]: Note: percentage shows a share of a particular caller in the total amount of its parent calls. Callers occupying less than 1.0% are not shown. ticks parent name 1023 88.8% T node::crypto::PBKDF2(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) 1023 100.0% T v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) 1023 100.0% Function: ~pbkdf2 crypto.js:691:16 1023 100.0% Function: ~exports.pbkdf2Sync crypto.js:686:30 1023 100.0% Function: ~hash /Users/nswbmw/Desktop/test/app.js:3:15 1023 100.0% Function: ~&lt;anonymous&gt; /Users/nswbmw/Desktop/test/app.js:1:11 ... 打印结果包含六部分：Shared libraries、JavaScript、C++、Summary、C++ entry points 和 Bottom up (heavy) profile。[JavaScript] 部分列出了 JavaScript 代码执行所占用的 CPU ticks（CPU 时钟周期），[C++] 部分列出了 C++ 代码执行所占用的 CPU ticks，[Summary] 列出了各个部分的占比，[Bottom up] 列出了所有 CPU 占用时间从大到小的函数及堆栈信息，小于 1% 的则不予显示。 可以看出：88.8%的 CPU 时间都花在了 crypto.js 文件的 pbkdf2Sync 函数上，该函数在 app.js 第 3 行被调用，即我们的 hash 函数。 解决方法：将同步的 pbkdf2Sync 改为异步的 pbkdf2。修改代码如下： 1234567891011121314151617const crypto = require(&#x27;crypto&#x27;)function hash (password, cb) &#123; const salt = crypto.randomBytes(128).toString(&#x27;base64&#x27;) crypto.pbkdf2(password, salt, 10000, 64, &#x27;sha512&#x27;, cb)&#125;let count = 0console.time(&#x27;pbkdf2&#x27;)for (let i = 0; i &lt; 100; i++) &#123; hash(&#x27;random_password&#x27;, () =&gt; &#123; count++ if (count === 100) &#123; console.timeEnd(&#x27;pbkdf2&#x27;) &#125; &#125;)&#125; 运行结果： 12$ node --prof apppbkdf2: 656.332ms 可以看出，程序运行了 656.332ms，相比较于之前的 1375.585ms，性能提升了 1 倍。我们继续看下 v8.log 的分析结果，运行： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$ node --prof-process isolate-0x102802400-v8.logStatistical profiling result from isolate-0x103001a00-v8.log, (198 ticks, 19 unaccounted, 0 excluded). [Shared libraries]: ticks total nonlib name [JavaScript]: ticks total nonlib name 1 0.5% 0.5% StoreIC: A store IC from the snapshot 1 0.5% 0.5% Function: ~set native collection.js:149:4 1 0.5% 0.5% Function: ~pbkdf2 crypto.js:691:16 1 0.5% 0.5% Function: ~inherits util.js:962:18 1 0.5% 0.5% Builtin: ArrayIteratorPrototypeNext [C++]: ticks total nonlib name 83 41.9% 41.9% T ___kdebug_trace_string 31 15.7% 15.7% t node::(anonymous namespace)::ContextifyScript::New(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) 14 7.1% 7.1% T ___pthread_sigmask ... [Summary]: ticks total nonlib name 5 2.5% 2.5% JavaScript 174 87.9% 87.9% C++ 3 1.5% 1.5% GC 0 0.0% Shared libraries 19 9.6% Unaccounted [C++ entry points]: ticks cpp total name 41 60.3% 20.7% T v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) 17 25.0% 8.6% T v8::internal::Runtime_CompileLazy(int, v8::internal::Object**, v8::internal::Isolate*) ... [Bottom up (heavy) profile]: Note: percentage shows a share of a particular caller in the total amount of its parent calls. Callers occupying less than 1.0% are not shown. ticks parent name 83 41.9% T ___kdebug_trace_string 31 15.7% t node::(anonymous namespace)::ContextifyScript::New(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) 31 100.0% T v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) 31 100.0% Function: ~runInThisContext bootstrap_node.js:495:28 31 100.0% Function: ~NativeModule.compile bootstrap_node.js:584:44 31 100.0% Function: ~NativeModule.require bootstrap_node.js:516:34 ... 可以看出，[Bottom up] 没有很多 ticks，而且不再有 pbkdf2 这种堆栈信息。 1.3.2 Web UIV8 还提供了一个 Web 可视化工具来查看生成的 v8 日志。首先，将代码还原到使用 pbkdf2Sync 的版本，运行： 1234$ node --prof app # 生成 isolate-0x103000000-v8.log$ node --prof-process --preprocess isolate-0x103000000-v8.log &gt; v8.json # 格式化成 JSON 文件$ git clone https://github.com/v8/v8.git # 克隆 v8 仓库$ open v8/tools/profview/index.html # 打开 V8 profiling log processor 点击 “选择文件”，选择刚才生成的 v8.json 文件，点击 “Bottom up” 视图，如下所示： 有以下两点需要解释： 图中的上半部分展示了 CPU 的 timeline，X 轴代表时间的流逝，Y 轴代表当前时间点不同部分占用 CPU 的比例，可以在 timeline 图表上单击左键不放，然后拖动，选择时间区间。 图中的下半部分展示了当前时间段内 CPU 占用比从大到小降序排列的函数，展开可查看堆栈信息。不同的颜色代表了不同的部分，点击任意一个函数，timeline 底部会展示该函数的执行时间分布。 1.3.3 参考链接 https://github.com/v8/v8/wiki/V8-Profiler https://blog.ghaiklor.com/profiling-nodejs-applications-1609b77afe4e https://stackoverflow.com/questions/23934451/how-to-read-nodejs-internal-profiler-tick-processor-output","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging, 1.2 How to use v8-profiler","slug":"1.2.1 使用 v8-profiler","date":"2019-03-23T06:00:00.000Z","updated":"2022-05-25T04:22:04.311Z","comments":true,"path":"2019/03/23/1.2.1 使用 v8-profiler/","link":"","permalink":"https://marvinliu1.github.io/2019/03/23/1.2.1%20%E4%BD%BF%E7%94%A8%20v8-profiler/","excerpt":"","text":"Node in Debugging 我们知道 Node.js 是基于 V8 引擎的，V8 暴露了一些 profiler API，我们可以通过 v8-profiler 收集一些运行时数据（例如：CPU 和内存）。本节将介绍如何使用 v8-profiler 分析 CPU 的使用情况。 1.2.1 使用 v8-profiler创建测试代码： app.js 12345678910111213141516171819202122232425262728const fs = require(&#x27;fs&#x27;)const crypto = require(&#x27;crypto&#x27;)const Bluebird = require(&#x27;bluebird&#x27;)const profiler = require(&#x27;v8-profiler&#x27;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/encrypt&#x27;, controller: function encryptRouter (ctx) &#123; const password = ctx.query.password || &#x27;test&#x27; const salt = crypto.randomBytes(128).toString(&#x27;base64&#x27;) const encryptedPassword = crypto.pbkdf2Sync(password, salt, 10000, 64, &#x27;sha512&#x27;).toString(&#x27;hex&#x27;) ctx.body = encryptedPassword&#125;&#125;)app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/cpuprofile&#x27;, async controller (ctx) &#123; //Start Profiling profiler.startProfiling(&#x27;CPU profile&#x27;) await Bluebird.delay(30000) //Stop Profiling after 30s const profile = profiler.stopProfiling() profile.export() .pipe(fs.createWriteStream(`cpuprofile-$&#123;Date.now()&#125;.cpuprofile`)) .on(&#x27;finish&#x27;, () =&gt; profile.delete()) ctx.status = 204&#125;&#125;) app.listen(3000) GET /encrypt 有一个 CPU 密集型的计算函数 crypto.pbkdf2Sync，GET /cpuprofile 用来收集 30s 的 V8 log 然后将其 dump 到一个文件中。 运行该程序，打开两个终端窗口。一个终端运行： 1$ curl localhost:3000/cpuprofile 来触发 CPU profiling，然后另一个终端立即运行： 1$ ab -c 20 -n 2000 &quot;http://localhost:3000/encrypt?password=123456&quot; 来触发 CPU 密集计算。 最后生成 cpuprofile-xxx.cpuprofile 文件，该文件的内容其实就是一个大的 JSON 对象，大体如下： 12345678910111213141516171819&#123; &quot;typeId&quot;: &quot;CPU&quot;, &quot;uid&quot;: &quot;1&quot;, &quot;title&quot;: &quot;CPU profile&quot;, &quot;head&quot;: &#123; &quot;functionName&quot;: &quot;(root)&quot;, &quot;url&quot;: &quot;&quot;, &quot;lineNumber&quot;: 0, &quot;callUID&quot;: 154, &quot;bailoutReason&quot;: &quot;&quot;, &quot;id&quot;: 1, &quot;scriptId&quot;: 0, &quot;hitCount&quot;: 0, &quot;children&quot;: [ ... ] &#125;, &quot;startTime&quot;: 276245, &quot;endTime&quot;: 276306, &quot;samples&quot;: [ ... ], &quot;timestamps&quot;: [ ... ]&#125; 这个 JSON 对象记录了函数调用栈、路径、时间戳和一些其他信息，samples 节点数组与 timestamps 节点数组中的时间戳是一一对应的，并且 samples 节点数组中的每一个值其实对应了 head 节点的深度优先遍历 ID。这里我们不深究每个字段的含义，先来看看如何可视化这些数据。 1.2.2 方法 1——Chrome DevToolsChrome 自带了分析 CPU profile 日志的工具。打开 Chrome -&gt; 调出开发者工具（DevTools） -&gt; 单击右上角三个点的按钮 -&gt; More tools -&gt; JavaScript Profiler -&gt; Load，加载刚才生成的 cpuprofile 文件。左上角的下拉菜单可以选择如下三种模式： Chart：显示按时间顺序排列的火焰图。 Heavy (Bottom Up)：按照函数对性能的影响排列，同时可以检查函数的调用路径。 Tree (Top Down)：显示调用结构的总体状况，从调用堆栈的顶端开始。 这里我们选择 Tree (Top Down) 模式，按 Total Time 降序排列。可以看到有如下三列： Self Time：函数调用所耗费的时间，仅包含函数本身的声明，不包含任何子函数的执行时间。 Total Time：函数调用所耗费的总时间，包含函数本身的声明及所有子函数执行时间。即：父函数的 Total Time &#x3D; 父函数的 Self Time + 所有子函数的 Total Time。 Function：函数名及路径，可展开查看子函数。 我们不断地展开，并定位到了 encryptRouter，如下图所示： 可以看出：我们定位到了 encryptRouter 这个路由，并且这个路由中 exports.pbkdf2Sync 占据了绝大部分 CPU 时间。 1.2.3 方法 2——火焰图我们也可以用火焰图来展示 cpuprofile 数据。首先全局安装 flamegraph 模块： 1$ npm i flamegraph -g 运行以下命令将 cpuprofile 文件生成 svg 文件： 1$ flamegraph -t cpuprofile -f cpuprofile-xxx.cpuprofile -o cpuprofile.svg 用浏览器打开 cpuprofile.svg，如下所示： 可以看出：我们定位到了 app.js 的第 8 行，即 encryptRouter 这个路由，并且这个路由中 exports.pbkdf2Sync 占据了绝大部分 CPU 时间。 1.2.4 方法 3——v8-analyticsv8-analytics 是社区开源的一个解析 v8-profiler 和 heapdump 等模块生成的 CPU 和 heap-memory 日志的工具。它提供以下功能： 将 V8 引擎逆优化或者优化失败的函数标红展示，并展示优化失败的原因。 在函数执行时长超过预期时标红展示。 展示当前项目中可疑的内存泄漏点。 我们以上述第 2 个功能为例，使用 v8-analytics 分析 CPU 的使用情况。 首先，全局安装 v8-analytics： 1$ npm i v8-analytics -g 使用以下命令查看执行时间大于 200ms 的函数： 1$ va timeout cpuprofile-xxx.cpuprofile 200 --only 结果截图如下： 可以看出：我们依然能够定位到 encryptRouter 和 exports.pbkdf2Sync。 1.2.5 参考链接 https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution http://www.ebaytechblog.com/2016/06/15/igniting-node-js-flames/ https://cnodejs.org/topic/58b562f97872ea0864fee1a7 https://github.com/hyj1991/v8-analytics/blob/master/README_ZH.md","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging 1.1 Perf + FameGraph","slug":"1.1.1 perf","date":"2019-03-21T06:00:00.000Z","updated":"2022-05-25T04:21:57.857Z","comments":true,"path":"2019/03/21/1.1.1 perf/","link":"","permalink":"https://marvinliu1.github.io/2019/03/21/1.1.1%20perf/","excerpt":"","text":"Node in Debugging 当程序出现性能瓶颈时，我们通常通过表象（比如请求某个接口时 CPU 使用率飙涨）然后结合代码去推测可能出问题的地方，却不知道问题到底是什么引起的。如果有个一可视化的工具直观地展现程序的性能瓶颈就好了，幸好 Brendan D. Gregg 发明了火焰图。 火焰图（Flame Graph）看起来就像一团跳动的火焰，因此得名。火焰图可以将 CPU 的使用情况可视化，使我们直观地了解到程序的性能瓶颈，通常要结合操作系统的性能分析工具（profiling tracer）使用，常见的操作系统的性能分析工具如下： Linux：perf, eBPF, SystemTap, and ktap。 Solaris, illumos, FreeBSD：DTrace。 Mac OS X：DTrace and Instruments。 Windows：Xperf.exe。 1.1.1 perfperf_events（简称 perf）是 Linux Kernal 自带的系统性能分析工具，能够进行函数级与指令级的热点查找。它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析，常用于查找性能瓶颈及定位热点代码。 测试机器： 12$ uname -aLinux nswbmw-VirtualBox 4.10.0-28-generic #32~16.04.2-Ubuntu SMP Thu Jul 20 10:19:48 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux 注意：非 Linux 用户需要用虚拟机安装 Ubuntu 16.04 和 &#110;&#111;&#x64;&#x65;&#x40;&#56;&#46;&#57;&#x2e;&#x34; 后进行后面的操作。 安装 perf： 123$ sudo apt install linux-tools-common$ perf # 根据提示安装对应的内核版本的 tools, 如下$ sudo apt install linux-tools-4.10.0-28-generic linux-cloud-tools-4.10.0-28-generic 创建测试目录 ~&#x2F;test 和测试代码： app.js 12345678910111213141516171819202122232425262728293031323334const crypto = require(&#x27;crypto&#x27;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()const users = &#123;&#125;app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/newUser&#x27;, controller (ctx) &#123; const username = ctx.query.username || &#x27;test&#x27; const password = ctx.query.password || &#x27;test&#x27; const salt = crypto.randomBytes(128).toString(&#x27;base64&#x27;) const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, &#x27;sha512&#x27;).toString(&#x27;hex&#x27;) users[username] = &#123; salt, hash &#125; ctx.status = 204&#125;&#125;)app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/auth&#x27;, controller (ctx) &#123; const username = ctx.query.username || &#x27;test&#x27; const password = ctx.query.password || &#x27;test&#x27; if (!users[username]) &#123; ctx.throw(400) &#125; const hash = crypto.pbkdf2Sync(password, users[username].salt, 10000, 64, &#x27;sha512&#x27;).toString(&#x27;hex&#x27;) if (users[username].hash === hash) &#123; ctx.status = 204 &#125; else &#123; ctx.throw(403) &#125;&#125;&#125;) app.listen(3000) 添加 –perf_basic_prof（或者 –perf-basic-prof）参数运行此程序，会对应生成一个 &#x2F;tmp&#x2F;perf-.map 的文件。命令如下： 12345678910111213$ node --perf_basic_prof app.js &amp;[1] 3590$ tail /tmp/perf-3590.map51b87a7b93e 18 Function:~emitListeningNT net.js:137551b87a7b93e 18 LazyCompile:~emitListeningNT net.js:137551b87a7bad6 39 Function:~emitAfterScript async_hooks.js:44351b87a7bad6 39 LazyCompile:~emitAfterScript async_hooks.js:44351b87a7bcbe 77 Function:~tickDone internal/process/next_tick.js:8851b87a7bcbe 77 LazyCompile:~tickDone internal/process/next_tick.js:8851b87a7bf36 12 Function:~clear internal/process/next_tick.js:4251b87a7bf36 12 LazyCompile:~clear internal/process/next_tick.js:4251b87a7c126 b8 Function:~emitPendingUnhandledRejections internal/process/promises.js:8651b87a7c126 b8 LazyCompile:~emitPendingUnhandledRejections internal/process/promises.js:86 map 文件内容三列依次为：16进制的符号地址（symbol addresses）、大小（sizes）和符号名（symbol names）。perf 会尝试查找 &#x2F;tmp&#x2F;perf-.map 文件，用来做符号转换，即把 16 进制的符号地址转换成人能读懂的符号名。 注意：使用 –perf_basic_prof_only_functions 参数也可以，但经尝试后发现生成的火焰图信息不全（不全的地方显示 [perf-.map]），所以这里使用 –perf_basic_prof。但是，使用 –perf_basic_prof 有个缺点，就是会导致 map 文件一直增大，这是由于符号（symbols）地址不断变换导致的，用 –perf_basic_prof_only_functions 可以缓解这个问题。关于如何取舍，还请读者自行尝试。 接下来 clone 用来生成火焰图的工具： 1$ git clone http://github.com/brendangregg/FlameGraph ~/FlameGraph 我们先用 ab 压测： 12$ curl &quot;http://localhost:3000/newUser?username=admin&amp;password=123456&quot;$ ab -k -c 10 -n 2000 &quot;http://localhost:3000/auth?username=admin&amp;password=123456&quot; 新开另一个终端，在 ab 开始压测后立即运行： 1234$ sudo perf record -F 99 -p 3590 -g -- sleep 30$ sudo chown root /tmp/perf-3590.map$ sudo perf script &gt; perf.stacks$ ~/FlameGraph/stackcollapse-perf.pl --kernel &lt; ~/perf.stacks | ~/FlameGraph/flamegraph.pl --color=js --hash&gt; ~/flamegraph.svg 注意：第 1 次生成的 svg 可能不太准确，最好重复几次以上步骤，使用第 2 次及以后生成的 flamegraph.svg。 有几点需要解释一下： perf record -F 指定了采样频率 99Hz（即每秒 99 次，如果 99 次都返回同一个函数名，那就说明 CPU 在这一秒钟都在执行同一个函数，可能存在性能问题）。 -p 指定进程的 pid。 -g 启用 call-graph 记录。 – sleep 30 指定记录 30s。 sudo chown root &#x2F;tmp&#x2F;perf-3009.map，将 map 文件更改为 root 权限，否则会报如下错误： File &#x2F;tmp&#x2F;perf-PID.map not owned by current user or root, ignoring it (use -f to override). Failed to open &#x2F;tmp&#x2F;perf-PID.map, continuing without symbols perf record 会将记录的信息保存到当前执行目录的 perf.data 文件中，然后使用 perf script 读取 perf.data 的 trace 信息写入 perf.stacks。 –color&#x3D;js 指定生成针对 JavaScript 配色的 svg，即： green：JavaScript。 blue：Builtin。 yellow：C++。 red：System（native user-level, and kernel）。 ab 压测用了 30s 左右，用浏览器打开 flamegraph.svg，截取关键的部分如下图所示： 1.1.2 理解火焰图火焰图含义： 每一个小块代表了一个函数在栈中的位置（即一个栈帧）。 Y 轴代表栈的深度（栈上的帧数），顶端的小块显示了占据 CPU 的函数。每个小块的下面是它的祖先（即父函数）。 X 轴代表总的样例群体。它不像绝大多数图表那样从左到右表示时间的流逝，其左右顺序没有特殊含义，仅仅按照字母表的顺序排列。 小块的宽度代表 CPU 的使用时间，或者说相对于父函数而言使用 CPU 的比例（基于所有样例），越宽则代表占用 CPU 的时间越长，或者使用 CPU 很频繁。 如果采取多线程并发运行取样，则取样数量会超过运行时间。 从上图可以看出：最上面的绿色小块（即 JavaScript 代码）指向 test&#x2F;app.js 第 18 行，即 GET /auth 这个路由。再往上看，黄色的小块（即 C++ 代码） node::crypto::PBKDF2 占用了大量的 CPU 时间。 解决方法：将同步改为异步，即将 crypto.pbkdf2Sync 改为 crypto.pbkdf2。修改如下： 12345678910111213141516171819202122app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/auth&#x27;, async controller (ctx) &#123; const username = ctx.query.username || &#x27;test&#x27; const password = ctx.query.password || &#x27;test&#x27; if (!users[username]) &#123; ctx.throw(400) &#125; const hash = await new Promise((resolve, reject) =&gt; &#123; crypto.pbkdf2(password, users[username].salt, 10000, 64, &#x27;sha512&#x27;, (err, derivedKey) =&gt; &#123; if (err) &#123; return reject(err) &#125; resolve(derivedKey.toString(&#x27;hex&#x27;)) &#125;) &#125;) if (users[username].hash === hash) &#123; ctx.status = 204 &#125; else &#123; ctx.throw(403) &#125;&#125;&#125;) 用 ab 重新压测，结果用了 16s。重新生成的火焰图如下： 可以看出：只有在左侧极窄的绿色小块可以看到 JavaScript 代码，红色的部分我们不关心也无法优化。那么，为什么异步比同步的 QPS 要高呢？原因是 Node.js 底层的 libuv 用了多个线程进行计算，这里就不再深入介绍了。 svg 火焰图的其他小技巧如下： 单击任意一个小块即可展开，即被单击的小块宽度变宽，它的子函数也按比例变宽，方便查看。 可单击 svg 右上角的 search 按钮进行搜索，被搜索的关键词会高亮显示，在有目的地查找某个函数时比较有用。 1.1.3 红蓝差分火焰图虽然我们有了火焰图，但要处理性能回退问题，还需要在修改代码前后的火焰图之间，不断切换和对比，来找出问题所在，很不方便。于是 Brendan D. Gregg 又发明了红蓝差分火焰图（Red&#x2F;Blue Differential Flame Graphs）。 如下所示：红色表示增长，蓝色表示衰减。 红蓝差分火焰图的工作原理如下： 抓取修改前的栈 profile1 文件。 抓取修改后的栈 profile2 文件。 使用 profile2 来生成火焰图，这样栈帧的宽度就是以 profile2 文件为基准的。 使用 profile2 - profile1 的差异来对火焰图重新上色。上色的原则是：如果栈帧在 profile2 中出现出现的次数更多，则标为红色，否则标为蓝色。色彩是根据修改前后的差异来填充的。 这样，通过红蓝差分火焰图，我们就可以清楚地看到系统性能的差异之处。 生成红蓝差分火焰图的流程如下： 修改代码前运行： 123$ sudo perf record -F 99 -p &lt;PID&gt; -g -- sleep 30$ sudo chown root /tmp/perf-&lt;PID&gt;.map$ sudo perf script &gt; perf_before.stacks 修改代码后运行： 123$ sudo perf record -F 99 -p &lt;PID&gt; -g -- sleep 30$ sudo chown root /tmp/perf-&lt;PID&gt;.map$ sudo perf script &gt; perf_after.stacks 将 profile 文件进行折叠（fold），然后生成差分火焰图： 123$ ~/FlameGraph/stackcollapse-perf.pl ~/perf_before.stacks &gt; perf_before.folded$ ~/FlameGraph/stackcollapse-perf.pl ~/perf_after.stacks &gt; perf_after.folded$ ./FlameGraph/difffolded.pl perf_before.folded perf_after.folded | ./FlameGraph/flamegraph.pl &gt; flamegraph_diff.svg 如上缺点是：如果一个代码执行路径完全消失了，那么在火焰图中就找不到地方来标注蓝色，我们只能看到当前的 CPU 使用情况，却不知道为什么会变成这样。 一种解决办法是：生成一个相反的差分火焰图，即基于 profile1 生成 profile1 - profile2 的差分火焰图。对应命令如下： 1$ ./FlameGraph/difffolded.pl perf_after.folded perf_before.folded | ./FlameGraph/flamegraph.pl --negate &gt; flamegraph_diff2.svg 其中，–negate 用于颠倒红&#x2F;蓝配色。最终我们得到： flamegraph_diff.svg：宽度是以修改前的 profile 文件为基准，颜色表明将要发生的情况。 flamegraph_diff2.svg：宽度是以修改后的 profile 文件为基准，颜色表明已经发生的情况。 总之，红蓝差分火焰图可能只在代码变化不大的情况下使用时效果明显，在代码变化较大的情况下使用时效果可能就不明显了。 1.1.4 参考链接 https://yunong.io/2015/11/23/generating-node-js-flame-graphs/ http://www.brendangregg.com/perf.html http://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html https://linux.cn/article-4670-1.html http://www.brendangregg.com/blog/2014-11-09/differential-flame-graphs.html http://www.ruanyifeng.com/blog/2017/09/flame-graph.html","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Hexo: Update server automatically","slug":"Hexo-update-server-automatically","date":"2018-05-20T21:45:26.000Z","updated":"2022-05-21T07:36:18.586Z","comments":true,"path":"2018/05/20/Hexo-update-server-automatically/","link":"","permalink":"https://marvinliu1.github.io/2018/05/20/Hexo-update-server-automatically/","excerpt":"","text":"How to update the Hexo server automatically:Sometimes you may want to update your Hexo server after editing a post or creating a new one, here is how to use Browsersync to achieve that. Step 1: Install the Browsersync1&gt;npm install -g browser-sync Step 2: Install Hexo plugin1&gt;npm install hexo-browsersync --save Step 3: Start your Hexo service1hexo s","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-02T07:26:30.000Z","updated":"2022-05-21T08:41:13.026Z","comments":true,"path":"2018/01/02/hello-world/","link":"","permalink":"https://marvinliu1.github.io/2018/01/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/categories/Hexo/"},{"name":"Nuxt","slug":"Nuxt","permalink":"https://marvinliu1.github.io/categories/Nuxt/"},{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"},{"name":"Linux","slug":"Hexo/Linux","permalink":"https://marvinliu1.github.io/categories/Hexo/Linux/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/tags/Hexo/"},{"name":"NeXt","slug":"NeXt","permalink":"https://marvinliu1.github.io/tags/NeXt/"},{"name":"Vue","slug":"Vue","permalink":"https://marvinliu1.github.io/tags/Vue/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://marvinliu1.github.io/tags/MarkDown/"},{"name":"Next","slug":"Next","permalink":"https://marvinliu1.github.io/tags/Next/"},{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"},{"name":"Nohup","slug":"Nohup","permalink":"https://marvinliu1.github.io/tags/Nohup/"},{"name":"Linux","slug":"Linux","permalink":"https://marvinliu1.github.io/tags/Linux/"},{"name":"Nuxt","slug":"Nuxt","permalink":"https://marvinliu1.github.io/tags/Nuxt/"},{"name":"Javascript","slug":"Javascript","permalink":"https://marvinliu1.github.io/tags/Javascript/"}]}