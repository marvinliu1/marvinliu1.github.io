{"meta":{"title":"Marvin's Blog","subtitle":"","description":"Take in the good!","author":"Marvin Liu","url":"https://marvinliu1.github.io","root":"/"},"pages":[{"title":"","date":"2020-10-21T08:57:00.000Z","updated":"2022-05-21T10:04:11.949Z","comments":true,"path":"about/index.html","permalink":"https://marvinliu1.github.io/about/index.html","excerpt":"","text":"About me . . . A passionate coder Fantastic troubleshooter And enthusiastic software developer $(\"#code\").typewriter();"},{"title":"categories","date":"2022-05-21T07:31:25.000Z","updated":"2022-05-21T07:31:40.888Z","comments":true,"path":"categories/index.html","permalink":"https://marvinliu1.github.io/categories/index.html","excerpt":"","text":""},{"title":"Favorite Links","date":"2022-05-24T22:20:17.136Z","updated":"2022-05-24T22:20:17.136Z","comments":true,"path":"links/index.html","permalink":"https://marvinliu1.github.io/links/index.html","excerpt":"","text":"NodeJS Usefull Links Nuxt authentication A very good auth implementation by Chimezie Enyinnaya Official Tutorials about NodeJS & Vue & Nuxt Vue Tutorial Vue's tutorial from vuejs.org MDN - Getting started with Vue MDN's fine introduction about vue NuxtJS - Tutorials Discover tutorials made by the Nuxt community."},{"title":"tags","date":"2022-05-21T07:32:07.000Z","updated":"2022-05-21T07:32:16.953Z","comments":true,"path":"tags/index.html","permalink":"https://marvinliu1.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo NexT8 主题添加友链页面","slug":"Adding links into Hexo NexT8 ","date":"2022-05-22T18:11:00.000Z","updated":"2022-05-24T23:02:16.595Z","comments":true,"path":"2022/05/22/Adding links into Hexo NexT8 /","link":"","permalink":"https://marvinliu1.github.io/2022/05/22/Adding%20links%20into%20Hexo%20NexT8%20/","excerpt":"","text":"本文转载自Cu Blog NexT 主题自带的并没有友链页面，本着 “可以不用但必须有” 的思想，我通过搜索引擎找到了可行的解决方案，在此记录，希望能帮到其他人。 NexT 版本：8.10.1。 先看一下最终效果吧： NexT 配置文件修改打开_config.next.yml 文件，搜索_data，能够找到这样一条被注释的语句：style: source/_data/styles.styl，取消注释即可。 然后在 source 文件夹下新建_data 目录，并创建文件 styles.styl，在里面写入以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#links &#123; margin-top: 5rem;&#125;.links-content &#123; margin-top:1rem;&#125;.link-navigation::after &#123; content: &quot; &quot;; display: block; clear: both;&#125;.card &#123; width: 300px; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex;&#125;.card:nth-child(odd) &#123; float: left;&#125;.card:nth-child(even) &#123; float: right;&#125;.card:hover &#123; transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);&#125;.card a &#123; border:none;&#125;.card .ava &#123; width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px;&#125;.card .card-header &#123; font-style: italic; overflow: hidden; width: 236px;&#125;.card .card-header a &#123; font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none;&#125;.card .card-header a:hover &#123; color: #d480aa; text-decoration: none;&#125;.card .card-header .info &#123; font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;&#125; 然后修改主页面板： 1友链: /links || fas fa-link 创建友链页面使用 hexo new page link 可以新建一个 link 页面，我们将其作为友链页面。创建完成后，写入以下内容（自己使用时请按需修改）： 123456789101112131415161718192021222324252627282930313233343536373839404142---title: 友链type: links---&lt;div class=&quot;links-content&quot;&gt;&lt;div class=&quot;no-icon note warning&quot;&gt;&lt;div class=&quot;link-info&quot;&gt;欢迎与我交换友链！&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;link-navigation&quot;&gt;&#123;% for link in site.data.links %&#125;&lt;div class=&quot;card&quot;&gt;&lt;img class=&quot;ava nomediumzoom&quot; src=&quot;&#123;&#123; link.avatar &#125;&#125;&quot;/&gt;&lt;div class=&quot;card-header&quot;&gt;&lt;div&gt;&lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt; &#123;&#123; link.name &#125;&#125;&lt;/a&gt; &lt;/div&gt;&lt;div class=&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#123;% endfor %&#125;&lt;/div&gt;------&#123;% note success %&#125;**友链申请条件：**- 网站内容符合中国大陆法律- 已开启HTTPS，且至少有3篇博客，最新一篇为三个月之内发表- 网站内容以原创为主，技术性博客优先，娱乐性博客除非特别感兴趣，否则不会考虑**友链格式：**```yaml- name: Cu Blog site: https://www.litcu.cn info: 安全新人小醋的快乐收集处 avatar: https://img.litcu.cn/avatar/avatar1.jpg```&#123;% endnote %&#125; 核心是 HTML 代码中的那个 for 循环，site.data 就是 source/_data 目录，后面的 links 就是我们之后要创建的 links.yml 友链文件。如果后续没有正常显示友链，可以看看这里是否出现了问题。 添加友链在 source/_data/ 目录下新建 link.yml 文件，写入以下内容： 1234- name: Cu Blog site: https://www.litcu.cn info: 安全新人小醋的快乐收集处 avatar: https://img.litcu.cn/avatar/avatar1.jpg 然后 hexo cl &amp;&amp; hexo g &amp;&amp; hexo s 就可以看到效果啦！","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/tags/Hexo/"}]},{"title":"How To Implement Authentication in a Nuxt.js App","slug":"How-To-Implement-Auth-in-Nuxt","date":"2020-09-25T06:12:31.000Z","updated":"2022-05-24T22:31:18.910Z","comments":true,"path":"2020/09/25/How-To-Implement-Auth-in-Nuxt/","link":"","permalink":"https://marvinliu1.github.io/2020/09/25/How-To-Implement-Auth-in-Nuxt/","excerpt":"","text":"Original published and copy-righted by Chimezie EnyinnayaView more on digitalocean.com IntroductionIn this tutorial, you’ll implement authentication in a Nuxt.js app using the Auth module. For the purpose of this tutorial, you’ll be using JWT for authentication. Below is a quick demo of what you’ll be building in this tutorial: You can find the source code for this application at GitHub. Warning: Several of the packages in this tutorial now contain dependencies with known vulnerabilities. In a production setting, you would resolve these issues by upgrading these packages, finding alternatives, or creating forked versions with patched fixes. However, within the limited context of a tutorial, it provides educational value as-is. PrerequisitesTo complete this tutorial, you will need: Node.js installed locally, which you can do by following How to Install Node.js and Create a Local Development Environment. A valid Git installation is optionally required for cloning the API, consult Getting Started with Git. Some familiarity with Vue.js and Nuxt.js may be beneficial. You can refer to this post if you’re getting started with Nuxt.js. This tutorial was verified with Node v13.13.0, npm v6.14.4, vue v2.6.11, and nuxt v2.12.2. Step 1 — Spinning up a Sample APIYou are free to use whatever framework that works best for you. However, for quick development, this tutorial will clone an API built with AdonisJs. The API utilizes: JWT (JSON Web Tokens) for authentication SQLite CORS enabled The API has three endpoints: /register: endpoint for user registration /login: endpoint for authenticating users /me: endpoint for getting details for the currently authenticated user and it is protected by an auth middleware, which means a user must be authenticated to access the endpoint First, run the following command in your terminal window: 1git clone https://github.com/do-community/jwt-auth-api.git Copy Then, navigate to the project directory: 1cd jwt-auth-api Copy And install the API dependencies: 1npm install Copy Note: When running install, you may encounter issues with sqlite3 version 4.0.1 depending on the version of Node you are running. Refer to the changelog to determine compatibility with your environment. At the time of original publication, the latest version of Node was 10. One option is to downgrade your version of Node to 10.20.1 (with the understanding that it is nearing end-of-life support). Then, run npm install. A second option is to remove the package-lock.json file which will cause the system to look for 4.2.0 which is supported up to Node 13. You may need to also downgrade your version of Node to 13.13.0. Then, run npm install. A third option would be to modify package.json to a version of sqlite3 supported by your current version of Node, remove package-lock.json, and run npm install. However, at the time of testing, 5.0.0 is not yet released to handle Node 14+ support. Other symptoms of incompatibility include the following errors: TypeError: Cannot read property &#39;data&#39; of undefined and Error: Cannot find module &#39;[...]/node_modules/sqlite3/lib/binding/[...]/node_sqlite3.node&#39;. Next, rename .env.example to .env: 1mv .env.example .env Copy And generate an APP_KEY: 1npx @adonisjs/cli@4.0.12 key:generate Copy You should see: 1Outputgenerated: unique APP_KEY Copy Once that’s coomplete, let’s run the migrations: 1npx @adonisjs/cli@4.0.12 migration:run Copy Now, you can start the API: 12# ensure that you are in the `jwt-auth-api` project directorynpm start Copy You can access the API on http://127.0.0.1:3333/api. Leave this running in a terminal window for the rest of the duration of the tutorial. Step 2 — Creating a Nuxt.js AppNow, you can create a Nuxt.js app. Open a new terminal window and use vue-cli to initialize a new Vue project with the Nuxt starter template: 1npx vue-cli@2.9.6 init nuxt/starter nuxt-auth Copy Note: At the time of testing, vue-cli is deprecated. @vue/cli is the current command line tool for Vue projects. And @vue/cli-init is the recommended approach for legacy vue-cli projects. However, create-nuxt-app is the recommended approach for modern Nuxt projects. Next, you need to navigate to the project directory: 1cd nuxt-auth Copy And install the dependencies: 1npm install Then, you can launch the app: 1npm run dev Copy The app should be running on http://localhost:3000. You can view the application in a web browser to see the default Vue application created by vue-cli. Step 3 — Installing Necessary Nuxt.js ModulesNow, let’s install the Nuxt.js modules that you’ll be needing for your app. You’ll be using the Nuxt Auth module and the Nuxt Axios module, since the auth module makes use of Axios internally: 12# ensure that you are in the `nuxt-auth` project directorynpm install @nuxtjs/auth@4.5.1 @nuxtjs/axios@5.3.1 --save Copy Once that’s completed, open nuxt.config.js: 1nano nuxt.config.js Copy Add the code below to nuxt.config.js: nuxt.config.js 12345678module.exports = &#123; // ... modules: [ &#x27;@nuxtjs/axios&#x27;, &#x27;@nuxtjs/auth&#x27; ],&#125; Copy Note: At this point, newer versions of Nuxt may encounter the error: Enable vuex store by creating &#39;store/index.js&#39;. This error can be resolved by adding an empty index.js file to the store directory. Next, you need to set up the modules. Paste the code below into nuxt.config.js: nuxt.config.js 12345678910111213141516171819module.exports = &#123; // ... axios: &#123; baseURL: &#x27;http://127.0.0.1:3333/api&#x27; &#125;, auth: &#123; strategies: &#123; local: &#123; endpoints: &#123; login: &#123; url: &#x27;login&#x27;, method: &#x27;post&#x27;, propertyName: &#x27;data.token&#x27; &#125;, user: &#123; url: &#x27;me&#x27;, method: &#x27;get&#x27;, propertyName: &#x27;data&#x27; &#125;, logout: false &#125; &#125; &#125; &#125;&#125; Copy Here, you set the base URL that Axios will use when making requests. In our case, we are referencing the sample API we set up earlier. Then, you define the authentication endpoints for the local strategy corresponding to those on your API: On successful authentication, the token will be available in the response as a token object inside a data object. Similarly, the response from the /me endpoint will be inside a data object. Lastly, you set logout to false since your API doesn’t have an endpoint for logout. You’ll just remove the token from localStorage when a user logs out. Step 4 — Creating a Navbar ComponentTo style your app, you can make use of Bulma. Open nuxt.config.js and paste the code below within the link object that is inside the head object: nuxt.config.js 1234567891011121314module.exports = &#123; // ... head: &#123; // ... link [ // ... &#123; rel: &#x27;stylesheet&#x27;, href: &#x27;https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css&#x27; &#125; ] &#125;, // ...&#125; Copy Now, let’s create the Navbar component: 1nano components/Navbar.vue Copy And add the following code: components&#x2F;Navbar.vue 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;nav class=&quot;navbar is-light&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-brand&quot;&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/&quot;&gt;Nuxt Auth&lt;/nuxt-link&gt; &lt;button class=&quot;button navbar-burger&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;navbar-menu&quot;&gt; &lt;div class=&quot;navbar-end&quot;&gt; &lt;div class=&quot;navbar-item has-dropdown is-hoverable&quot;&gt; &lt;a class=&quot;navbar-link&quot;&gt; My Account &lt;/a&gt; &lt;div class=&quot;navbar-dropdown&quot;&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/profile&quot;&gt;My Profile&lt;/nuxt-link&gt; &lt;hr class=&quot;navbar-divider&quot;/&gt; &lt;a class=&quot;navbar-item&quot;&gt;Logout&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;template&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/register&quot;&gt;Register&lt;/nuxt-link&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/login&quot;&gt;Log In&lt;/nuxt-link&gt; &lt;/template&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;&lt;/template&gt; Copy The Navbar component contains links to login, register, profile, and logout. Next, let’s update the default layout to make use of the Navbar component. Open default.vue: 1nano layouts/default.vue Copy And replace the content with the following: layouts&#x2F;default.vue 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;Navbar/&gt; &lt;nuxt/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Navbar from &#x27;~/components/Navbar&#x27;export default &#123; components: &#123; Navbar &#125;&#125;&lt;/script&gt; Copy Also, let’s update the homepage. Open index.vue: 1nano pages/index.vue Copy And replace the content with the following: pages&#x2F;index.vue 1234567&lt;template&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;Nuxt Auth&lt;/h1&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt; Copy At this point, you should have an application that displays a title of &quot;Nuxt Auth&quot; with a header bar with navigation links: Step 5 — Handling User RegistrationInside the pages directory, create a new register.vue file: 1nano pages/register.vue Copy And add the following code: pages&#x2F;register.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;template&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column is-4 is-offset-4&quot;&gt; &lt;h2 class=&quot;title has-text-centered&quot;&gt;Register!&lt;/h2&gt; &lt;Notification :message=&quot;error&quot; v-if=&quot;error&quot;/&gt; &lt;form method=&quot;post&quot; @submit.prevent=&quot;register&quot;&gt; &lt;div class=&quot;field&quot;&gt; &lt;label class=&quot;label&quot;&gt;Username&lt;/label&gt; &lt;div class=&quot;control&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;input&quot; name=&quot;username&quot; v-model=&quot;username&quot; required /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;label class=&quot;label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;control&quot;&gt; &lt;input type=&quot;email&quot; class=&quot;input&quot; name=&quot;email&quot; v-model=&quot;email&quot; required /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;label class=&quot;label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;control&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;input&quot; name=&quot;password&quot; v-model=&quot;password&quot; required /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;control&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;button is-dark is-fullwidth&quot;&gt;Register&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;div class=&quot;has-text-centered&quot; style=&quot;margin-top: 20px&quot;&gt; Already got an account? &lt;nuxt-link to=&quot;/login&quot;&gt;Login&lt;/nuxt-link&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;import Notification from &#x27;~/components/Notification&#x27;export default &#123; components: &#123; Notification, &#125;, data() &#123; return &#123; username: &#x27;&#x27;, email: &#x27;&#x27;, password: &#x27;&#x27;, error: null &#125; &#125;, methods: &#123; async register() &#123; try &#123; await this.$axios.post(&#x27;register&#x27;, &#123; username: this.username, email: this.email, password: this.password &#125;) await this.$auth.loginWith(&#x27;local&#x27;, &#123; data: &#123; email: this.email, password: this.password &#125;, &#125;) this.$router.push(&#x27;/&#x27;) &#125; catch (e) &#123; this.error = e.response.data.message &#125; &#125; &#125;&#125;&lt;/script&gt; Copy This contains a form with three fields: username, email, and password. Each field is bound to corresponding data on the component. When the form is submitted, a register method will be called. Using the Axios module, you make a post request to the /register endpoint, passing along the user data. If the registration was successful, you make use of the Auth module’s loginWith(), using the local strategy and passing the user data to log the user in. Then, you redirect the user to the homepage. If there is an error during the registration, you set the error data as the error message gotten from the API response. If there is an error, the error message is displayed by a Notification component. Create a new Notification.vue file inside components: 1nano components/Notifaction.vue Copy And paste the code below in it: components&#x2F;Notification.vue 123456789101112&lt;template&gt; &lt;div class=&quot;notification is-danger&quot;&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Notification&#x27;, props: [&#x27;message&#x27;]&#125;&lt;/script&gt; Copy The Notification component accepts a message props, which is the error message. Now, you can test out user registration: Step 6 — Handling LoggedUsers Logged In and Logged OutUpon successful registration, users should be logged in but there is currently no way for the app to know whether users are logged in or not. So let’s fix that by updating the Navbar component and adding some computed properties. Before you do just that, let’s first activate the Vuex store by creating an index.js file inside the store directory. The Auth module stores user authentication status as well as user details inside Vuex state in an auth object. So you can check if a user is logged in or not with this.$store.state.auth.loggedIn, which will either return true or false. Similarly, you can get a user’s details with this.$store.state.auth.user, which will be null if no user is logged in. Note: You can also access the user authentication status as well as the user details directly with the Auth module using this.$auth.loggedIn and this.$auth.user respectively. Since you might want to use the computed properties in multiple places in your app, let’s create store getters. Open index.js: 1nano store/index.js Copy And paste the code below in it: store&#x2F;index.js 123456789export const getters = &#123; isAuthenticated(state) &#123; return state.auth.loggedIn &#125;, loggedInUser(state) &#123; return state.auth.user &#125;&#125; Copy Here, you create two getters. The first one (isAuthenticated) will return the authentication status of a user and the second (loggedInUser) will return the details or the logged in user. Next, let’s update the Navbar component to make use of the getters. Replace the content of components/Navbar.vue with the following: components&#x2F;Navbar.vue 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;nav class=&quot;navbar is-light&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-brand&quot;&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/&quot;&gt;Nuxt Auth&lt;/nuxt-link&gt; &lt;button class=&quot;button navbar-burger&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;navbar-menu&quot;&gt; &lt;div class=&quot;navbar-end&quot;&gt; &lt;div class=&quot;navbar-item has-dropdown is-hoverable&quot; v-if=&quot;isAuthenticated&quot;&gt; &lt;a class=&quot;navbar-link&quot;&gt; &#123;&#123; loggedInUser.username &#125;&#125; &lt;/a&gt; &lt;div class=&quot;navbar-dropdown&quot;&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/profile&quot;&gt;My Profile&lt;/nuxt-link&gt; &lt;hr class=&quot;navbar-divider&quot;/&gt; &lt;a class=&quot;navbar-item&quot;&gt;Logout&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;template v-else&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/register&quot;&gt;Register&lt;/nuxt-link&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/login&quot;&gt;Log In&lt;/nuxt-link&gt; &lt;/template&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123; computed: &#123; ...mapGetters([&#x27;isAuthenticated&#x27;, &#x27;loggedInUser&#x27;]) &#125;&#125;&lt;/script&gt; Copy You create the computed properties by using the spread operator (...) to extract the getters from mapGetters. Then using isAuthenticated, you display the user menu or links to login or register depending on whether the user is logged in or not. Also, you use loggedInUser to display the authenticated user username. Now, if you give your app a refresh, you should see something similar to below: Step 7 — Handling User Log InNow, let’s allow returning users the ability to log in. Create a new login.vue file inside the pages directory: 1nano pages/login.vue And paste the code below in it: pages&#x2F;login.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;template&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class=&quot;column is-4 is-offset-4&quot;&gt; &lt;h2 class=&quot;title has-text-centered&quot;&gt;Welcome back!&lt;/h2&gt; &lt;Notification :message=&quot;error&quot; v-if=&quot;error&quot;/&gt; &lt;form method=&quot;post&quot; @submit.prevent=&quot;login&quot;&gt; &lt;div class=&quot;field&quot;&gt; &lt;label class=&quot;label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;control&quot;&gt; &lt;input type=&quot;email&quot; class=&quot;input&quot; name=&quot;email&quot; v-model=&quot;email&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;label class=&quot;label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;control&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;input&quot; name=&quot;password&quot; v-model=&quot;password&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;control&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;button is-dark is-fullwidth&quot;&gt;Log In&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;div class=&quot;has-text-centered&quot; style=&quot;margin-top: 20px&quot;&gt; &lt;p&gt; Don&#x27;t have an account? &lt;nuxt-link to=&quot;/register&quot;&gt;Register&lt;/nuxt-link&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;import Notification from &#x27;~/components/Notification&#x27;export default &#123; components: &#123; Notification, &#125;, data() &#123; return &#123; email: &#x27;&#x27;, password: &#x27;&#x27;, error: null &#125; &#125;, methods: &#123; async login() &#123; try &#123; await this.$auth.loginWith(&#x27;local&#x27;, &#123; data: &#123; email: this.email, password: this.password &#125; &#125;) this.$router.push(&#x27;/&#x27;) &#125; catch (e) &#123; this.error = e.response.data.message &#125; &#125; &#125;&#125;&lt;/script&gt; Copy This is quite similar to the register page. The form contains two fields: email and password. When the form is submitted, a login method will be called. Using the Auth module loginWith() and passing along the user data, you log the user in. If the authentication was successful, you redirect the user to the homepage. Otherwise, set error to the error message gotten from the API response. Again, you are using the Notification component from earlier on to display the error message. Step 8 — Displaying the User ProfileLet’s allow logged in users to view their profile. Create a new profile.vue file inside the pages directory: 1nano pages/profile.vue Copy And paste the code below in it: pages&#x2F;profile.vue 123456789101112131415161718192021222324252627&lt;template&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;My Profile&lt;/h2&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt; &lt;strong&gt;Username:&lt;/strong&gt; &#123;&#123; loggedInUser.username &#125;&#125; &lt;/p&gt; &lt;p&gt; &lt;strong&gt;Email:&lt;/strong&gt; &#123;&#123; loggedInUser.email &#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapGetters &#125; from &#x27;vuex&#x27;export default &#123; computed: &#123; ...mapGetters([&#x27;loggedInUser&#x27;]) &#125;&#125;&lt;/script&gt; Copy Notice how you are using the loggedInUser getter from earlier on to display the user details. Clicking on the My Profile link should result in a My Profile page being displayed. Step 9 — Logging Users OutUpdate the logout link inside the Navbar component. Open Navbar.vue: 1nano components/Navbar.vue Copy Modify the logout link to use @click=&quot;logout&quot;: components&#x2F;Navbar.vue 1234567// ...&lt;div class=&quot;navbar-dropdown&quot;&gt; &lt;nuxt-link class=&quot;navbar-item&quot; to=&quot;/profile&quot;&gt;My Profile&lt;/nuxt-link&gt; &lt;hr class=&quot;navbar-divider&quot;/&gt; &lt;a class=&quot;navbar-item&quot; @click=&quot;logout&quot;&gt;Logout&lt;/a&gt;&lt;/div&gt;// ... Copy When the logout link is clicked, it will trigger a logout method. Next, let’s add the logout method inside the script section of the Navbar component: components&#x2F;Navbar.vue 12345678910// ...export default &#123; // ... methods: &#123; async logout() &#123; await this.$auth.logout(); &#125;, &#125;,&#125; Copy You call the logout() of the Auth module. This will delete the user’s token from localstorage and redirect the user to the homepage. Step 10 — Restricting the Profile PageAs it stands now, anybody can visit the profile page. And if the user is not logged in, it will result in an error. To fix this, you need to restrict the profile page to only logged in users. Luckily for us, you can achieve that with the Auth module. The Auth module comes with an auth middleware, which you can use in this scenario. So let’s add the auth middleware to the profile page. Update the script section as below: pages&#x2F;profile.vue 123456// ...export default &#123; middleware: &#x27;auth&#x27;, // ...&#125; Copy Now when a user that is not logged in tries to visit the profile page, the user will be redirected to the login page. Step 11 — Creating a Guest MiddlewareAgain as it stands, even as a logged in user, you can still access the login and register pages. One way to fix that is to restrict login and register pages to only users that are not logged in. You can do that by creating a guest middleware. Inside the middleware directory, create a new guest.js file: 1nano middleware/guest.js Copy And paste the code below in it: middleware&#x2F;guest.js 12345export default function (&#123; store, redirect &#125;) &#123; if (store.state.auth.loggedIn) &#123; return redirect(&#x27;/&#x27;) &#125;&#125; Copy A middleware accepts the context as its first argument. So you extract store and redirect from the context. Then, you check if the user is logged in then redirect the user to the homepage. Otherwise, you allow the normal execution of the request. Next, let’s make use of this middleware. Update the script section of both login and register as below: pages&#x2F;login.vue and pages&#x2F;register.vue 123456// ...export default &#123; middleware: &#x27;guest&#x27;, // ...&#125; Copy Now, everything will be working as expected. ConclusionIn this tutorial, you looked at how to implement authentication in a Nuxt.js application using the Auth module. You also saw how to keep the authentication flow sleek by making use of middleware. To learn more about the Auth module, check out the docs. If you’d like to learn more about Vue.js, check out our Vue.js topic page for exercises and programming projects.","categories":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://marvinliu1.github.io/categories/Nuxt/"}],"tags":[{"name":"NeXt","slug":"NeXt","permalink":"https://marvinliu1.github.io/tags/NeXt/"},{"name":"Vue","slug":"Vue","permalink":"https://marvinliu1.github.io/tags/Vue/"}]},{"title":"Markdown公式用法大全","slug":"Markdown公式用法大全","date":"2020-05-21T06:12:31.000Z","updated":"2022-05-24T22:44:16.653Z","comments":true,"path":"2020/05/21/Markdown公式用法大全/","link":"","permalink":"https://marvinliu1.github.io/2020/05/21/Markdown%E5%85%AC%E5%BC%8F%E7%94%A8%E6%B3%95%E5%A4%A7%E5%85%A8/","excerpt":"","text":"基本语法Markdown是一种轻量级标记语言 123456789# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题**加粗***斜体*==高亮== 两种代码引用方式1``式或```式 插入链接并描述1[博客](https://www.cnblogs.com/ &quot;博客&quot;) 插入图片1![路飞](https://pic.baike.soso.com/ugc/baikepic2/0/ori-20190529230042-1249666563_jpeg_640_960_59726.jpg/800 &#x27;路飞&#x27;) 有序列表1231.one2.two3.three 无序列表123* one* two* three 分割线1--- 表格123name | age | sex:-: | :- | -:tony|20|男 name age sex tony 20 男 注：代码中第二行分别表示居中，右对齐，左对齐，若结果不显示，转化成源代码模式去掉行与行之间的空行。 如何插入公式数学公式有两种：行中公式（与文字搭配使用）和独立公式（独立成行） 行内公式表示：$ 数学公式 $ 独立公式表示：$$ 数学公式 $$ 如何输入上下标^ 表示上标, _ 表示下标。如果上下标的内容多于一个字符，需要用 &#123;&#125; 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。 如：$$ x^&#123;y^z&#125;=(1+&#123;\\rm e&#125;^x)^&#123;-2xy^w&#125; $$,显示：$x{yz}&#x3D;(1+{\\rm e}x){-2xy^w} $ 另外，如果要在左右两边都有上下标，可以用 \\sideset 命令。 如：$$ \\sideset&#123;^1_2&#125;&#123;^3_4&#125;\\bigotimes $$,显示：$ \\sideset{1_2}{3_4}\\bigotimes $ 如何输入括号和分隔符()、[] 和 | 表示符号本身，使用 \\&#123;\\&#125; 来表示 &#123;&#125; 。当要显示大号的括号或分隔符时，要用 \\left 和 \\right 命令。 输入 显示 输入 显示 \\langle ⟨⟨ \\rangle ⟩⟩ \\lceil ⌈⌈ \\rceil ⌉⌉ \\lfloor ⌊⌊ \\rfloor ⌋⌋ \\lbrace { { \\rbrace } } 如：$$ f(x,y,z) = 3y^2z \\left( 3+\\frac&#123;7x+5&#125;&#123;1+y^2&#125; \\right) $$,显示：f(x,y,z)&#x3D;3y2z(3+7x+51+y2)f(x,y,z)&#x3D;3y2z(3+7x+51+y2) 有时候要用 \\left. 或 \\right. 进行匹配而不显示本身。 如：$$ \\left. \\frac&#123;&#123;\\rm d&#125;u&#125;&#123;&#123;\\rm d&#125;x&#125; \\right| _&#123;x=0&#125; $$`,显示：[MathProcessingError]dudx∣∣x=0[MathProcessingError]dudx|x=0 ### 如何输入分数 通常使用 `\\frac &#123;分子&#125; &#123;分母&#125;` 命令产生一个分数，分数可嵌套。便捷情况可直接输入 `\\frac ab` 来快速生成一个 abab 。 如果分式很复杂，亦可使用 `分子 \\over 分母` 命令，此时分数仅有一层。 如：`$$ \\frac&#123;a-1&#125;&#123;b-1&#125; \\quad and \\quad &#123;a+1\\over b+1&#125; $$`,显示：a−1b−1anda+1b+1a−1b−1anda+1b+1 ### 如何输入开方 使用 `\\sqrt [根指数，省略时为2] &#123;被开方数&#125;` 命令输入开方。 如：`$$ \\sqrt&#123;2&#125; \\quad and \\quad \\sqrt[n]&#123;3&#125; $$`,显示：2–√and3–√n2and3n ### 如何输入省略号 数学公式中常见的省略号有两种，`\\ldots` 表示与文本底线对齐的省略号，`\\cdots` 表示与文本中线对齐的省略号。 如：`$$ f(x_1,x_2,\\underbrace&#123;\\ldots&#125;_&#123;\\rm ldots&#125; ,x_n) = x_1^2 + x_2^2 + \\underbrace&#123;\\cdots&#125;_&#123;\\rm cdots&#125; + x_n^2 $$`,显示：$ f(x_1,x_2,\\underbrace&#123;\\ldots&#125;*&#123;\\rm ldots&#125; ,x_n) = x_1^2 + x_2^2 + \\underbrace&#123;\\cdots&#125;*&#123;\\rm cdots&#125; + x_n^2 $ ### 如何输入矢量 使用 `\\vec&#123;矢量&#125;` 来自动产生一个矢量。也可以使用 `\\overrightarrow` 等命令自定义字母上方的符号。 如：`$$ \\vec&#123;a&#125; \\cdot \\vec&#123;b&#125;=0 $$`,显示： a⃗ ⋅b⃗ =0a→⋅b→=0 如：`$$ \\overleftarrow&#123;xy&#125; \\quad and \\quad \\overleftrightarrow&#123;xy&#125; \\quad and \\quad \\overrightarrow&#123;xy&#125; $$`,显示： xy←−andxy←→andxy−→xy←andxy↔andxy→ ### 如何输入积分 使用 `\\int_积分下限^积分上限 &#123;被积表达式&#125;` 来输入一个积分。 如：`$$ \\int_0^1 &#123;x^2&#125; \\,&#123;\\rm d&#125;x $$`,显示：∫10x2,dx∫01x2,dx,例中 `\\,` 和 `&#123;\\rm d&#125;` 部分可省略，建议加入，使式子更美观。 ### 如何输入极限运算 使用 `\\lim_&#123;变量 \\to 表达式&#125; 表达式` 来输入一个极限。如有需求，可以更改 `\\to` 符号至任意符号。 如：`$$ \\lim_&#123;n \\to +\\infty&#125; \\frac&#123;1&#125;&#123;n(n+1)&#125; \\quad and \\quad \\lim_&#123;x\\leftarrow&#123;示例&#125;&#125; \\frac&#123;1&#125;&#123;n(n+1)&#125; $$,显示： limn→+∞1n(n+1)andlimx←示例1n(n+1)limn→+∞1n(n+1)andlimx←示例1n(n+1) 如何输入累加、累乘运算使用 \\sum_&#123;下标表达式&#125;^&#123;上标表达式&#125; &#123;累加表达式&#125; 来输入一个累加。与之类似，使用 \\prod \\bigcup \\bigcap 来分别输入累乘、并集和交集。此类符号在行内显示时上下标表达式将会移至右上角和右下角。 如：$$ \\sum_&#123;i=1&#125;^n \\frac&#123;1&#125;&#123;i^2&#125; \\quad and \\quad \\prod_&#123;i=1&#125;^n \\frac&#123;1&#125;&#123;i^2&#125; \\quad and \\quad \\bigcup_&#123;i=1&#125;^&#123;2&#125; R $$,显示：∑ni&#x3D;11i2and∏ni&#x3D;11i2and⋃2i&#x3D;1R∑i&#x3D;1n1i2and∏i&#x3D;1n1i2and⋃i&#x3D;12R 如何输入希腊字母输入 \\小写希腊字母英文全称 和 \\首字母大写希腊字母英文全称 来分别输入小写和大写希腊字母,对于大写希腊字母与现有字母相同的，直接输入大写字母即可。 输入 显示 输入 显示 输入 显示 输入 显示 \\alpha αα A AA \\beta ββ B BB \\gamma γγ \\Gamma ΓΓ \\delta δδ \\Delta ΔΔ \\epsilon ϵϵ E EE \\zeta ζζ Z ZZ \\eta ηη H HH \\theta θθ \\Theta ΘΘ \\iota ιι I II \\kappa κκ K KK \\lambda λλ \\Lambda ΛΛ \\mu μμ M MM \\nu νν N NN \\xi ξξ \\Xi ΞΞ o oo O OO \\pi ππ \\Pi ΠΠ \\rho ρρ P PP \\sigma σσ \\Sigma ΣΣ \\tau ττ T TT \\upsilon υυ \\Upsilon ΥΥ \\phi ϕϕ \\Phi ΦΦ \\chi χχ X XX \\psi ψψ \\Psi ΨΨ \\omega ωω \\Omega ΩΩ 部分字母有变量专用形式，以 \\var- 开头。 小写形式 大写形式 变量形式 显示 \\epsilon E \\varepsilon ϵ∣E∣εϵ∣E∣ε \\theta \\Theta \\vartheta θ∣Θ∣ϑθ∣Θ∣ϑ \\rho P \\varrho ρ∣P∣ϱρ∣P∣ϱ \\sigma \\Sigma \\varsigma σ∣Σ∣ςσ∣Σ∣ς \\phi \\Phi \\varphi ϕ∣Φ∣φϕ∣Φ∣φ 如何输入其它特殊字符若需要显示更大或更小的字符，在符号前插入 \\large 或 \\small 命令。若找不到需要的符号，使用 Detexify2Detexify2 来画出想要的符号。 关系运算符 输入 显示 输入 显示 输入 显示 输入 显示 \\pm ±± \\times ×× \\div ÷÷ \\mid ∣∣ \\nmid ∤∤ \\cdot ⋅⋅ \\circ ∘∘ \\ast ∗∗ \\bigodot ⨀⨀ \\bigotimes ⨂⨂ \\bigoplus ⨁⨁ \\leq ≤≤ \\geq ≥≥ \\neq ≠≠ \\approx ≈≈ \\equiv ≡≡ \\sum ∑∑ \\prod ∏∏ \\coprod ∐∐ \\backslash ∖∖ 集合运算符 输入 显示 输入 显示 输入 显示 \\emptyset ∅∅ \\in ∈∈ \\notin ∉∉ \\subset ⊂⊂ \\supset ⊃⊃ \\subseteq ⊆⊆ \\supseteq ⊇⊇ \\bigcap ⋂⋂ \\bigcup ⋃⋃ \\bigvee ⋁⋁ \\bigwedge ⋀⋀ \\biguplus ⨄⨄ 对数运算符 输入 显示 输入 显示 输入 显示 \\log loglog \\lg lglg \\ln lnln 三角运算符 输入 显示 输入 显示 输入 显示 30^\\circ 30∘30∘ \\bot ⊥⊥ \\angle A ∠A∠A \\sin sinsin \\cos coscos \\tan tantan \\csc csccsc \\sec secsec \\cot cotcot 微积分运算符 输入 显示 输入 显示 输入 显示 \\int ∫∫ \\iint ∬∬ \\iiint ∭∭ \\iiiint ∬∬⨌ \\oint ∮∮ \\prime ′′ \\lim limlim \\infty ∞∞ \\nabla ∇∇ 逻辑运算符 输入 显示 输入 显示 输入 显示 \\because ∵∵ \\therefore ∴∴ \\forall ∀∀ \\exists ∃∃ \\not\\subset ⊄⊄ \\not&lt; ≮≮ \\not&gt; ≯≯ \\not&#x3D; ≠≠ 戴帽符号 输入 显示 输入 显示 \\hat{xy} xy^xy^ \\widehat{xyz} xyzˆxyz^ \\tilde{xy} xyxy \\widetilde{xyz} xyz˜xyz~ \\check{x} xˇxˇ \\breve{y} y˘y˘ \\grave{x} xx \\acute{y} y´y´ 连线符号 输入 显示 \\fbox{a+b+c+d} a+b+c+da+b+c+d \\overleftarrow{a+b+c+d} a+b+c+d←−−−a+b+c+d← \\overrightarrow{a+b+c+d} a+b+c+d−→−−a+b+c+d→ \\overleftrightarrow{a+b+c+d} a+b+c+d←→−a+b+c+d↔ \\underleftarrow{a+b+c+d} a+b+c+d←−−−a+b+c+d← \\underrightarrow{a+b+c+d} a+b+c+d−→−−a+b+c+d→ \\underleftrightarrow{a+b+c+d} a+b+c+d←→−a+b+c+d↔ \\overline{a+b+c+d} a+b+c+d¯¯¯¯¯¯¯¯¯¯¯a+b+c+d¯ \\underline{a+b+c+d} a+b+c+d–––––a+b+c+d_ \\overbrace{a+b+c+d}^{Sample} a+b+c+dSamplea+b+c+d⏞Sample \\underbrace{a+b+c+d}_{Sample} a+b+c+dSamplea+b+c+d⏟Sample \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} a+b+c1.0+d2.0a+b+c⏟1.0+d⏞2.0 \\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}} a⋅a⋯ab timesa⋅a⋯a⏟b times 箭头符号 推荐使用符号：|输入|显示|输入|显示|输入|显示||:–😐:–😐:–😐:–😐:–😐:–😐|\\to|$ \\to|↦||↦| \\mapsto||||⟹|||||⟹| \\implies|⟺||⟺| \\iff|⟸||⟸| \\impliedby$| 其它可用符号：|输入|显示|输入|显示||:–😐:–😐:–😐:–😐|\\uparrow|$ \\uparrow|⇑||⇑| \\Uparrow||↓|||↓| \\downarrow|⇓||⇓| \\Downarrow||←|||←| \\leftarrow|⇐||⇐| \\Leftarrow||→|||→| \\rightarrow|⇒||⇒| \\Rightarrow||↔|||↔| \\leftrightarrow|⇔||⇔| \\Leftrightarrow||⟵|||⟵| \\longleftarrow|⟸||⟸| \\Longleftarrow||⟶|||⟶| \\longrightarrow|⟹||⟹| \\Longrightarrow||⟷|||⟷| \\longleftrightarrow|⟺||⟺| \\Longleftrightarrow$| 如何进行字体转换若要对公式的某一部分字符进行字体转换，可以用 &#123;\\字体 &#123;需转换的部分字符&#125;&#125; 命令，其中 \\字体 部分可以参照下表选择合适的字体。一般情况下，公式默认为意大利体 italicitalic 。示例中 全部大写 的字体仅大写可用。 输入 说明 显示 输入 说明 显示 \\rm 罗马体 SampleSample \\cal 花体 SAMPLESAMPLE \\it 意大利体 SampleSample \\Bbb 黑板粗体 SAMPLESAMPLE \\bf 粗体 SampleSample \\mit 数学斜体 SAMPLESAMPLE \\sf 等线体 SampleSample \\scr 手写体 SAMPLESAMPLE \\tt 打字机体 SampleSample \\frak 旧德式字体 SampleSample 转换字体十分常用，例如在积分中： 12345\\begin&#123;array&#125;&#123;cc&#125;\\mathrm&#123;Bad&#125; &amp; \\mathrm&#123;Better&#125; \\\\\\hline \\\\\\int_0^1 x^2 dx &amp; \\int_0^1 x^2 \\,&#123;\\rm d&#125;x\\end&#123;array&#125; 显示：\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\hline \\\\int_0^1 x^2 dx &amp; \\int_0^1 x^2 ,{\\rm d}x\\end{array}\\begin{array}{cc} \\mathrm{Bad} &amp; \\mathrm{Better} \\ \\hline \\ \\int_0^1 x^2 dx &amp; \\int_0^1 x^2 ,{\\rm d}x \\end{array},注意比较两个式子间 dxdx 与 dxdx 的不同。 如何使用大括号和行标使用 \\left 和 \\right 来创建自动匹配高度的 (圆括号)，[方括号] 和 {花括号} ，在每个公式末尾前使用 \\tag&#123;行标&#125; 来实现行标。 例如： 123456789101112131415$$f\\left( \\left[ \\frac&#123; 1+\\left\\&#123;x,y\\right\\&#125; &#125;&#123; \\left( \\frac&#123;x&#125;&#123;y&#125;+\\frac&#123;y&#125;&#123;x&#125; \\right) \\left(u+1\\right) &#125;+a \\right]^&#123;3/2&#125;\\right)\\tag&#123;行标&#125;$$ 显示： f⎛⎝⎜⎜⎡⎣⎢1+{x,y}(xy+yx)(u+1)+a⎤⎦⎥3&#x2F;2⎞⎠⎟⎟(行标)(行标)f([1+{x,y}(xy+yx)(u+1)+a]3&#x2F;2) 如果你需要在不同的行显示对应括号，可以在每一行对应处使用 \\left. 或 \\right. 来放一个”影子”括号： 例如： 123456$$\\begin&#123;aligned&#125;a=&amp;\\left(1+2+3+ \\cdots \\right. \\\\&amp; \\cdots+ \\left. \\infty-2+\\infty-1+\\infty\\right)\\end&#123;aligned&#125;$$ 显示： a&#x3D;(1+2+3+⋯⋯+∞−2+∞−1+∞)a&#x3D;(1+2+3+⋯⋯+∞−2+∞−1+∞) 如果你需要将行内显示的分隔符也变大，可以使用 \\middle 命令： 例如： 123456789$$\\left\\langle q\\middle\\| \\frac&#123;\\frac&#123;x&#125;&#123;y&#125;&#125;&#123;\\frac&#123;u&#125;&#123;v&#125;&#125;\\middle| p \\right\\rangle$$ 显示： ⟨q∥∥∥xyuv∣∣∣p⟩⟨q‖xyuv|p⟩ 其它公式定义新的符号\\operatorname如：$$ \\operatorname&#123;Symbol&#125; A $$，显示： SymbolASymbol⁡A 添加注释文字 \\text在 \\text &#123;文字&#125; 中仍可以使用 $公式$ 插入其它公式。 如：$$ f(n)= \\begin&#123;cases&#125; n/2, &amp; \\text &#123;if $n$ is even&#125; \\\\ 3n+1, &amp; \\text&#123;if $n$ is odd&#125; \\end&#123;cases&#125; $$ 显示：$ f(n)&#x3D; \\begin{cases} n&#x2F;2, &amp; \\text {if nn is even} \\ 3n+1, &amp; \\text{if nn is odd} \\end{cases} $ 在字符间加入空格有四种宽度的空格可以使用： \\,、\\;、\\quad 和 \\qquad 。 如：$$ a \\, b \\mid a \\; b \\mid a \\quad b \\mid a \\qquad b $$,显示：a,b∣a;b∣ab∣aba,b∣a;b∣ab∣ab 当然，使用 \\text &#123;n个空格&#125; 也可以达到同样效果。 更改文字颜色使用 \\color&#123;颜色&#125;&#123;文字&#125; 来更改特定的文字颜色,更改文字颜色 需要浏览器支持，如果浏览器不知道你所需的颜色，那么文字将被渲染为黑色。对于较旧的浏览器（HTML4与CSS2），以下颜色是被支持的： 输入 显示 输入 显示 black texttext grey texttext silver texttext white texttext maroon texttext red texttext yellow texttext lime texttext olive texttext green texttext teal texttext auqa texttext blue texttext navy texttext purple texttext fuchsia texttext 对于较新的浏览器（HTML5与CSS3），额外的124种颜色将被支持：输入 &#96;\\color","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/categories/Hexo/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://marvinliu1.github.io/tags/MarkDown/"},{"name":"Next","slug":"Next","permalink":"https://marvinliu1.github.io/tags/Next/"}]},{"title":"Node in Debugging 1.1 Perf + FameGraph","slug":"NiD-1.1.1 perf","date":"2020-05-21T06:12:31.000Z","updated":"2022-05-25T04:00:18.145Z","comments":true,"path":"2020/05/21/NiD-1.1.1 perf/","link":"","permalink":"https://marvinliu1.github.io/2020/05/21/NiD-1.1.1%20perf/","excerpt":"","text":"Node in Debugging 当程序出现性能瓶颈时，我们通常通过表象（比如请求某个接口时 CPU 使用率飙涨）然后结合代码去推测可能出问题的地方，却不知道问题到底是什么引起的。如果有个一可视化的工具直观地展现程序的性能瓶颈就好了，幸好 Brendan D. Gregg 发明了火焰图。 火焰图（Flame Graph）看起来就像一团跳动的火焰，因此得名。火焰图可以将 CPU 的使用情况可视化，使我们直观地了解到程序的性能瓶颈，通常要结合操作系统的性能分析工具（profiling tracer）使用，常见的操作系统的性能分析工具如下： Linux：perf, eBPF, SystemTap, and ktap。 Solaris, illumos, FreeBSD：DTrace。 Mac OS X：DTrace and Instruments。 Windows：Xperf.exe。 1.1.1 perfperf_events（简称 perf）是 Linux Kernal 自带的系统性能分析工具，能够进行函数级与指令级的热点查找。它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析，常用于查找性能瓶颈及定位热点代码。 测试机器： 12$ uname -aLinux nswbmw-VirtualBox 4.10.0-28-generic #32~16.04.2-Ubuntu SMP Thu Jul 20 10:19:48 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux 注意：非 Linux 用户需要用虚拟机安装 Ubuntu 16.04 和 &#110;&#x6f;&#100;&#101;&#x40;&#x38;&#x2e;&#x39;&#46;&#x34; 后进行后面的操作。 安装 perf： 123$ sudo apt install linux-tools-common$ perf # 根据提示安装对应的内核版本的 tools, 如下$ sudo apt install linux-tools-4.10.0-28-generic linux-cloud-tools-4.10.0-28-generic 创建测试目录 ~&#x2F;test 和测试代码： app.js 12345678910111213141516171819202122232425262728293031323334const crypto = require(&#x27;crypto&#x27;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()const users = &#123;&#125;app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/newUser&#x27;, controller (ctx) &#123; const username = ctx.query.username || &#x27;test&#x27; const password = ctx.query.password || &#x27;test&#x27; const salt = crypto.randomBytes(128).toString(&#x27;base64&#x27;) const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, &#x27;sha512&#x27;).toString(&#x27;hex&#x27;) users[username] = &#123; salt, hash &#125; ctx.status = 204&#125;&#125;)app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/auth&#x27;, controller (ctx) &#123; const username = ctx.query.username || &#x27;test&#x27; const password = ctx.query.password || &#x27;test&#x27; if (!users[username]) &#123; ctx.throw(400) &#125; const hash = crypto.pbkdf2Sync(password, users[username].salt, 10000, 64, &#x27;sha512&#x27;).toString(&#x27;hex&#x27;) if (users[username].hash === hash) &#123; ctx.status = 204 &#125; else &#123; ctx.throw(403) &#125;&#125;&#125;) app.listen(3000) 添加 –perf_basic_prof（或者 –perf-basic-prof）参数运行此程序，会对应生成一个 &#x2F;tmp&#x2F;perf-.map 的文件。命令如下： 12345678910111213$ node --perf_basic_prof app.js &amp;[1] 3590$ tail /tmp/perf-3590.map51b87a7b93e 18 Function:~emitListeningNT net.js:137551b87a7b93e 18 LazyCompile:~emitListeningNT net.js:137551b87a7bad6 39 Function:~emitAfterScript async_hooks.js:44351b87a7bad6 39 LazyCompile:~emitAfterScript async_hooks.js:44351b87a7bcbe 77 Function:~tickDone internal/process/next_tick.js:8851b87a7bcbe 77 LazyCompile:~tickDone internal/process/next_tick.js:8851b87a7bf36 12 Function:~clear internal/process/next_tick.js:4251b87a7bf36 12 LazyCompile:~clear internal/process/next_tick.js:4251b87a7c126 b8 Function:~emitPendingUnhandledRejections internal/process/promises.js:8651b87a7c126 b8 LazyCompile:~emitPendingUnhandledRejections internal/process/promises.js:86 map 文件内容三列依次为：16进制的符号地址（symbol addresses）、大小（sizes）和符号名（symbol names）。perf 会尝试查找 &#x2F;tmp&#x2F;perf-.map 文件，用来做符号转换，即把 16 进制的符号地址转换成人能读懂的符号名。 注意：使用 –perf_basic_prof_only_functions 参数也可以，但经尝试后发现生成的火焰图信息不全（不全的地方显示 [perf-.map]），所以这里使用 –perf_basic_prof。但是，使用 –perf_basic_prof 有个缺点，就是会导致 map 文件一直增大，这是由于符号（symbols）地址不断变换导致的，用 –perf_basic_prof_only_functions 可以缓解这个问题。关于如何取舍，还请读者自行尝试。 接下来 clone 用来生成火焰图的工具： 1$ git clone http://github.com/brendangregg/FlameGraph ~/FlameGraph 我们先用 ab 压测： 12$ curl &quot;http://localhost:3000/newUser?username=admin&amp;password=123456&quot;$ ab -k -c 10 -n 2000 &quot;http://localhost:3000/auth?username=admin&amp;password=123456&quot; 新开另一个终端，在 ab 开始压测后立即运行： 1234$ sudo perf record -F 99 -p 3590 -g -- sleep 30$ sudo chown root /tmp/perf-3590.map$ sudo perf script &gt; perf.stacks$ ~/FlameGraph/stackcollapse-perf.pl --kernel &lt; ~/perf.stacks | ~/FlameGraph/flamegraph.pl --color=js --hash&gt; ~/flamegraph.svg 注意：第 1 次生成的 svg 可能不太准确，最好重复几次以上步骤，使用第 2 次及以后生成的 flamegraph.svg。 有几点需要解释一下： perf record -F 指定了采样频率 99Hz（即每秒 99 次，如果 99 次都返回同一个函数名，那就说明 CPU 在这一秒钟都在执行同一个函数，可能存在性能问题）。 -p 指定进程的 pid。 -g 启用 call-graph 记录。 – sleep 30 指定记录 30s。 sudo chown root &#x2F;tmp&#x2F;perf-3009.map，将 map 文件更改为 root 权限，否则会报如下错误： File &#x2F;tmp&#x2F;perf-PID.map not owned by current user or root, ignoring it (use -f to override). Failed to open &#x2F;tmp&#x2F;perf-PID.map, continuing without symbols perf record 会将记录的信息保存到当前执行目录的 perf.data 文件中，然后使用 perf script 读取 perf.data 的 trace 信息写入 perf.stacks。 –color&#x3D;js 指定生成针对 JavaScript 配色的 svg，即： green：JavaScript。 blue：Builtin。 yellow：C++。 red：System（native user-level, and kernel）。 ab 压测用了 30s 左右，用浏览器打开 flamegraph.svg，截取关键的部分如下图所示： 1.1.2 理解火焰图火焰图含义： 每一个小块代表了一个函数在栈中的位置（即一个栈帧）。 Y 轴代表栈的深度（栈上的帧数），顶端的小块显示了占据 CPU 的函数。每个小块的下面是它的祖先（即父函数）。 X 轴代表总的样例群体。它不像绝大多数图表那样从左到右表示时间的流逝，其左右顺序没有特殊含义，仅仅按照字母表的顺序排列。 小块的宽度代表 CPU 的使用时间，或者说相对于父函数而言使用 CPU 的比例（基于所有样例），越宽则代表占用 CPU 的时间越长，或者使用 CPU 很频繁。 如果采取多线程并发运行取样，则取样数量会超过运行时间。 从上图可以看出：最上面的绿色小块（即 JavaScript 代码）指向 test&#x2F;app.js 第 18 行，即 GET /auth 这个路由。再往上看，黄色的小块（即 C++ 代码） node::crypto::PBKDF2 占用了大量的 CPU 时间。 解决方法：将同步改为异步，即将 crypto.pbkdf2Sync 改为 crypto.pbkdf2。修改如下： 12345678910111213141516171819202122app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/auth&#x27;, async controller (ctx) &#123; const username = ctx.query.username || &#x27;test&#x27; const password = ctx.query.password || &#x27;test&#x27; if (!users[username]) &#123; ctx.throw(400) &#125; const hash = await new Promise((resolve, reject) =&gt; &#123; crypto.pbkdf2(password, users[username].salt, 10000, 64, &#x27;sha512&#x27;, (err, derivedKey) =&gt; &#123; if (err) &#123; return reject(err) &#125; resolve(derivedKey.toString(&#x27;hex&#x27;)) &#125;) &#125;) if (users[username].hash === hash) &#123; ctx.status = 204 &#125; else &#123; ctx.throw(403) &#125;&#125;&#125;) 用 ab 重新压测，结果用了 16s。重新生成的火焰图如下： 可以看出：只有在左侧极窄的绿色小块可以看到 JavaScript 代码，红色的部分我们不关心也无法优化。那么，为什么异步比同步的 QPS 要高呢？原因是 Node.js 底层的 libuv 用了多个线程进行计算，这里就不再深入介绍了。 svg 火焰图的其他小技巧如下： 单击任意一个小块即可展开，即被单击的小块宽度变宽，它的子函数也按比例变宽，方便查看。 可单击 svg 右上角的 search 按钮进行搜索，被搜索的关键词会高亮显示，在有目的地查找某个函数时比较有用。 1.1.3 红蓝差分火焰图虽然我们有了火焰图，但要处理性能回退问题，还需要在修改代码前后的火焰图之间，不断切换和对比，来找出问题所在，很不方便。于是 Brendan D. Gregg 又发明了红蓝差分火焰图（Red&#x2F;Blue Differential Flame Graphs）。 如下所示：红色表示增长，蓝色表示衰减。 红蓝差分火焰图的工作原理如下： 抓取修改前的栈 profile1 文件。 抓取修改后的栈 profile2 文件。 使用 profile2 来生成火焰图，这样栈帧的宽度就是以 profile2 文件为基准的。 使用 profile2 - profile1 的差异来对火焰图重新上色。上色的原则是：如果栈帧在 profile2 中出现出现的次数更多，则标为红色，否则标为蓝色。色彩是根据修改前后的差异来填充的。 这样，通过红蓝差分火焰图，我们就可以清楚地看到系统性能的差异之处。 生成红蓝差分火焰图的流程如下： 修改代码前运行： 123$ sudo perf record -F 99 -p &lt;PID&gt; -g -- sleep 30$ sudo chown root /tmp/perf-&lt;PID&gt;.map$ sudo perf script &gt; perf_before.stacks 修改代码后运行： 123$ sudo perf record -F 99 -p &lt;PID&gt; -g -- sleep 30$ sudo chown root /tmp/perf-&lt;PID&gt;.map$ sudo perf script &gt; perf_after.stacks 将 profile 文件进行折叠（fold），然后生成差分火焰图： 123$ ~/FlameGraph/stackcollapse-perf.pl ~/perf_before.stacks &gt; perf_before.folded$ ~/FlameGraph/stackcollapse-perf.pl ~/perf_after.stacks &gt; perf_after.folded$ ./FlameGraph/difffolded.pl perf_before.folded perf_after.folded | ./FlameGraph/flamegraph.pl &gt; flamegraph_diff.svg 如上缺点是：如果一个代码执行路径完全消失了，那么在火焰图中就找不到地方来标注蓝色，我们只能看到当前的 CPU 使用情况，却不知道为什么会变成这样。 一种解决办法是：生成一个相反的差分火焰图，即基于 profile1 生成 profile1 - profile2 的差分火焰图。对应命令如下： 1$ ./FlameGraph/difffolded.pl perf_after.folded perf_before.folded | ./FlameGraph/flamegraph.pl --negate &gt; flamegraph_diff2.svg 其中，–negate 用于颠倒红&#x2F;蓝配色。最终我们得到： flamegraph_diff.svg：宽度是以修改前的 profile 文件为基准，颜色表明将要发生的情况。 flamegraph_diff2.svg：宽度是以修改后的 profile 文件为基准，颜色表明已经发生的情况。 总之，红蓝差分火焰图可能只在代码变化不大的情况下使用时效果明显，在代码变化较大的情况下使用时效果可能就不明显了。 1.1.4 参考链接 https://yunong.io/2015/11/23/generating-node-js-flame-graphs/ http://www.brendangregg.com/perf.html http://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html https://linux.cn/article-4670-1.html http://www.brendangregg.com/blog/2014-11-09/differential-flame-graphs.html http://www.ruanyifeng.com/blog/2017/09/flame-graph.html","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging 1.3 Tick Processor","slug":"NiD-1.3.1 Tick Processor","date":"2020-05-21T06:12:31.000Z","updated":"2022-05-25T04:00:10.359Z","comments":true,"path":"2020/05/21/NiD-1.3.1 Tick Processor/","link":"","permalink":"https://marvinliu1.github.io/2020/05/21/NiD-1.3.1%20Tick%20Processor/","excerpt":"","text":"Node in Debugging V8 内置了一个性能分析工具——Tick Processor，可以记录 JavaScript&#x2F;C&#x2F;C++ 代码的堆栈信息，该功能默认是关闭的，可以通过添加命令行参数 --prof 开启。 1.3.1 Tick Processor创建测试代码： app.js 12345678910111213const crypto = require(&#x27;crypto&#x27;)function hash (password) &#123; const salt = crypto.randomBytes(128).toString(&#x27;base64&#x27;) const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, &#x27;sha512&#x27;) return hash&#125;console.time(&#x27;pbkdf2Sync&#x27;)for (let i = 0; i &lt; 100; i++) &#123; hash(&#x27;random_password&#x27;)&#125;console.timeEnd(&#x27;pbkdf2Sync&#x27;) 运行： 12$ node --prof apppbkdf2Sync: 1375.582ms 可以看出，执行 100 次 hash 函数总共用了 1375.585ms，并且当前目录下多了一个 isolate-xxx-v8.log 文件，该文件记录了 V8 的性能日志，内容如下： 12345678v8-version,6,1,534,50,0shared-library,&quot;/usr/local/bin/node&quot;,0x100001800,0x100bbb69a,0...code-creation,Function,18,111912,0x37d07c7246a8,144,&quot;hash /Users/nswbmw/Desktop/test/app.js:3:15&quot;,0x37d07c7076d0,~code-creation,LazyCompile,18,111927,0x37d07c7246a8,144,&quot;hash /Users/nswbmw/Desktop/test/app.js:3:15&quot;,0x37d07c7076d0,~code-creation,Function,18,112058,0x37d07c725690,80,&quot;exports.pbkdf2Sync crypto.js:686:30&quot;,0x37d07c70cb58,~code-creation,LazyCompile,18,112074,0x37d07c725690,80,&quot;exports.pbkdf2Sync crypto.js:686:30&quot;,0x37d07c70cb58,~... 早期我们需要借助 node-tick-processor 这样的工具解析 v8.log，但 Node.js 在 v5.2.0 之后包含了 v8.log 处理器，添加命令行参数 --prof-process 开启。 运行： 1$ node --prof-process isolate-0x103000000-v8.log 结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344Statistical profiling result from isolate-0x103000000-v8.log, (1152 ticks, 44 unaccounted, 0 excluded). [Shared libraries]: ticks total nonlib name [JavaScript]: ticks total nonlib name 1 0.1% 0.1% Function: ~Uint8Array native typedarray.js:158:31 1 0.1% 0.1% Function: ~NativeModule.cache bootstrap_node.js:604:42 1 0.1% 0.1% Function: ~Buffer.toString buffer.js:609:37 [C++]: ticks total nonlib name 1023 88.8% 88.8% T node::crypto::PBKDF2(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) 27 2.3% 2.3% t node::(anonymous namespace)::ContextifyScript::New(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) ... [Summary]: ticks total nonlib name 3 0.3% 0.3% JavaScript 1105 95.9% 95.9% C++ 3 0.3% 0.3% GC 0 0.0% Shared libraries 44 3.8% Unaccounted [C++ entry points]: ticks cpp total name 1062 98.2% 92.2% T v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) 13 1.2% 1.1% T v8::internal::Runtime_CompileLazy(int, v8::internal::Object**, v8::internal::Isolate*) ... [Bottom up (heavy) profile]: Note: percentage shows a share of a particular caller in the total amount of its parent calls. Callers occupying less than 1.0% are not shown. ticks parent name 1023 88.8% T node::crypto::PBKDF2(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) 1023 100.0% T v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) 1023 100.0% Function: ~pbkdf2 crypto.js:691:16 1023 100.0% Function: ~exports.pbkdf2Sync crypto.js:686:30 1023 100.0% Function: ~hash /Users/nswbmw/Desktop/test/app.js:3:15 1023 100.0% Function: ~&lt;anonymous&gt; /Users/nswbmw/Desktop/test/app.js:1:11 ... 打印结果包含六部分：Shared libraries、JavaScript、C++、Summary、C++ entry points 和 Bottom up (heavy) profile。[JavaScript] 部分列出了 JavaScript 代码执行所占用的 CPU ticks（CPU 时钟周期），[C++] 部分列出了 C++ 代码执行所占用的 CPU ticks，[Summary] 列出了各个部分的占比，[Bottom up] 列出了所有 CPU 占用时间从大到小的函数及堆栈信息，小于 1% 的则不予显示。 可以看出：88.8%的 CPU 时间都花在了 crypto.js 文件的 pbkdf2Sync 函数上，该函数在 app.js 第 3 行被调用，即我们的 hash 函数。 解决方法：将同步的 pbkdf2Sync 改为异步的 pbkdf2。修改代码如下： 1234567891011121314151617const crypto = require(&#x27;crypto&#x27;)function hash (password, cb) &#123; const salt = crypto.randomBytes(128).toString(&#x27;base64&#x27;) crypto.pbkdf2(password, salt, 10000, 64, &#x27;sha512&#x27;, cb)&#125;let count = 0console.time(&#x27;pbkdf2&#x27;)for (let i = 0; i &lt; 100; i++) &#123; hash(&#x27;random_password&#x27;, () =&gt; &#123; count++ if (count === 100) &#123; console.timeEnd(&#x27;pbkdf2&#x27;) &#125; &#125;)&#125; 运行结果： 12$ node --prof apppbkdf2: 656.332ms 可以看出，程序运行了 656.332ms，相比较于之前的 1375.585ms，性能提升了 1 倍。我们继续看下 v8.log 的分析结果，运行： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$ node --prof-process isolate-0x102802400-v8.logStatistical profiling result from isolate-0x103001a00-v8.log, (198 ticks, 19 unaccounted, 0 excluded). [Shared libraries]: ticks total nonlib name [JavaScript]: ticks total nonlib name 1 0.5% 0.5% StoreIC: A store IC from the snapshot 1 0.5% 0.5% Function: ~set native collection.js:149:4 1 0.5% 0.5% Function: ~pbkdf2 crypto.js:691:16 1 0.5% 0.5% Function: ~inherits util.js:962:18 1 0.5% 0.5% Builtin: ArrayIteratorPrototypeNext [C++]: ticks total nonlib name 83 41.9% 41.9% T ___kdebug_trace_string 31 15.7% 15.7% t node::(anonymous namespace)::ContextifyScript::New(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) 14 7.1% 7.1% T ___pthread_sigmask ... [Summary]: ticks total nonlib name 5 2.5% 2.5% JavaScript 174 87.9% 87.9% C++ 3 1.5% 1.5% GC 0 0.0% Shared libraries 19 9.6% Unaccounted [C++ entry points]: ticks cpp total name 41 60.3% 20.7% T v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) 17 25.0% 8.6% T v8::internal::Runtime_CompileLazy(int, v8::internal::Object**, v8::internal::Isolate*) ... [Bottom up (heavy) profile]: Note: percentage shows a share of a particular caller in the total amount of its parent calls. Callers occupying less than 1.0% are not shown. ticks parent name 83 41.9% T ___kdebug_trace_string 31 15.7% t node::(anonymous namespace)::ContextifyScript::New(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;) 31 100.0% T v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) 31 100.0% Function: ~runInThisContext bootstrap_node.js:495:28 31 100.0% Function: ~NativeModule.compile bootstrap_node.js:584:44 31 100.0% Function: ~NativeModule.require bootstrap_node.js:516:34 ... 可以看出，[Bottom up] 没有很多 ticks，而且不再有 pbkdf2 这种堆栈信息。 1.3.2 Web UIV8 还提供了一个 Web 可视化工具来查看生成的 v8 日志。首先，将代码还原到使用 pbkdf2Sync 的版本，运行： 1234$ node --prof app # 生成 isolate-0x103000000-v8.log$ node --prof-process --preprocess isolate-0x103000000-v8.log &gt; v8.json # 格式化成 JSON 文件$ git clone https://github.com/v8/v8.git # 克隆 v8 仓库$ open v8/tools/profview/index.html # 打开 V8 profiling log processor 点击 “选择文件”，选择刚才生成的 v8.json 文件，点击 “Bottom up” 视图，如下所示： 有以下两点需要解释： 图中的上半部分展示了 CPU 的 timeline，X 轴代表时间的流逝，Y 轴代表当前时间点不同部分占用 CPU 的比例，可以在 timeline 图表上单击左键不放，然后拖动，选择时间区间。 图中的下半部分展示了当前时间段内 CPU 占用比从大到小降序排列的函数，展开可查看堆栈信息。不同的颜色代表了不同的部分，点击任意一个函数，timeline 底部会展示该函数的执行时间分布。 1.3.3 参考链接 https://github.com/v8/v8/wiki/V8-Profiler https://blog.ghaiklor.com/profiling-nodejs-applications-1609b77afe4e https://stackoverflow.com/questions/23934451/how-to-read-nodejs-internal-profiler-tick-processor-output","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Node in Debugging 1.2 使用 v8-profiler","slug":"Nid-1.2.1 使用 v8-profiler","date":"2020-05-21T06:12:31.000Z","updated":"2022-05-25T04:00:14.597Z","comments":true,"path":"2020/05/21/Nid-1.2.1 使用 v8-profiler/","link":"","permalink":"https://marvinliu1.github.io/2020/05/21/Nid-1.2.1%20%E4%BD%BF%E7%94%A8%20v8-profiler/","excerpt":"","text":"Node in Debugging 我们知道 Node.js 是基于 V8 引擎的，V8 暴露了一些 profiler API，我们可以通过 v8-profiler 收集一些运行时数据（例如：CPU 和内存）。本节将介绍如何使用 v8-profiler 分析 CPU 的使用情况。 1.2.1 使用 v8-profiler创建测试代码： app.js 12345678910111213141516171819202122232425262728const fs = require(&#x27;fs&#x27;)const crypto = require(&#x27;crypto&#x27;)const Bluebird = require(&#x27;bluebird&#x27;)const profiler = require(&#x27;v8-profiler&#x27;)const Paloma = require(&#x27;paloma&#x27;)const app = new Paloma()app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/encrypt&#x27;, controller: function encryptRouter (ctx) &#123; const password = ctx.query.password || &#x27;test&#x27; const salt = crypto.randomBytes(128).toString(&#x27;base64&#x27;) const encryptedPassword = crypto.pbkdf2Sync(password, salt, 10000, 64, &#x27;sha512&#x27;).toString(&#x27;hex&#x27;) ctx.body = encryptedPassword&#125;&#125;)app.route(&#123; method: &#x27;GET&#x27;, path: &#x27;/cpuprofile&#x27;, async controller (ctx) &#123; //Start Profiling profiler.startProfiling(&#x27;CPU profile&#x27;) await Bluebird.delay(30000) //Stop Profiling after 30s const profile = profiler.stopProfiling() profile.export() .pipe(fs.createWriteStream(`cpuprofile-$&#123;Date.now()&#125;.cpuprofile`)) .on(&#x27;finish&#x27;, () =&gt; profile.delete()) ctx.status = 204&#125;&#125;) app.listen(3000) GET /encrypt 有一个 CPU 密集型的计算函数 crypto.pbkdf2Sync，GET /cpuprofile 用来收集 30s 的 V8 log 然后将其 dump 到一个文件中。 运行该程序，打开两个终端窗口。一个终端运行： 1$ curl localhost:3000/cpuprofile 来触发 CPU profiling，然后另一个终端立即运行： 1$ ab -c 20 -n 2000 &quot;http://localhost:3000/encrypt?password=123456&quot; 来触发 CPU 密集计算。 最后生成 cpuprofile-xxx.cpuprofile 文件，该文件的内容其实就是一个大的 JSON 对象，大体如下： 12345678910111213141516171819&#123; &quot;typeId&quot;: &quot;CPU&quot;, &quot;uid&quot;: &quot;1&quot;, &quot;title&quot;: &quot;CPU profile&quot;, &quot;head&quot;: &#123; &quot;functionName&quot;: &quot;(root)&quot;, &quot;url&quot;: &quot;&quot;, &quot;lineNumber&quot;: 0, &quot;callUID&quot;: 154, &quot;bailoutReason&quot;: &quot;&quot;, &quot;id&quot;: 1, &quot;scriptId&quot;: 0, &quot;hitCount&quot;: 0, &quot;children&quot;: [ ... ] &#125;, &quot;startTime&quot;: 276245, &quot;endTime&quot;: 276306, &quot;samples&quot;: [ ... ], &quot;timestamps&quot;: [ ... ]&#125; 这个 JSON 对象记录了函数调用栈、路径、时间戳和一些其他信息，samples 节点数组与 timestamps 节点数组中的时间戳是一一对应的，并且 samples 节点数组中的每一个值其实对应了 head 节点的深度优先遍历 ID。这里我们不深究每个字段的含义，先来看看如何可视化这些数据。 1.2.2 方法 1——Chrome DevToolsChrome 自带了分析 CPU profile 日志的工具。打开 Chrome -&gt; 调出开发者工具（DevTools） -&gt; 单击右上角三个点的按钮 -&gt; More tools -&gt; JavaScript Profiler -&gt; Load，加载刚才生成的 cpuprofile 文件。左上角的下拉菜单可以选择如下三种模式： Chart：显示按时间顺序排列的火焰图。 Heavy (Bottom Up)：按照函数对性能的影响排列，同时可以检查函数的调用路径。 Tree (Top Down)：显示调用结构的总体状况，从调用堆栈的顶端开始。 这里我们选择 Tree (Top Down) 模式，按 Total Time 降序排列。可以看到有如下三列： Self Time：函数调用所耗费的时间，仅包含函数本身的声明，不包含任何子函数的执行时间。 Total Time：函数调用所耗费的总时间，包含函数本身的声明及所有子函数执行时间。即：父函数的 Total Time &#x3D; 父函数的 Self Time + 所有子函数的 Total Time。 Function：函数名及路径，可展开查看子函数。 我们不断地展开，并定位到了 encryptRouter，如下图所示： 可以看出：我们定位到了 encryptRouter 这个路由，并且这个路由中 exports.pbkdf2Sync 占据了绝大部分 CPU 时间。 1.2.3 方法 2——火焰图我们也可以用火焰图来展示 cpuprofile 数据。首先全局安装 flamegraph 模块： 1$ npm i flamegraph -g 运行以下命令将 cpuprofile 文件生成 svg 文件： 1$ flamegraph -t cpuprofile -f cpuprofile-xxx.cpuprofile -o cpuprofile.svg 用浏览器打开 cpuprofile.svg，如下所示： 可以看出：我们定位到了 app.js 的第 8 行，即 encryptRouter 这个路由，并且这个路由中 exports.pbkdf2Sync 占据了绝大部分 CPU 时间。 1.2.4 方法 3——v8-analyticsv8-analytics 是社区开源的一个解析 v8-profiler 和 heapdump 等模块生成的 CPU 和 heap-memory 日志的工具。它提供以下功能： 将 V8 引擎逆优化或者优化失败的函数标红展示，并展示优化失败的原因。 在函数执行时长超过预期时标红展示。 展示当前项目中可疑的内存泄漏点。 我们以上述第 2 个功能为例，使用 v8-analytics 分析 CPU 的使用情况。 首先，全局安装 v8-analytics： 1$ npm i v8-analytics -g 使用以下命令查看执行时间大于 200ms 的函数： 1$ va timeout cpuprofile-xxx.cpuprofile 200 --only 结果截图如下： 可以看出：我们依然能够定位到 encryptRouter 和 exports.pbkdf2Sync。 1.2.5 参考链接 https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution http://www.ebaytechblog.com/2016/06/15/igniting-node-js-flames/ https://cnodejs.org/topic/58b562f97872ea0864fee1a7 https://github.com/hyj1991/v8-analytics/blob/master/README_ZH.md","categories":[{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"}]},{"title":"Nuxt.js 基础入门教程","slug":"Nuxtjs 基础入门教程","date":"2020-05-21T06:12:31.000Z","updated":"2022-05-24T23:05:19.839Z","comments":true,"path":"2020/05/21/Nuxtjs 基础入门教程/","link":"","permalink":"https://marvinliu1.github.io/2020/05/21/Nuxtjs%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"原文链接 Vue 开发一个单页面应用，相信很多前端工程师都已经学会了，但是单页面应用有一个致命的缺点，就是 SEO 极不友好。除非，vue 能在服务端渲染（ssr）并直接返回已经渲染好的页面，而并非只是一个单纯的 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;。 Nuxt.js 就是一个极简的 vue 版的 ssr 框架。基于它，我们可以快速开发一个基于 vue 的 ssr 单页面应用。 安装Nuxt.js 官方提供了一个模板，可以使用 vue-cli 直接安装。 1$ vue init nuxt-community/starter-template &lt;project-name&gt; 目录结构1234567891011121314.├── README.md├── assets├── components├── layouts├── middleware├── node_modules├── nuxt.config.js├── package.json├── pages├── plugins├── static├── store└── yarn.lock 其中： assets: 资源文件。放置需要经过 webpack 打包处理的资源文件，如 scss，图片，字体等。 components: 组件。这里存放在页面中，可以复用的组件。 layouts: 布局。页面都需要有一个布局，默认为 default。它规定了一个页面如何布局页面。所有页面都会加载在布局页面中的 &lt;nuxt /&gt; 标签中。如果需要在普通页面中使用下级路由，则需要在页面中添加 &lt;nuxt-child /&gt;。该目录名为Nuxt.js保留的，不可更改。 middleware: 中间件。存放中间件。可以在页面中调用： middleware: &#39;middlewareName&#39; 。 pages: 页面。一个 vue 文件即为一个页面。index.vue 为根页面。 若需要二级页面，则添加文件夹即可。 如果页面的名称类似于 _id.vue （以 _ 开头），则为动态路由页面，_ 后为匹配的变量（params）。 若变量是必须的，则在文件夹下建立空文件 index.vue。更多的配置请移步至 官网 。 plugin: 插件。用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。需要注意的是，在任何 Vue 组件的生命周期内， 只有 beforeCreate 和 created 这两个钩子方法会在 *客户端和服务端均被调用*。其他钩子方法仅在客户端被调用。 static: 静态文件。放置不需要经过 webpack 打包的静态资源。如一些 js, css 库。 store: 状态管理。具体使用请移步至 官网。 nuxt.config.js: nuxt.config.js 文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。具体配置请移步至 官网。 Nuxt 特有函数首先，了解一下在 nuxt 的页面中独有的函数&#x2F;变量： asyncData(context)asyncData方法使得你能够在渲染组件之前异步获取数据。该方法在服务端中执行的，所以，请求数据时，不存在跨域问题。返回的数据将与 data() 返回的数据进行合并。由于asyncData方法是在组件 *初始化* 前被调用的，所以在方法内是没有办法通过 this 来引用组件的实例对象。 context 变量的可用属性一览： 属性字段 类型 可用 描述 isClient Boolean 客户端 &amp; 服务端 是否来自客户端渲染 isServer Boolean 客户端 &amp; 服务端 是否来自服务端渲染 isDev Boolean 客户端 &amp; 服务端 是否是开发(dev) 模式，在生产环境的数据缓存中用到 route vue-router 路由 客户端 &amp; 服务端 vue-router 路由实例。 store vuex 数据流 客户端 &amp; 服务端 Vuex.Store 实例。只有vuex 数据流存在相关配置时可用。 env Object 客户端 &amp; 服务端 nuxt.config.js 中配置的环境变量, 见 环境变量 api params Object 客户端 &amp; 服务端 route.params 的别名 query Object 客户端 &amp; 服务端 route.query 的别名 req http.Request 服务端 Node.js API 的 Request 对象。如果 nuxt 以中间件形式使用的话，这个对象就根据你所使用的框架而定。nuxt generate 不可用。 res http.Response 服务端 Node.js API 的 Response 对象。如果 nuxt 以中间件形式使用的话，这个对象就根据你所使用的框架而定。nuxt generate 不可用。 redirect Function 客户端 &amp; 服务端 用这个方法重定向用户请求到另一个路由。状态码在服务端被使用，默认 302。redirect([status,] path [, query]) error Function 客户端 &amp; 服务端 用这个方法展示错误页：error(params)。params 参数应该包含 statusCode 和 message 字段。 fetch(context)fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据。为了让获取过程可以异步，你需要返回一个 Promise，Nuxt.js 会等这个 promise 完成后再渲染组件。 fetch 会在组件每次加载前被调用（在服务端或切换至目标路由之前）。 headNuxt.js 使用了 vue-meta 更新应用的 头部标签(Head) 和 html 属性。 用于更新 头部信息。如 title，descripe 等。在 head 方法里可通过 this 关键字来获取组件的数据。 layout指定该页面使用哪个布局文件。默认值为 default。 middleware需要执行的中间件，如鉴权的 auth等。 transition指定页面切换时的动画效果。支持传入 String, Object, Function。具体配置请移步至 官网 。 validateNuxt.js 可以让你在动态路由对应的页面组件中配置一个校验方法用于校验动态路由参数的有效性。 返回 true 说明路由有效，则进入路由页面。返回不是 true 则显示 404 页面。 Begin Coding前置工作API在这里，我们使用 CNode API 进行开发 Demo. axios请求数据，我们使用 Nuxt 官方提供的 @nuxtjs&#x2F;axios 安装后，在 nuxt.config.js 中加上： 1234567891011export default &#123; ... modules: [ &#x27;@nuxtjs/axios&#x27; ], axios: &#123; baseURL: &#x27;https://cnodejs.org/api/v1&#x27;, // or other axios configs. &#125; ...&#125; 就可以在页面中通过 this.$axios.$get 来获取数据，不需要在每个页面都单独引入 axios. scss需要先安装 sass-loader 和 node-sass 1$ yarn add sass-loader node-sass --dev 如果需要在项目中全局使用某个 scss 文件（如 mixins, vars 等），需要借助 sass-resources-loader : yarn add sass-resources-loader —dev， 还需要在 nuxt.config.js 的 build 配置中调整导出的 loader 配置： 123456789101112131415161718192021222324252627export default &#123; ... build: &#123; extend(config, &#123; isDev, isClient &#125;) &#123; const sassResourcesLoader = &#123; loader: &#x27;sass-resources-loader&#x27;, options: &#123; resources: [ // 填写需要全局注入 scss 的文件。引入后，所有页面均有效。 &#x27;assets/styles/mixins.scss&#x27; ] &#125; &#125; // 修改 scss sass 引用的 loader。 config.module.rules.forEach((rule) =&gt; &#123; if (rule.test.toString() === &#x27;/\\\\.vue$/&#x27;) &#123; rule.options.loaders.sass.push(sassResourcesLoader) rule.options.loaders.scss.push(sassResourcesLoader) &#125; if ([&#x27;/\\\\.sass$/&#x27;, &#x27;/\\\\.scss$/&#x27;].indexOf(rule.test.toString()) !== -1) &#123; rule.use.push(sassResourcesLoader) &#125; &#125;) &#125; &#125; ...&#125; 首页首页一般只需要简单的获取首页数据并渲染即可。 主要 代码： 123456789asyncData(&#123;app, query&#125;) &#123; console.log(query) // 根据不用的标签获取不同的数据，最后返回话题列表。 return app.$axios.$get(`topics?tab=$&#123;query.tab || &#x27;&#x27;&#125;`).then(res =&gt; &#123; // console.log(res) // console.log(JSON.parse(res)) return &#123;list: res.data&#125; &#125;)&#125; 当进入首页时，该函数会被执行， nuxt 会等到获取数据后再和组件的 data 合并，进而渲染数据。在模板中，可以直接使用 list 变量获取数据。 123456789101112131415&lt;div class=&quot;card fluid topic&quot; v-for=&quot;topic in list&quot; :key=&quot;topic.id&quot; &gt; &lt;div class=&quot;section&quot;&gt; &lt;h3&gt;&lt;nuxt-link :to=&quot;&#123;name: &#x27;topic-id&#x27;, params: &#123;id: topic.id&#125;&#125;&quot; class=&quot;topic-title&quot;&gt;&#123;&#123;topic.title&#125;&#125;&lt;/nuxt-link&gt;&lt;/h3&gt; &lt;p class=&quot;topic-info&quot;&gt; &lt;mark v-if=&quot;topic.top&quot; class=&quot;tertiary&quot;&gt;精华&lt;/mark&gt; &lt;mark v-else&gt;&#123;&#123;tabsObj[topic.tab]&#125;&#125;&lt;/mark&gt; &lt;span class=&quot;avatar&quot;&gt; &lt;img :src=&quot;topic.author.avatar_url&quot; alt=&quot;&quot;&gt; &lt;/span&gt; &lt;span class=&quot;username&quot;&gt; &#123;&#123;topic.author.loginname&#125;&#125; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 在这里提及一下， &lt;nuxt-link /&gt; 和 &lt;a /&gt; 的区别是： nuxt-link 走的是 vue-router 的路由，即网页已为单页面，并且浏览器不会重定向。而 a 标签走的是 window.location.href，每一次点击 a 标签后的页面，都会进行一次服务端渲染，和普通的 PHP 混合开发没有太大的区别。 在这里使用了 nuxt-link 是因为 CNode 的 API 不存在跨域问题，因此可以作为一个单页面应用，体验更好。 因为列表页数据类型有多种，该页面可能会被复用，所以当路由对象发生变化时，需要重新获取数据，这时可以监听路由的变化以做出响应： 123456watch: &#123; &#x27;$route&#x27;: function() &#123; console.log(&#x27;$route has changed.&#x27;) this.getData() &#125;&#125; 配置 seo 优化（这里只是单纯的复制罢了，demo 使用，侵删）： 12345678910head() &#123; return &#123; title: &#x27;首页&#x27; + (this.$route.query.tab ? `- $&#123;this.tabsObj[this.$route.query.tab]&#125;` : &#x27;&#x27;), meta: [&#123; hid: &#x27;description&#x27;, name: &#x27;description&#x27;, content: &#x27;CNode：Node.js专业中文社区&#x27; &#125;] &#125;&#125; 话题详情同样的，使用 asyncData 函数进行获取数据，再渲染页面。 12345678910111213141516asyncData(&#123;app, params&#125;) &#123; console.log(params) return app.$axios.$get(&#x27;topic/&#x27; + params.id).then(res =&gt; &#123; // let data = res.data instanceof String ? JSON.parse(res.data) : res.data let data = res.data // console.log(res) // let div = document.createElement(&#x27;div&#x27;) // div.innerHTML = res.data.data.content // res.data.summary = div.innerText.substr(0, 120) data.summary = data.content.replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;).substr(0, 120).replace(/\\s+/g, &#x27;&#x27;) return &#123;detail: data&#125; &#125;).catch(err =&gt; &#123; console.log(&#x27;axios.get failed.&#x27;) console.error(err) &#125;)&#125; 在这里，踩过坑。想使用 div 的 innerText 来过滤掉正文中的 HTML 标签，但是，如果用户是直接进入这个页面的时候，执行 asyncData 时，document 对象是不存在的，从而会报错。也就是说，当 asyncData 在服务端执行时，是没有 document 和 window 对象的，请大家注意一下。 作为一个社区，seo 尤为重要，倘若每个页面都需要写一大堆的 head 对象，就会显得尤其的繁琐。所以可以借助 nuxt 的 plugin 机制，将其封装成一个函数，并注入到每一个页面当中： 123456789101112131415161718// plugins/global.jsimport Vue from &#x27;vue&#x27;Vue.mixin(&#123; methods: &#123; // 必传 标题，描述。其他的 meta 标签通过 payload 注入，其中，每个 meta 的 hid 需要是唯一的。 $seo(title, content, payload = []) &#123; return &#123; title, meta: [&#123; hid: &#x27;description&#x27;, name: &#x27;description&#x27;, content &#125;].concat(payload) &#125; &#125; &#125;&#125;) 在 nuxt.config.js 中加上： 12345export default &#123; plugins: [ &#x27;~plugins/global.js&#x27; ]&#125; 这样，只需要在页面的 head 的函数中，返回该函数即可： 123head() &#123; return this.$seo(this.detail.title, this.detail.summary)&#125; 可见，详情页已经成功的设置了部分 seo 的标签。 以上是 Nuxt 的一些基础配置及应用。 我再去研究一下， fetch 和 store 的结合，将该 demo 继续完善。 Demo 线上地址GitHub 地址","categories":[{"name":"Nuxt","slug":"Nuxt","permalink":"https://marvinliu1.github.io/categories/Nuxt/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://marvinliu1.github.io/tags/Vue/"},{"name":"Nuxt","slug":"Nuxt","permalink":"https://marvinliu1.github.io/tags/Nuxt/"},{"name":"Javascript","slug":"Javascript","permalink":"https://marvinliu1.github.io/tags/Javascript/"}]},{"title":"Adding tag cloud","slug":"Adding-tag-cloud","date":"2018-06-21T06:26:30.000Z","updated":"2022-05-23T04:41:59.583Z","comments":true,"path":"2018/06/21/Adding-tag-cloud/","link":"","permalink":"https://marvinliu1.github.io/2018/06/21/Adding-tag-cloud/","excerpt":"","text":"Step 1: Install the plugin hexo-tag-cloud1npm install hexo-tag-cloud@^2.0.* --save Step 2: ConfigurationFor the SwigLocate the file bash theme/next/layout/_macro/sidebar.swig 123456789101112&#123;% if site.tags.length &gt; 1 %&#125;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;&lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;标签云&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &#123;&#123; list_tags() &#125;&#125; &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; For the ejsLocated the file bash hexo/themes/landscape/layout/_widget/tagcloud.ejs 12345678910111213&lt;% if (site.tags.length) &#123; %&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt; &lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &lt;%- tagcloud() %&gt; &lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt; For the jadeLocate the file bash apollo/layout/archive.jade 123456789101112block container include mixins/post .archive h2(class=&#x27;archive-year&#x27;)= &#x27;Tag Cloud&#x27; script(type=&#x27;text/javascript&#x27;, charset=&#x27;utf-8&#x27;, src=&#x27;/oj-code/js/tagcloud.js&#x27;) script(type=&#x27;text/javascript&#x27;, charset=&#x27;utf-8&#x27;, src=&#x27;/oj-code/js/tagcanvas.js&#x27;) #myCanvasContainer.widget.tagcloud(align=&#x27;center&#x27;) canvas#resCanvas(width=&#x27;500&#x27;, height=&#x27;500&#x27;, style=&#x27;width=100%&#x27;) !=tagcloud() !=tagcloud() +postList() Step 3: Config the themeLocate the config file in your theme folder bash _config.yml Adding new lines below in the end of the config file 1234567# hexo-tag-cloudtag_cloud: textFont: Trebuchet MS, Helvetica textColor: &#x27;#333&#x27; textHeight: 25 outlineColor: &#x27;#E2E1D1&#x27; maxSpeed: 0.1","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/tags/Hexo/"},{"name":"NeXt","slug":"NeXt","permalink":"https://marvinliu1.github.io/tags/NeXt/"}]},{"title":"Hexo: Update server automatically","slug":"Hexo-update-server-automatically","date":"2018-05-20T21:45:26.000Z","updated":"2022-05-21T07:36:18.586Z","comments":true,"path":"2018/05/20/Hexo-update-server-automatically/","link":"","permalink":"https://marvinliu1.github.io/2018/05/20/Hexo-update-server-automatically/","excerpt":"","text":"How to update the Hexo server automatically:Sometimes you may want to update your Hexo server after editing a post or creating a new one, here is how to use Browsersync to achieve that. Step 1: Install the Browsersync1&gt;npm install -g browser-sync Step 2: Install Hexo plugin1&gt;npm install hexo-browsersync --save Step 3: Start your Hexo service1hexo s","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-02T07:26:30.000Z","updated":"2022-05-21T08:41:13.026Z","comments":true,"path":"2018/01/02/hello-world/","link":"","permalink":"https://marvinliu1.github.io/2018/01/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/categories/Hexo/"},{"name":"Nuxt","slug":"Nuxt","permalink":"https://marvinliu1.github.io/categories/Nuxt/"},{"name":"Node in Debugging","slug":"Node-in-Debugging","permalink":"https://marvinliu1.github.io/categories/Node-in-Debugging/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://marvinliu1.github.io/tags/Hexo/"},{"name":"NeXt","slug":"NeXt","permalink":"https://marvinliu1.github.io/tags/NeXt/"},{"name":"Vue","slug":"Vue","permalink":"https://marvinliu1.github.io/tags/Vue/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://marvinliu1.github.io/tags/MarkDown/"},{"name":"Next","slug":"Next","permalink":"https://marvinliu1.github.io/tags/Next/"},{"name":"Node","slug":"Node","permalink":"https://marvinliu1.github.io/tags/Node/"},{"name":"Debugging","slug":"Debugging","permalink":"https://marvinliu1.github.io/tags/Debugging/"},{"name":"Nuxt","slug":"Nuxt","permalink":"https://marvinliu1.github.io/tags/Nuxt/"},{"name":"Javascript","slug":"Javascript","permalink":"https://marvinliu1.github.io/tags/Javascript/"}]}